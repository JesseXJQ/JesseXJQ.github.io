{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/cactus-dark/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/cactus-dark/source/images/apple-touch-icon.png","path":"images/apple-touch-icon.png","modified":0,"renderable":1},{"_id":"themes/cactus-dark/source/images/favicon-192x192.png","path":"images/favicon-192x192.png","modified":0,"renderable":1},{"_id":"themes/cactus-dark/source/images/favicon.ico","path":"images/favicon.ico","modified":0,"renderable":1},{"_id":"themes/cactus-dark/source/images/logo.png","path":"images/logo.png","modified":0,"renderable":1},{"_id":"themes/cactus-dark/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/cactus-dark/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/cactus-dark/source/lib/justified-gallery/jquery.justifiedGallery.min.js","path":"lib/justified-gallery/jquery.justifiedGallery.min.js","modified":0,"renderable":1},{"_id":"themes/cactus-dark/source/lib/justified-gallery/justifiedGallery.min.css","path":"lib/justified-gallery/justifiedGallery.min.css","modified":0,"renderable":1},{"_id":"themes/cactus-dark/source/lib/meslo-LG/styles.css","path":"lib/meslo-LG/styles.css","modified":0,"renderable":1},{"_id":"themes/cactus-dark/source/lib/jquery/jquery.min.js","path":"lib/jquery/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/cactus-dark/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/cactus-dark/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/cactus-dark/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/cactus-dark/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/cactus-dark/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/cactus-dark/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/cactus-dark/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/cactus-dark/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGL-Italic.ttf","path":"lib/meslo-LG/fonts/MesloLGL-Italic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGL-Regular.ttf","path":"lib/meslo-LG/fonts/MesloLGL-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGM-Bold.ttf","path":"lib/meslo-LG/fonts/MesloLGM-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGM-BoldItalic.ttf","path":"lib/meslo-LG/fonts/MesloLGM-BoldItalic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGM-Italic.ttf","path":"lib/meslo-LG/fonts/MesloLGM-Italic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGS-Bold.ttf","path":"lib/meslo-LG/fonts/MesloLGS-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGM-Regular.ttf","path":"lib/meslo-LG/fonts/MesloLGM-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGS-BoldItalic.ttf","path":"lib/meslo-LG/fonts/MesloLGS-BoldItalic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGS-Italic.ttf","path":"lib/meslo-LG/fonts/MesloLGS-Italic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGS-Regular.ttf","path":"lib/meslo-LG/fonts/MesloLGS-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGL-BoldItalic.ttf","path":"lib/meslo-LG/fonts/MesloLGL-BoldItalic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGL-Bold.ttf","path":"lib/meslo-LG/fonts/MesloLGL-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/cactus-dark/source/images/theme overview.psd","path":"images/theme overview.psd","modified":0,"renderable":1}],"Cache":[{"_id":"themes/cactus-dark/.DS_Store","hash":"4db31f65a149e1334d7fe87baa95cda9388401cc","modified":1595009926038},{"_id":"themes/cactus-dark/LICENSE","hash":"4d5f5f360a18c68f0fd1897bdb1eb1210c2893e3","modified":1516813406000},{"_id":"themes/cactus-dark/README.md","hash":"e4dfd8af96e2d01d17ac4720ccbe799dec1a5997","modified":1516813406000},{"_id":"themes/cactus-dark/_config.yml","hash":"a9e9f59877c6c95483353b716aa00e151e73b4b8","modified":1516862150000},{"_id":"source/CNAME","hash":"bf815241540ab253820174b071304ab580cde491","modified":1516945524000},{"_id":"themes/cactus-dark/layout/archive.ejs","hash":"b5e70bd2780d044b94e22ce8af0afb114c2a6eae","modified":1516813406000},{"_id":"themes/cactus-dark/layout/index.ejs","hash":"2b7ea6af1e6f848bffb1fac53c00a1eb04a30c8a","modified":1516813406000},{"_id":"themes/cactus-dark/layout/layout.ejs","hash":"8484532ad7c4da22f46fc1394bb2fd9ded34be1f","modified":1516813406000},{"_id":"themes/cactus-dark/layout/page.ejs","hash":"d14964cac07f5db45d83af682a7924413f7dd3b6","modified":1516813406000},{"_id":"themes/cactus-dark/layout/post.ejs","hash":"2731e597b5d1714a6f5a775c432e99785f02a3e3","modified":1516813406000},{"_id":"themes/cactus-dark/scripts/meta.js","hash":"fa6055a39851c9953d033e70c1614547b94dce60","modified":1516813406000},{"_id":"themes/cactus-dark/scripts/thumbnail.js","hash":"df8829fd8c3119650037eba5ec11bdce06acff9d","modified":1516813406000},{"_id":"source/_posts/DailyTools.md","hash":"dedb2fa6cfba11c7e85baf97d632896ae7c568b4","modified":1523863690000},{"_id":"source/_posts/IDEA创建JEE项目.md","hash":"21237dc84acf4d55b5f521b9885493100f189a43","modified":1516814580000},{"_id":"source/_posts/Kindle Note.md","hash":"4d1fb234f8ce9982bd0b38f70a910f71c37d2cd0","modified":1523702528000},{"_id":"source/_posts/Windows平台最优秀的解压软件：Bandizip.md","hash":"0083476be93fa574403dc218497dca01263044f1","modified":1516877292000},{"_id":"source/about/index.md","hash":"bdf7360f50216c0167af77e89285a33b8d4b347b","modified":1516867674000},{"_id":"themes/cactus-dark/layout/_partial/comments.ejs","hash":"853a4500da515ef3facc51a055886eaf8efd080d","modified":1516813406000},{"_id":"themes/cactus-dark/layout/_partial/footer.ejs","hash":"84405f28558404641fa35fdd49b02b538ea056cc","modified":1521773304000},{"_id":"themes/cactus-dark/layout/_partial/head.ejs","hash":"7782e6b1ce72fcf121f0017d383e2fb87e72c539","modified":1516813406000},{"_id":"themes/cactus-dark/layout/_partial/header.ejs","hash":"889fe54bbfd1fb3357e8c0614d57a437a72f782a","modified":1516813406000},{"_id":"themes/cactus-dark/layout/_partial/pagination.ejs","hash":"ca660c59aec56daa4a7b41715b97434d4a24c37e","modified":1516813406000},{"_id":"themes/cactus-dark/layout/_partial/scripts.ejs","hash":"ccb989b34754fad61631703630a19abe1b16dddf","modified":1516813406000},{"_id":"themes/cactus-dark/layout/_partial/search.ejs","hash":"1812a10645f635fa8467bf71eed57e704fa3b7cd","modified":1516813406000},{"_id":"themes/cactus-dark/layout/_partial/styles.ejs","hash":"6eb7189f05783e7044c7dab16e671176329e7cd3","modified":1516813406000},{"_id":"themes/cactus-dark/source/css/_extend.styl","hash":"faca25132d55e8989d1c1d638e55d1e97de3c561","modified":1516813406000},{"_id":"themes/cactus-dark/source/css/_mixins.styl","hash":"c921ceb620deedddd38c9cec28190995e8764bab","modified":1516813406000},{"_id":"themes/cactus-dark/source/css/_util.styl","hash":"f8e286a21c7ec3e771d5ddeb2909ac92390af9bd","modified":1516813406000},{"_id":"themes/cactus-dark/source/css/_variables.styl","hash":"80345f77f0e601669047cbb3c44491720c3b5c13","modified":1516813406000},{"_id":"themes/cactus-dark/source/css/style.styl","hash":"b095c98ad8c7e59b297f61f1fde7171a05b1997e","modified":1516813406000},{"_id":"themes/cactus-dark/source/images/apple-touch-icon.png","hash":"57e2def34682655f41a0be2d083f16765ba7858b","modified":1516813406000},{"_id":"themes/cactus-dark/source/images/favicon-192x192.png","hash":"96e6fcbbb13a5914a6131391e210eb7dfd13d692","modified":1516813406000},{"_id":"themes/cactus-dark/source/images/favicon.ico","hash":"189f9842bcb79a6f8f9e8445bc8bbd773443826b","modified":1516813406000},{"_id":"themes/cactus-dark/source/images/logo.png","hash":"199750f3a39251ca97d36ed8317d88dfdc2dfe66","modified":1516813406000},{"_id":"themes/cactus-dark/source/js/main.js","hash":"2703a7cb4fc7056d13215b9fde675da426b9cdc4","modified":1516813406000},{"_id":"themes/cactus-dark/source/js/search.js","hash":"62493e5477618f259eec9b9d626f5bfd000589df","modified":1516813406000},{"_id":"source/_posts/Leetcode-Summary.md","hash":"213f888df4fb2d1f48343ddaabb6acb872a74fbf","modified":1579557882000},{"_id":"themes/cactus-dark/layout/_partial/post/actions_desktop.ejs","hash":"063ae931a6902f192e086fe5cceae587d27ed196","modified":1516813406000},{"_id":"themes/cactus-dark/layout/_partial/post/actions_mobile.ejs","hash":"64d0f85480997a4fa53c99954e9454c189595e9c","modified":1516813406000},{"_id":"themes/cactus-dark/layout/_partial/post/date.ejs","hash":"12a4a7ba6334e3e5c03d9a9601d7779a27c2e082","modified":1516813406000},{"_id":"themes/cactus-dark/layout/_partial/post/gallery.ejs","hash":"9aecd8908e8a684f33dc20c02497c0f1774137c7","modified":1516813406000},{"_id":"themes/cactus-dark/layout/_partial/post/share.ejs","hash":"25a3406f97e976ec13239f0d3f32f9e512511f50","modified":1516813406000},{"_id":"themes/cactus-dark/layout/_partial/post/tag.ejs","hash":"bfab03ef986d35ccad583f2d2b575db4a8d2789e","modified":1516813406000},{"_id":"themes/cactus-dark/layout/_partial/post/title.ejs","hash":"a060f1c6e3718494a6b1d0e1981ea0bf4e549828","modified":1516813406000},{"_id":"themes/cactus-dark/source/css/_highlight/agate.styl","hash":"601eb70448a16b918df132f6fc41e891ae053653","modified":1516813406000},{"_id":"themes/cactus-dark/source/css/_highlight/androidstudio.styl","hash":"65d09f1b0e81c6a182f549fd3de51e59823c97ae","modified":1516813406000},{"_id":"themes/cactus-dark/source/css/_highlight/arta.styl","hash":"1a5accc115f41d1b669ed708ac6a29abac876599","modified":1516813406000},{"_id":"themes/cactus-dark/source/css/_highlight/atelier-cave-dark.styl","hash":"bc647b2c1d971d7cc947aa1ed66e9fd115261921","modified":1516813406000},{"_id":"themes/cactus-dark/source/css/_highlight/atelier-dune-dark.styl","hash":"df50a85a4b14c7ca6e825d665594b91229d0e460","modified":1516813406000},{"_id":"themes/cactus-dark/source/css/_highlight/atelier-estuary-dark.styl","hash":"d84382bc8298f96730757391d3e761b7e640f406","modified":1516813406000},{"_id":"themes/cactus-dark/source/css/_highlight/atelier-forest-dark.styl","hash":"57c154c6045a038dc7df0a25927853e10bf48c4a","modified":1516813406000},{"_id":"themes/cactus-dark/source/css/_highlight/atelier-heath-dark.styl","hash":"b0cf13b2233e7bc38342032d2d7296591a4c2bcf","modified":1516813406000},{"_id":"themes/cactus-dark/source/css/_highlight/atelier-lakeside-dark.styl","hash":"bb0a8c4ad0dd8e3e7de7122ddf268fc42aa94acb","modified":1516813406000},{"_id":"themes/cactus-dark/source/css/_highlight/atelier-plateau-dark.styl","hash":"09c64f1a7052aec9070c36c0431df25216afaea1","modified":1516813406000},{"_id":"themes/cactus-dark/source/css/_highlight/atelier-savanna-dark.styl","hash":"a16c919a1ccf2f845488078fb341381bec46b1f3","modified":1516813406000},{"_id":"themes/cactus-dark/source/css/_highlight/atelier-seaside-dark.styl","hash":"ce233a101daea7124cbfcd34add43ccfe2e1e1c7","modified":1516813406000},{"_id":"themes/cactus-dark/source/css/_highlight/atelier-sulphurpool-dark.styl","hash":"414b0cfc142f70afe359c16450b651e28bf7325a","modified":1516813406000},{"_id":"themes/cactus-dark/source/css/_highlight/codepen-embed.styl","hash":"f4dcc84d8e39f9831a5efe80e51923fc3054feb0","modified":1516813406000},{"_id":"themes/cactus-dark/source/css/_highlight/dark.styl","hash":"71ce56d311cc2f3a605f6e2c495ccd7236878404","modified":1516813406000},{"_id":"themes/cactus-dark/source/css/_highlight/darkula.styl","hash":"ad0d5728d21645039c9f199e7a56814170ed3bab","modified":1516813406000},{"_id":"themes/cactus-dark/source/css/_highlight/far.styl","hash":"d9928010ffe71e80b97a5afcba1a4975efdd7372","modified":1516813406000},{"_id":"themes/cactus-dark/source/css/_highlight/hopscotch.styl","hash":"b374c6550b89b4751aedc8fbc3cf98d95bd70ead","modified":1516813406000},{"_id":"themes/cactus-dark/source/css/_highlight/hybrid.styl","hash":"ea8d7ddc258b073308746385f5cb85aabb8bfb83","modified":1516813406000},{"_id":"themes/cactus-dark/source/css/_highlight/ir-black.styl","hash":"693078bbd72a2091ed30f506cc55949600b717af","modified":1516813406000},{"_id":"themes/cactus-dark/source/css/_highlight/kimbie.styl","hash":"45dbb168f22d739d0109745d2decd66b5f94e786","modified":1516813406000},{"_id":"themes/cactus-dark/source/css/_highlight/monokai-sublime.styl","hash":"25aa2fc1dbe38593e7c7ebe525438a39574d9935","modified":1516813406000},{"_id":"themes/cactus-dark/source/css/_highlight/monokai.styl","hash":"5a4fe9f957fd7a368c21b62a818403db4270452f","modified":1516813406000},{"_id":"themes/cactus-dark/source/css/_highlight/obsidian.styl","hash":"55572bbcfee1de6c31ac54681bb00336f5ae826d","modified":1516813406000},{"_id":"themes/cactus-dark/source/css/_highlight/paraiso.styl","hash":"f1537bd868579fa018ecdbfd2eb922dcf3ba2cac","modified":1516813406000},{"_id":"themes/cactus-dark/source/css/_highlight/pojoaque.styl","hash":"77dae9dc41945359d17fe84dbd317f1b40b2ee33","modified":1516813406000},{"_id":"themes/cactus-dark/source/css/_highlight/railscasts.styl","hash":"acd620f8bb7ff0e3fe5f9a22b4433ceef93a05e6","modified":1516813406000},{"_id":"themes/cactus-dark/source/css/_highlight/rainbow.styl","hash":"ce73b858fc0aba0e57ef9fb136c083082746bc1d","modified":1516813406000},{"_id":"themes/cactus-dark/source/css/_highlight/solarized-dark.styl","hash":"702b9299a48c90124e3ac1d45f1591042f2beccc","modified":1516813406000},{"_id":"themes/cactus-dark/source/css/_highlight/sunburst.styl","hash":"a0b5b5129547a23865d400cfa562ea0ac1ee3958","modified":1516813406000},{"_id":"themes/cactus-dark/source/css/_highlight/tomorrow-night-blue.styl","hash":"8b3087d4422be6eb800935a22eb11e035341c4ba","modified":1516813406000},{"_id":"themes/cactus-dark/source/css/_highlight/tomorrow-night-bright.styl","hash":"0ac6af6ecb446b5b60d6226748e4a6532db34f57","modified":1516813406000},{"_id":"themes/cactus-dark/source/css/_highlight/tomorrow-night-eighties.styl","hash":"fa57b3bb7857a160fc856dbe319b31e30cc5d771","modified":1516813406000},{"_id":"themes/cactus-dark/source/css/_highlight/tomorrow-night.styl","hash":"19b3080d4b066b40d50d7e7f297472482b5801fd","modified":1516813406000},{"_id":"themes/cactus-dark/source/css/_highlight/zenburn.styl","hash":"fc5ec840435dad80964d04519d3f882ddc03746a","modified":1516813406000},{"_id":"themes/cactus-dark/source/css/_partial/archive.styl","hash":"18fa7f84a9783c5fb56c9f450ea93bd88408e682","modified":1516813406000},{"_id":"themes/cactus-dark/source/css/_partial/article.styl","hash":"202b775a966d7bc35bf5adc693b62463dec106bb","modified":1516813406000},{"_id":"themes/cactus-dark/source/css/_partial/comments.styl","hash":"11fb41241a13971d23fc3f7e6d60315c7f248396","modified":1516813406000},{"_id":"themes/cactus-dark/source/css/_partial/footer.styl","hash":"b7570de60eaf9aa6b0192bf9c71b9172ff11bfbc","modified":1516813406000},{"_id":"themes/cactus-dark/source/css/_partial/header.styl","hash":"63707d9103a283147ca222fd6f8ff9bffbffe427","modified":1516813406000},{"_id":"themes/cactus-dark/source/css/_partial/index.styl","hash":"e78a3d6254ea6acb339c177692f4d3df7fab87bd","modified":1516813406000},{"_id":"themes/cactus-dark/source/css/_partial/pagination.styl","hash":"03a1b81d60dae3dd55963b7e74a6fee83470e6bb","modified":1516813406000},{"_id":"themes/cactus-dark/source/css/_partial/search.styl","hash":"4bf70f1ecc5f2c41003ca51a8b0255e32c8c6eba","modified":1516813406000},{"_id":"themes/cactus-dark/source/lib/justified-gallery/jquery.justifiedGallery.min.js","hash":"b2683e7a872bc109b1756a65188a37cef7d0bd5c","modified":1516813406000},{"_id":"themes/cactus-dark/source/lib/justified-gallery/justifiedGallery.min.css","hash":"13fbcba5e97aa88b748d94d3efc4718475279907","modified":1516813406000},{"_id":"themes/cactus-dark/source/lib/meslo-LG/styles.css","hash":"eb88d0b9f1bbef99070e9627e2c96d892036bf7e","modified":1516813406000},{"_id":"themes/cactus-dark/source/lib/jquery/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1516813406000},{"_id":"themes/cactus-dark/source/css/_partial/post/actions_desktop.styl","hash":"fb5106e42ab607181145e5f4fb78b8ae717ac263","modified":1516813406000},{"_id":"themes/cactus-dark/source/css/_partial/post/actions_mobile.styl","hash":"e6a802d7ee1023c5fc5fac18bb0ba3dc03ef2ac8","modified":1516813406000},{"_id":"themes/cactus-dark/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1516813406000},{"_id":"themes/cactus-dark/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1516813406000},{"_id":"themes/cactus-dark/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1516813406000},{"_id":"themes/cactus-dark/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1516813406000},{"_id":"themes/cactus-dark/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1516813406000},{"_id":"themes/cactus-dark/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1516813406000},{"_id":"themes/cactus-dark/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1516813406000},{"_id":"themes/cactus-dark/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1516813406000},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGL-Italic.ttf","hash":"96c97a0a098ca40802f948ae56fa37aa6683d034","modified":1516813406000},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGL-Regular.ttf","hash":"2b912dd13f052f645ee19951604610bb350d50af","modified":1516813406000},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGM-Bold.ttf","hash":"a8a8df3393bccc365335fc5eb0a62a6b7ccd32b9","modified":1516813406000},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGM-BoldItalic.ttf","hash":"65ddb11e75ee93909e845ab912a36717c48f1c94","modified":1516813406000},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGM-Italic.ttf","hash":"68700db02debd4b922304134da83b829cbfddfc9","modified":1516813406000},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGS-Bold.ttf","hash":"df202ce09cbdc70bc16b81983a13ef0f94e46f10","modified":1516813406000},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGM-Regular.ttf","hash":"5e220152adefe905b2197f873d7cee99eca50e91","modified":1516813406000},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGS-BoldItalic.ttf","hash":"d895a1bd25e36c58b7f463ebe14de09f186d5ab4","modified":1516813406000},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGS-Italic.ttf","hash":"7f7cdbdcc26279c04046632e22d872f111bc9399","modified":1516813406000},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGS-Regular.ttf","hash":"56fa0e33a390b704afc56af93a31576ccdbbdd9e","modified":1516813406000},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGL-BoldItalic.ttf","hash":"a9a431fc7a6c3a67c98021d4035c12a07a4f1070","modified":1516813406000},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGL-Bold.ttf","hash":"bfa1ed9a263ed78462f06d322de13bd5bd0906b2","modified":1516813406000},{"_id":"themes/cactus-dark/source/images/theme overview.psd","hash":"8dc11d9d289c247423911e962c4eb3a556dc67d1","modified":1516813406000},{"_id":"public/search.xml","hash":"06f0b696c0364f2d94c2fd4fe7fb844e2d7c6eeb","modified":1595010524494},{"_id":"public/about/index.html","hash":"45b8ff71f9a88e8f93770a60c3e2823161bd797b","modified":1595010524788},{"_id":"public/2020/01/20/Leetcode-Summary/index.html","hash":"bbf1654639ed819a65e1d3040db9e1814f3b2607","modified":1595010524788},{"_id":"public/2018/04/14/Kindle Note/index.html","hash":"71dfd96f9345938cac91a64977250d20e4994d03","modified":1595010524788},{"_id":"public/2018/01/25/Windows平台最优秀的解压软件：Bandizip/index.html","hash":"617b6f4a109217753f7453f10780e636834d7263","modified":1595010524788},{"_id":"public/2018/01/25/DailyTools/index.html","hash":"8883e83112a6301e3c07590ff36b78327a8f0177","modified":1595010524788},{"_id":"public/2018/01/25/IDEA创建JEE项目/index.html","hash":"54d6baa5cbb346b4ec014523608b481dc1d34dd2","modified":1595010524788},{"_id":"public/archives/index.html","hash":"40c0d63026753000a766b91e86c21b106b01dbc6","modified":1595010524788},{"_id":"public/archives/2018/index.html","hash":"446d5389a40e9065d4eb1519d365d01f577f9dc1","modified":1595010524788},{"_id":"public/archives/2018/01/index.html","hash":"135da95384088f2612b371b2aa393eaea5f33604","modified":1595010524788},{"_id":"public/archives/2018/04/index.html","hash":"4737411c801f6ca5ab81fc978d4293c7596c158d","modified":1595010524789},{"_id":"public/archives/2020/index.html","hash":"18b59adc67dad9d4fc71df825da3eceb723f9c87","modified":1595010524789},{"_id":"public/archives/2020/01/index.html","hash":"f178da074070db642f64a665c8eaa210125a694d","modified":1595010524789},{"_id":"public/index.html","hash":"9e50586e1c4c62770f6bef8c5ce6025b2fc87346","modified":1595010524789},{"_id":"public/tags/Softwares/index.html","hash":"60c46add2f258e0b3893f6fc142f2f6c0d4c520e","modified":1595010524790},{"_id":"public/tags/JEE/index.html","hash":"ba170c66890b4a42c7a0f211cd3408d9b3882a52","modified":1595010524790},{"_id":"public/tags/Reading/index.html","hash":"38333ee2b571081a7fd2bcebb5f05f8941f614bd","modified":1595010524790},{"_id":"public/tags/Programming/index.html","hash":"61084dde0513e28f91aac63f56ebca5e7d36fe9e","modified":1595010524790},{"_id":"public/CNAME","hash":"bf815241540ab253820174b071304ab580cde491","modified":1595010524796},{"_id":"public/images/apple-touch-icon.png","hash":"57e2def34682655f41a0be2d083f16765ba7858b","modified":1595010524796},{"_id":"public/images/favicon-192x192.png","hash":"96e6fcbbb13a5914a6131391e210eb7dfd13d692","modified":1595010524797},{"_id":"public/images/favicon.ico","hash":"189f9842bcb79a6f8f9e8445bc8bbd773443826b","modified":1595010524797},{"_id":"public/images/logo.png","hash":"199750f3a39251ca97d36ed8317d88dfdc2dfe66","modified":1595010524797},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1595010525063},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1595010525064},{"_id":"public/css/style.css","hash":"6ee22b7752786f7f0384023f9f8e992745e3602e","modified":1595010525067},{"_id":"public/js/main.js","hash":"2703a7cb4fc7056d13215b9fde675da426b9cdc4","modified":1595010525067},{"_id":"public/js/search.js","hash":"62493e5477618f259eec9b9d626f5bfd000589df","modified":1595010525067},{"_id":"public/lib/justified-gallery/justifiedGallery.min.css","hash":"13fbcba5e97aa88b748d94d3efc4718475279907","modified":1595010525067},{"_id":"public/lib/meslo-LG/styles.css","hash":"eb88d0b9f1bbef99070e9627e2c96d892036bf7e","modified":1595010525067},{"_id":"public/lib/justified-gallery/jquery.justifiedGallery.min.js","hash":"b2683e7a872bc109b1756a65188a37cef7d0bd5c","modified":1595010525067},{"_id":"public/lib/jquery/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1595010525067},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1595010525067},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1595010525068},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1595010525068},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1595010525068},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1595010525071},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1595010525079},{"_id":"public/lib/meslo-LG/fonts/MesloLGL-Italic.ttf","hash":"96c97a0a098ca40802f948ae56fa37aa6683d034","modified":1595010525079},{"_id":"public/lib/meslo-LG/fonts/MesloLGM-Italic.ttf","hash":"68700db02debd4b922304134da83b829cbfddfc9","modified":1595010525079},{"_id":"public/lib/meslo-LG/fonts/MesloLGS-Italic.ttf","hash":"7f7cdbdcc26279c04046632e22d872f111bc9399","modified":1595010525079},{"_id":"public/lib/meslo-LG/fonts/MesloLGM-Bold.ttf","hash":"a8a8df3393bccc365335fc5eb0a62a6b7ccd32b9","modified":1595010525081},{"_id":"public/lib/meslo-LG/fonts/MesloLGM-BoldItalic.ttf","hash":"65ddb11e75ee93909e845ab912a36717c48f1c94","modified":1595010525082},{"_id":"public/lib/meslo-LG/fonts/MesloLGS-Bold.ttf","hash":"df202ce09cbdc70bc16b81983a13ef0f94e46f10","modified":1595010525082},{"_id":"public/lib/meslo-LG/fonts/MesloLGM-Regular.ttf","hash":"5e220152adefe905b2197f873d7cee99eca50e91","modified":1595010525082},{"_id":"public/lib/meslo-LG/fonts/MesloLGS-BoldItalic.ttf","hash":"d895a1bd25e36c58b7f463ebe14de09f186d5ab4","modified":1595010525082},{"_id":"public/lib/meslo-LG/fonts/MesloLGS-Regular.ttf","hash":"56fa0e33a390b704afc56af93a31576ccdbbdd9e","modified":1595010525082},{"_id":"public/lib/meslo-LG/fonts/MesloLGL-Bold.ttf","hash":"bfa1ed9a263ed78462f06d322de13bd5bd0906b2","modified":1595010525082},{"_id":"public/lib/meslo-LG/fonts/MesloLGL-BoldItalic.ttf","hash":"a9a431fc7a6c3a67c98021d4035c12a07a4f1070","modified":1595010525083},{"_id":"public/lib/meslo-LG/fonts/MesloLGL-Regular.ttf","hash":"2b912dd13f052f645ee19951604610bb350d50af","modified":1595010525085},{"_id":"public/images/theme overview.psd","hash":"8dc11d9d289c247423911e962c4eb3a556dc67d1","modified":1595010525098}],"Category":[],"Data":[],"Page":[{"title":"about","date":"2018-01-25T22:38:12.000Z","_content":"\n# ABOUT\n\n---\n\n\n\n### About Me\n\n- Stu of DUT\n- Major in SE\n- Tech & Soccer\n\n###  About this Site\n\n- This website will contain the collcation of some useful and cool softwares or plugins. I would like to share the daily softwares and tools to you guys. It's not a kind of professional website but it will be more accessible for all.\n- Also sometimes, I am willing to post my personal evaluation or experience of some hardwares.\n- Technology is a kind of attitude to life. When we pay more attention to it, we will find out that technology is not unattaintable and it is the cornerstone of our current and future society. \n\n\n\n**The real Technology is that you can't feel the existence of Technology.**\n\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2018-01-25 14:38:12\n---\n\n# ABOUT\n\n---\n\n\n\n### About Me\n\n- Stu of DUT\n- Major in SE\n- Tech & Soccer\n\n###  About this Site\n\n- This website will contain the collcation of some useful and cool softwares or plugins. I would like to share the daily softwares and tools to you guys. It's not a kind of professional website but it will be more accessible for all.\n- Also sometimes, I am willing to post my personal evaluation or experience of some hardwares.\n- Technology is a kind of attitude to life. When we pay more attention to it, we will find out that technology is not unattaintable and it is the cornerstone of our current and future society. \n\n\n\n**The real Technology is that you can't feel the existence of Technology.**\n\n","updated":"2018-01-25T08:07:54.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckcqk30wt0001pu9k2zbl5y45","content":"<h1 id=\"ABOUT\"><a href=\"#ABOUT\" class=\"headerlink\" title=\"ABOUT\"></a>ABOUT</h1><hr>\n<h3 id=\"About-Me\"><a href=\"#About-Me\" class=\"headerlink\" title=\"About Me\"></a>About Me</h3><ul>\n<li>Stu of DUT</li>\n<li>Major in SE</li>\n<li>Tech &amp; Soccer</li>\n</ul>\n<h3 id=\"About-this-Site\"><a href=\"#About-this-Site\" class=\"headerlink\" title=\"About this Site\"></a>About this Site</h3><ul>\n<li>This website will contain the collcation of some useful and cool softwares or plugins. I would like to share the daily softwares and tools to you guys. It’s not a kind of professional website but it will be more accessible for all.</li>\n<li>Also sometimes, I am willing to post my personal evaluation or experience of some hardwares.</li>\n<li>Technology is a kind of attitude to life. When we pay more attention to it, we will find out that technology is not unattaintable and it is the cornerstone of our current and future society. </li>\n</ul>\n<p><strong>The real Technology is that you can’t feel the existence of Technology.</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"ABOUT\"><a href=\"#ABOUT\" class=\"headerlink\" title=\"ABOUT\"></a>ABOUT</h1><hr>\n<h3 id=\"About-Me\"><a href=\"#About-Me\" class=\"headerlink\" title=\"About Me\"></a>About Me</h3><ul>\n<li>Stu of DUT</li>\n<li>Major in SE</li>\n<li>Tech &amp; Soccer</li>\n</ul>\n<h3 id=\"About-this-Site\"><a href=\"#About-this-Site\" class=\"headerlink\" title=\"About this Site\"></a>About this Site</h3><ul>\n<li>This website will contain the collcation of some useful and cool softwares or plugins. I would like to share the daily softwares and tools to you guys. It’s not a kind of professional website but it will be more accessible for all.</li>\n<li>Also sometimes, I am willing to post my personal evaluation or experience of some hardwares.</li>\n<li>Technology is a kind of attitude to life. When we pay more attention to it, we will find out that technology is not unattaintable and it is the cornerstone of our current and future society. </li>\n</ul>\n<p><strong>The real Technology is that you can’t feel the existence of Technology.</strong></p>\n"}],"Post":[{"title":"DailyTools","date":"2018-01-26T00:16:41.000Z","_content":"\nThere're some tools I always use during my daily life and I will introduce the detail of some of them in the future.\n\n### Windows\n\n- 系统优化\n  - 火绒安全\n  - 净网大师\n  - RightMenuMgr\n  - CCleaner\n  - Bandizip（压缩）\n  - ThrottleStop（锁频）\n- 系统美化\n  - StartIsBack\n  - XMeters（监控硬件）\n- 效率提升\n  - Listary\n  - Wox\n    - Everything\n  - QuickLook\n  - Seer\n  - AutoHotKey\n- 常用工具\n  - Shadowsocks\n  - 幕布\n  - 墨刀\n  - iSlide（PPT）\n  - Typora（Markdown）\n  - Masterway\n  - SPlayer\n  - 福晰阅读器\n  - Teamviewer\n  - Writage（md转doc）\n- 代码\n  - Sublime Text\n  - JetBrains\n\n### IOS\n\n- iPhone\n  - 系统\n    - Geekbench\n    - AIDA64\n    - 清理君\n  - 工具\n    - Spark（邮件）\n    - 熊猫吃短信\n    - DataFlow（流量监控）\n    - Workflow\n    - 私家藏书\n    - 航班管家\n    - 历史价格查询\n    - Wingy（vps）\n  - 娱乐\n    - JRS体育\n    - Inoreader\n    - Weico\n- iPad\n  - 常用工具\n    - Fantastical（日历）\n    - Airmail\n    - 欧路词典\n    - 极光字典\n    - duet\n    - 博看期刊\n  - 学习工具\n    - Archimedes（计算）\n    - WolframAlpha\n    - PDF Expert\n    - 福晰阅读器\n    - Pythonista（Python IDE）\n    - Source（GitHub）\n    - Textastic Code Editor\n    - MathPad\n\n### Android\n\n- 黑域\n- 绿色守护\n- 夸克浏览器\n- Aris终端桌面\n\n### Chrome\n\n- Adblock Plus\n- Black Menu for Google\n- BookMark Manager\n- Google Keep\n- Imagus\n- Infinity\n- LiveReload\n- Nimbus Screenshot & Screen Video Recorder\n- Proxy SwitchOmega\n- Tampermonkey\n- Vimium\n- 二维码生成器\n- 划词翻译\n- 新浪微博图床","source":"_posts/DailyTools.md","raw":"---\ntitle: DailyTools\ndate: 2018-01-25 16:16:41\ntags: Softwares\n---\n\nThere're some tools I always use during my daily life and I will introduce the detail of some of them in the future.\n\n### Windows\n\n- 系统优化\n  - 火绒安全\n  - 净网大师\n  - RightMenuMgr\n  - CCleaner\n  - Bandizip（压缩）\n  - ThrottleStop（锁频）\n- 系统美化\n  - StartIsBack\n  - XMeters（监控硬件）\n- 效率提升\n  - Listary\n  - Wox\n    - Everything\n  - QuickLook\n  - Seer\n  - AutoHotKey\n- 常用工具\n  - Shadowsocks\n  - 幕布\n  - 墨刀\n  - iSlide（PPT）\n  - Typora（Markdown）\n  - Masterway\n  - SPlayer\n  - 福晰阅读器\n  - Teamviewer\n  - Writage（md转doc）\n- 代码\n  - Sublime Text\n  - JetBrains\n\n### IOS\n\n- iPhone\n  - 系统\n    - Geekbench\n    - AIDA64\n    - 清理君\n  - 工具\n    - Spark（邮件）\n    - 熊猫吃短信\n    - DataFlow（流量监控）\n    - Workflow\n    - 私家藏书\n    - 航班管家\n    - 历史价格查询\n    - Wingy（vps）\n  - 娱乐\n    - JRS体育\n    - Inoreader\n    - Weico\n- iPad\n  - 常用工具\n    - Fantastical（日历）\n    - Airmail\n    - 欧路词典\n    - 极光字典\n    - duet\n    - 博看期刊\n  - 学习工具\n    - Archimedes（计算）\n    - WolframAlpha\n    - PDF Expert\n    - 福晰阅读器\n    - Pythonista（Python IDE）\n    - Source（GitHub）\n    - Textastic Code Editor\n    - MathPad\n\n### Android\n\n- 黑域\n- 绿色守护\n- 夸克浏览器\n- Aris终端桌面\n\n### Chrome\n\n- Adblock Plus\n- Black Menu for Google\n- BookMark Manager\n- Google Keep\n- Imagus\n- Infinity\n- LiveReload\n- Nimbus Screenshot & Screen Video Recorder\n- Proxy SwitchOmega\n- Tampermonkey\n- Vimium\n- 二维码生成器\n- 划词翻译\n- 新浪微博图床","slug":"DailyTools","published":1,"updated":"2018-04-16T07:28:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcqk30wp0000pu9kpt0o537m","content":"<p>There’re some tools I always use during my daily life and I will introduce the detail of some of them in the future.</p>\n<h3 id=\"Windows\"><a href=\"#Windows\" class=\"headerlink\" title=\"Windows\"></a>Windows</h3><ul>\n<li>系统优化<ul>\n<li>火绒安全</li>\n<li>净网大师</li>\n<li>RightMenuMgr</li>\n<li>CCleaner</li>\n<li>Bandizip（压缩）</li>\n<li>ThrottleStop（锁频）</li>\n</ul>\n</li>\n<li>系统美化<ul>\n<li>StartIsBack</li>\n<li>XMeters（监控硬件）</li>\n</ul>\n</li>\n<li>效率提升<ul>\n<li>Listary</li>\n<li>Wox<ul>\n<li>Everything</li>\n</ul>\n</li>\n<li>QuickLook</li>\n<li>Seer</li>\n<li>AutoHotKey</li>\n</ul>\n</li>\n<li>常用工具<ul>\n<li>Shadowsocks</li>\n<li>幕布</li>\n<li>墨刀</li>\n<li>iSlide（PPT）</li>\n<li>Typora（Markdown）</li>\n<li>Masterway</li>\n<li>SPlayer</li>\n<li>福晰阅读器</li>\n<li>Teamviewer</li>\n<li>Writage（md转doc）</li>\n</ul>\n</li>\n<li>代码<ul>\n<li>Sublime Text</li>\n<li>JetBrains</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"IOS\"><a href=\"#IOS\" class=\"headerlink\" title=\"IOS\"></a>IOS</h3><ul>\n<li>iPhone<ul>\n<li>系统<ul>\n<li>Geekbench</li>\n<li>AIDA64</li>\n<li>清理君</li>\n</ul>\n</li>\n<li>工具<ul>\n<li>Spark（邮件）</li>\n<li>熊猫吃短信</li>\n<li>DataFlow（流量监控）</li>\n<li>Workflow</li>\n<li>私家藏书</li>\n<li>航班管家</li>\n<li>历史价格查询</li>\n<li>Wingy（vps）</li>\n</ul>\n</li>\n<li>娱乐<ul>\n<li>JRS体育</li>\n<li>Inoreader</li>\n<li>Weico</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>iPad<ul>\n<li>常用工具<ul>\n<li>Fantastical（日历）</li>\n<li>Airmail</li>\n<li>欧路词典</li>\n<li>极光字典</li>\n<li>duet</li>\n<li>博看期刊</li>\n</ul>\n</li>\n<li>学习工具<ul>\n<li>Archimedes（计算）</li>\n<li>WolframAlpha</li>\n<li>PDF Expert</li>\n<li>福晰阅读器</li>\n<li>Pythonista（Python IDE）</li>\n<li>Source（GitHub）</li>\n<li>Textastic Code Editor</li>\n<li>MathPad</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Android\"><a href=\"#Android\" class=\"headerlink\" title=\"Android\"></a>Android</h3><ul>\n<li>黑域</li>\n<li>绿色守护</li>\n<li>夸克浏览器</li>\n<li>Aris终端桌面</li>\n</ul>\n<h3 id=\"Chrome\"><a href=\"#Chrome\" class=\"headerlink\" title=\"Chrome\"></a>Chrome</h3><ul>\n<li>Adblock Plus</li>\n<li>Black Menu for Google</li>\n<li>BookMark Manager</li>\n<li>Google Keep</li>\n<li>Imagus</li>\n<li>Infinity</li>\n<li>LiveReload</li>\n<li>Nimbus Screenshot &amp; Screen Video Recorder</li>\n<li>Proxy SwitchOmega</li>\n<li>Tampermonkey</li>\n<li>Vimium</li>\n<li>二维码生成器</li>\n<li>划词翻译</li>\n<li>新浪微博图床</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>There’re some tools I always use during my daily life and I will introduce the detail of some of them in the future.</p>\n<h3 id=\"Windows\"><a href=\"#Windows\" class=\"headerlink\" title=\"Windows\"></a>Windows</h3><ul>\n<li>系统优化<ul>\n<li>火绒安全</li>\n<li>净网大师</li>\n<li>RightMenuMgr</li>\n<li>CCleaner</li>\n<li>Bandizip（压缩）</li>\n<li>ThrottleStop（锁频）</li>\n</ul>\n</li>\n<li>系统美化<ul>\n<li>StartIsBack</li>\n<li>XMeters（监控硬件）</li>\n</ul>\n</li>\n<li>效率提升<ul>\n<li>Listary</li>\n<li>Wox<ul>\n<li>Everything</li>\n</ul>\n</li>\n<li>QuickLook</li>\n<li>Seer</li>\n<li>AutoHotKey</li>\n</ul>\n</li>\n<li>常用工具<ul>\n<li>Shadowsocks</li>\n<li>幕布</li>\n<li>墨刀</li>\n<li>iSlide（PPT）</li>\n<li>Typora（Markdown）</li>\n<li>Masterway</li>\n<li>SPlayer</li>\n<li>福晰阅读器</li>\n<li>Teamviewer</li>\n<li>Writage（md转doc）</li>\n</ul>\n</li>\n<li>代码<ul>\n<li>Sublime Text</li>\n<li>JetBrains</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"IOS\"><a href=\"#IOS\" class=\"headerlink\" title=\"IOS\"></a>IOS</h3><ul>\n<li>iPhone<ul>\n<li>系统<ul>\n<li>Geekbench</li>\n<li>AIDA64</li>\n<li>清理君</li>\n</ul>\n</li>\n<li>工具<ul>\n<li>Spark（邮件）</li>\n<li>熊猫吃短信</li>\n<li>DataFlow（流量监控）</li>\n<li>Workflow</li>\n<li>私家藏书</li>\n<li>航班管家</li>\n<li>历史价格查询</li>\n<li>Wingy（vps）</li>\n</ul>\n</li>\n<li>娱乐<ul>\n<li>JRS体育</li>\n<li>Inoreader</li>\n<li>Weico</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>iPad<ul>\n<li>常用工具<ul>\n<li>Fantastical（日历）</li>\n<li>Airmail</li>\n<li>欧路词典</li>\n<li>极光字典</li>\n<li>duet</li>\n<li>博看期刊</li>\n</ul>\n</li>\n<li>学习工具<ul>\n<li>Archimedes（计算）</li>\n<li>WolframAlpha</li>\n<li>PDF Expert</li>\n<li>福晰阅读器</li>\n<li>Pythonista（Python IDE）</li>\n<li>Source（GitHub）</li>\n<li>Textastic Code Editor</li>\n<li>MathPad</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Android\"><a href=\"#Android\" class=\"headerlink\" title=\"Android\"></a>Android</h3><ul>\n<li>黑域</li>\n<li>绿色守护</li>\n<li>夸克浏览器</li>\n<li>Aris终端桌面</li>\n</ul>\n<h3 id=\"Chrome\"><a href=\"#Chrome\" class=\"headerlink\" title=\"Chrome\"></a>Chrome</h3><ul>\n<li>Adblock Plus</li>\n<li>Black Menu for Google</li>\n<li>BookMark Manager</li>\n<li>Google Keep</li>\n<li>Imagus</li>\n<li>Infinity</li>\n<li>LiveReload</li>\n<li>Nimbus Screenshot &amp; Screen Video Recorder</li>\n<li>Proxy SwitchOmega</li>\n<li>Tampermonkey</li>\n<li>Vimium</li>\n<li>二维码生成器</li>\n<li>划词翻译</li>\n<li>新浪微博图床</li>\n</ul>\n"},{"layout":"intellij","title":"IDEA创建JEE项目","date":"2018-01-25T08:21:24.000Z","_content":"\n### 环境准备：\n1. Intellij IDEA 2017.2.5\n2. JAVA jdk1.8.0_45\n3. Tomcat 8.5\n---\n### 项目创建步骤\n1. Create New Project\n  ![初始界面](http://upload-images.jianshu.io/upload_images/8743973-8d9d89c37d902e7e.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n2. 创建JavaEE项目\n  ![配置选项](http://upload-images.jianshu.io/upload_images/8743973-895fe7170bdcbca8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 项目名称\n  ![项目名称](http://upload-images.jianshu.io/upload_images/8743973-ab7c0ef312db8292.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n3. 创建classes和lib文件\n- File--> Project Structure --> Module --> Sources --> WEB-INF\n  ![](http://upload-images.jianshu.io/upload_images/8743973-755cea0a1b43cf90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 创建文件夹\n  ![classes和lib](http://upload-images.jianshu.io/upload_images/8743973-6fb9b0eeecf02ad6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n4. Paths路径配置\n- 选择Paths，选择Use Modules complie Output path，指定路径为上面创建的classes目录\n  ![Paths](http://upload-images.jianshu.io/upload_images/8743973-1b13ca0bedff9022.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n5. 添加依赖路径\n- 切换到 Dependencies  --> \"+\" -->JARs or directories... \n  ![Dependencies](http://upload-images.jianshu.io/upload_images/8743973-720e1884e94ffa56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 选择创建的lib目录\n  ![lib](http://upload-images.jianshu.io/upload_images/8743973-6507f4ac415c7047.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 选择Jar Directory\n  ![Jar Directory](http://upload-images.jianshu.io/upload_images/8743973-23e04c1d0c430d4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n  ![添加成功](http://upload-images.jianshu.io/upload_images/8743973-ee3cabcc9f50f13b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n6. 切换到 Artifacts选项卡，IDEA会为该项目自动创建一个名为“JavaEE_war exploded”的打包方式，表示 打包成war包，并且是文件展开性的，输出路径为当前项目下的 out 文件夹，保持默认即可。另外勾选下“Include in project build”，表示编译的时候就打包部署，勾选“Show content of elements”，表示显示详细的内容列表。\n  ![Artifacts](http://upload-images.jianshu.io/upload_images/8743973-252025698c995aed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n7. 配置Tomcat\n- 点击Edit Configuration\n  ![Edit Configuration](http://upload-images.jianshu.io/upload_images/8743973-c745744bedd77ea4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 添加配置\n  ![Run/Debug Configuration](http://upload-images.jianshu.io/upload_images/8743973-f1d2a8c074861589.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 按下图设置\n  ![](http://upload-images.jianshu.io/upload_images/8743973-6a54aa3e094cfe6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 切换至Deployment\n  ![Deployment](http://upload-images.jianshu.io/upload_images/8743973-dcf12e312de8cd60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n8. 项目建立完成\n\n\n参考：\nhttp://blog.csdn.net/yhao2014/article/details/45740111\nhttp://www.jianshu.com/p/455c7c11dfb2","source":"_posts/IDEA创建JEE项目.md","raw":"---\nlayout: intellij\ntitle: IDEA创建JEE项目\ndate: 2018-01-25 00:21:24\ntags: JEE\n---\n\n### 环境准备：\n1. Intellij IDEA 2017.2.5\n2. JAVA jdk1.8.0_45\n3. Tomcat 8.5\n---\n### 项目创建步骤\n1. Create New Project\n  ![初始界面](http://upload-images.jianshu.io/upload_images/8743973-8d9d89c37d902e7e.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n2. 创建JavaEE项目\n  ![配置选项](http://upload-images.jianshu.io/upload_images/8743973-895fe7170bdcbca8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 项目名称\n  ![项目名称](http://upload-images.jianshu.io/upload_images/8743973-ab7c0ef312db8292.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n3. 创建classes和lib文件\n- File--> Project Structure --> Module --> Sources --> WEB-INF\n  ![](http://upload-images.jianshu.io/upload_images/8743973-755cea0a1b43cf90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 创建文件夹\n  ![classes和lib](http://upload-images.jianshu.io/upload_images/8743973-6fb9b0eeecf02ad6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n4. Paths路径配置\n- 选择Paths，选择Use Modules complie Output path，指定路径为上面创建的classes目录\n  ![Paths](http://upload-images.jianshu.io/upload_images/8743973-1b13ca0bedff9022.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n5. 添加依赖路径\n- 切换到 Dependencies  --> \"+\" -->JARs or directories... \n  ![Dependencies](http://upload-images.jianshu.io/upload_images/8743973-720e1884e94ffa56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 选择创建的lib目录\n  ![lib](http://upload-images.jianshu.io/upload_images/8743973-6507f4ac415c7047.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 选择Jar Directory\n  ![Jar Directory](http://upload-images.jianshu.io/upload_images/8743973-23e04c1d0c430d4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n  ![添加成功](http://upload-images.jianshu.io/upload_images/8743973-ee3cabcc9f50f13b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n6. 切换到 Artifacts选项卡，IDEA会为该项目自动创建一个名为“JavaEE_war exploded”的打包方式，表示 打包成war包，并且是文件展开性的，输出路径为当前项目下的 out 文件夹，保持默认即可。另外勾选下“Include in project build”，表示编译的时候就打包部署，勾选“Show content of elements”，表示显示详细的内容列表。\n  ![Artifacts](http://upload-images.jianshu.io/upload_images/8743973-252025698c995aed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n7. 配置Tomcat\n- 点击Edit Configuration\n  ![Edit Configuration](http://upload-images.jianshu.io/upload_images/8743973-c745744bedd77ea4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 添加配置\n  ![Run/Debug Configuration](http://upload-images.jianshu.io/upload_images/8743973-f1d2a8c074861589.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 按下图设置\n  ![](http://upload-images.jianshu.io/upload_images/8743973-6a54aa3e094cfe6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 切换至Deployment\n  ![Deployment](http://upload-images.jianshu.io/upload_images/8743973-dcf12e312de8cd60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n8. 项目建立完成\n\n\n参考：\nhttp://blog.csdn.net/yhao2014/article/details/45740111\nhttp://www.jianshu.com/p/455c7c11dfb2","slug":"IDEA创建JEE项目","published":1,"updated":"2018-01-24T17:23:00.000Z","comments":1,"photos":[],"link":"","_id":"ckcqk30wt0002pu9kvp0fv8ke","content":"<h3 id=\"环境准备：\"><a href=\"#环境准备：\" class=\"headerlink\" title=\"环境准备：\"></a>环境准备：</h3><ol>\n<li>Intellij IDEA 2017.2.5</li>\n<li>JAVA jdk1.8.0_45</li>\n<li>Tomcat 8.5</li>\n</ol>\n<hr>\n<h3 id=\"项目创建步骤\"><a href=\"#项目创建步骤\" class=\"headerlink\" title=\"项目创建步骤\"></a>项目创建步骤</h3><ol>\n<li>Create New Project<br><img src=\"http://upload-images.jianshu.io/upload_images/8743973-8d9d89c37d902e7e.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"初始界面\"></li>\n<li>创建JavaEE项目<br><img src=\"http://upload-images.jianshu.io/upload_images/8743973-895fe7170bdcbca8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"配置选项\"></li>\n</ol>\n<ul>\n<li>项目名称<br><img src=\"http://upload-images.jianshu.io/upload_images/8743973-ab7c0ef312db8292.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"项目名称\"></li>\n</ul>\n<ol>\n<li>创建classes和lib文件</li>\n</ol>\n<ul>\n<li>File–&gt; Project Structure –&gt; Module –&gt; Sources –&gt; WEB-INF<br><img src=\"http://upload-images.jianshu.io/upload_images/8743973-755cea0a1b43cf90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></li>\n<li>创建文件夹<br><img src=\"http://upload-images.jianshu.io/upload_images/8743973-6fb9b0eeecf02ad6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"classes和lib\"></li>\n</ul>\n<ol>\n<li>Paths路径配置</li>\n</ol>\n<ul>\n<li>选择Paths，选择Use Modules complie Output path，指定路径为上面创建的classes目录<br><img src=\"http://upload-images.jianshu.io/upload_images/8743973-1b13ca0bedff9022.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Paths\"></li>\n</ul>\n<ol>\n<li>添加依赖路径</li>\n</ol>\n<ul>\n<li>切换到 Dependencies  –&gt; “+” –&gt;JARs or directories…<br><img src=\"http://upload-images.jianshu.io/upload_images/8743973-720e1884e94ffa56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Dependencies\"></li>\n<li>选择创建的lib目录<br><img src=\"http://upload-images.jianshu.io/upload_images/8743973-6507f4ac415c7047.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"lib\"></li>\n<li>选择Jar Directory<br><img src=\"http://upload-images.jianshu.io/upload_images/8743973-23e04c1d0c430d4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Jar Directory\"><br><img src=\"http://upload-images.jianshu.io/upload_images/8743973-ee3cabcc9f50f13b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"添加成功\"></li>\n</ul>\n<ol>\n<li>切换到 Artifacts选项卡，IDEA会为该项目自动创建一个名为“JavaEE_war exploded”的打包方式，表示 打包成war包，并且是文件展开性的，输出路径为当前项目下的 out 文件夹，保持默认即可。另外勾选下“Include in project build”，表示编译的时候就打包部署，勾选“Show content of elements”，表示显示详细的内容列表。<br><img src=\"http://upload-images.jianshu.io/upload_images/8743973-252025698c995aed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Artifacts\"></li>\n<li>配置Tomcat</li>\n</ol>\n<ul>\n<li>点击Edit Configuration<br><img src=\"http://upload-images.jianshu.io/upload_images/8743973-c745744bedd77ea4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Edit Configuration\"></li>\n<li>添加配置<br><img src=\"http://upload-images.jianshu.io/upload_images/8743973-f1d2a8c074861589.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Run/Debug Configuration\"></li>\n<li>按下图设置<br><img src=\"http://upload-images.jianshu.io/upload_images/8743973-6a54aa3e094cfe6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></li>\n<li>切换至Deployment<br><img src=\"http://upload-images.jianshu.io/upload_images/8743973-dcf12e312de8cd60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Deployment\"></li>\n</ul>\n<ol>\n<li>项目建立完成</li>\n</ol>\n<p>参考：<br><a href=\"http://blog.csdn.net/yhao2014/article/details/45740111\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/yhao2014/article/details/45740111</a><br><a href=\"http://www.jianshu.com/p/455c7c11dfb2\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/455c7c11dfb2</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"环境准备：\"><a href=\"#环境准备：\" class=\"headerlink\" title=\"环境准备：\"></a>环境准备：</h3><ol>\n<li>Intellij IDEA 2017.2.5</li>\n<li>JAVA jdk1.8.0_45</li>\n<li>Tomcat 8.5</li>\n</ol>\n<hr>\n<h3 id=\"项目创建步骤\"><a href=\"#项目创建步骤\" class=\"headerlink\" title=\"项目创建步骤\"></a>项目创建步骤</h3><ol>\n<li>Create New Project<br><img src=\"http://upload-images.jianshu.io/upload_images/8743973-8d9d89c37d902e7e.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"初始界面\"></li>\n<li>创建JavaEE项目<br><img src=\"http://upload-images.jianshu.io/upload_images/8743973-895fe7170bdcbca8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"配置选项\"></li>\n</ol>\n<ul>\n<li>项目名称<br><img src=\"http://upload-images.jianshu.io/upload_images/8743973-ab7c0ef312db8292.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"项目名称\"></li>\n</ul>\n<ol>\n<li>创建classes和lib文件</li>\n</ol>\n<ul>\n<li>File–&gt; Project Structure –&gt; Module –&gt; Sources –&gt; WEB-INF<br><img src=\"http://upload-images.jianshu.io/upload_images/8743973-755cea0a1b43cf90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></li>\n<li>创建文件夹<br><img src=\"http://upload-images.jianshu.io/upload_images/8743973-6fb9b0eeecf02ad6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"classes和lib\"></li>\n</ul>\n<ol>\n<li>Paths路径配置</li>\n</ol>\n<ul>\n<li>选择Paths，选择Use Modules complie Output path，指定路径为上面创建的classes目录<br><img src=\"http://upload-images.jianshu.io/upload_images/8743973-1b13ca0bedff9022.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Paths\"></li>\n</ul>\n<ol>\n<li>添加依赖路径</li>\n</ol>\n<ul>\n<li>切换到 Dependencies  –&gt; “+” –&gt;JARs or directories…<br><img src=\"http://upload-images.jianshu.io/upload_images/8743973-720e1884e94ffa56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Dependencies\"></li>\n<li>选择创建的lib目录<br><img src=\"http://upload-images.jianshu.io/upload_images/8743973-6507f4ac415c7047.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"lib\"></li>\n<li>选择Jar Directory<br><img src=\"http://upload-images.jianshu.io/upload_images/8743973-23e04c1d0c430d4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Jar Directory\"><br><img src=\"http://upload-images.jianshu.io/upload_images/8743973-ee3cabcc9f50f13b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"添加成功\"></li>\n</ul>\n<ol>\n<li>切换到 Artifacts选项卡，IDEA会为该项目自动创建一个名为“JavaEE_war exploded”的打包方式，表示 打包成war包，并且是文件展开性的，输出路径为当前项目下的 out 文件夹，保持默认即可。另外勾选下“Include in project build”，表示编译的时候就打包部署，勾选“Show content of elements”，表示显示详细的内容列表。<br><img src=\"http://upload-images.jianshu.io/upload_images/8743973-252025698c995aed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Artifacts\"></li>\n<li>配置Tomcat</li>\n</ol>\n<ul>\n<li>点击Edit Configuration<br><img src=\"http://upload-images.jianshu.io/upload_images/8743973-c745744bedd77ea4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Edit Configuration\"></li>\n<li>添加配置<br><img src=\"http://upload-images.jianshu.io/upload_images/8743973-f1d2a8c074861589.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Run/Debug Configuration\"></li>\n<li>按下图设置<br><img src=\"http://upload-images.jianshu.io/upload_images/8743973-6a54aa3e094cfe6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></li>\n<li>切换至Deployment<br><img src=\"http://upload-images.jianshu.io/upload_images/8743973-dcf12e312de8cd60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Deployment\"></li>\n</ul>\n<ol>\n<li>项目建立完成</li>\n</ol>\n<p>参考：<br><a href=\"http://blog.csdn.net/yhao2014/article/details/45740111\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/yhao2014/article/details/45740111</a><br><a href=\"http://www.jianshu.com/p/455c7c11dfb2\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/455c7c11dfb2</a></p>\n"},{"title":"KindleNote","date":"2018-04-15T00:25:10.000Z","_content":"\n### Update date: 2018/4/14\n\n1. 游戏玩家会为自己的购买行为寻找理由，使自己相信自己并不愚蠢。唯一的解决办法就是不断掏腰包，以继续游戏。\n   <上瘾：让用户养成使用习惯的四大产品逻辑>([美]尼尔·埃亚尔,[美]瑞安·胡佛) \n2. 游戏玩家会为自己的购买行为寻找理由，使自己相信自己并不愚蠢。唯一的解决办法就是不断掏腰包，以继续游戏。\n   <上瘾：让用户养成使用习惯的四大产品逻辑>([美]尼尔·埃亚尔,[美]瑞安·胡佛) \n3. 想想你第一次啜饮啤酒或品尝辛辣食物时的反应，觉得美味吗？应该不太可能。我们的身体对酒精、辣椒素以及使辛辣食物产生热辣感的化合物有一种本能排斥。可是，反复品尝之后，我们会慢慢喜欢上这类口味。看到其他人喜爱这种口味，我们就会多尝上几口，久而久之，我们会渐渐适应这种口味。为避免这种不喜他人之喜的认知失调，我们会慢慢改变自己对过去不喜欢的事物的看法。\n   <上瘾：让用户养成使用习惯的四大产品逻辑>([美]尼尔·埃亚尔,[美]瑞安·胡佛) \n4. 我们总会尽力和过去的行为保持一致\n   <上瘾：让用户养成使用习惯的四大产品逻辑>([美]尼尔·埃亚尔,[美]瑞安·胡佛) \n5. 我们总会尽力和过去的行为保持一\n   <上瘾：让用户养成使用习惯的四大产品逻辑>([美]尼尔·埃亚尔,[美]瑞安·胡佛) \n6. 我们总会高估自己的劳动成果\n   <上瘾：让用户养成使用习惯的四大产品逻辑>([美]尼尔·埃亚尔,[美]瑞安·胡佛) \n7. 图21 变化不定的内容驱使一些用户在信息流中不停地搜索新鲜内容，而对于内容提供者来说，他们的酬赏来\n   <上瘾：让用户养成使用习惯的四大产品逻辑>([美]尼尔·埃亚尔,[美]瑞安·胡佛) \n8. 驱使我们采取行动的，并不是酬赏本身，而是渴望酬赏时产生的那份迫切需要。\n   <上瘾：让用户养成使用习惯的四大产品逻辑>([美]尼尔·埃亚尔,[美]瑞安·胡佛) \n9. 我们通常会以为互联网的优势在于花样翻新，但其实人们只想在网络上继续做自己熟悉的事\n   <上瘾：让用户养成使用习惯的四大产品逻辑>([美]尼尔·埃亚尔,[美]瑞安·胡佛) \n10. 来自朋友或家人的推荐往往是科技传播的核心推动力\n    <上瘾：让用户养成使用习惯的四大产品逻辑>([美]尼尔·埃亚尔,[美]瑞安·胡佛) \n11. 新产品要想在市场上站稳脚跟，略胜一筹是远远不够的，必须要有绝对优势\n    <上瘾：让用户养成使用习惯的四大产品逻辑>([美]尼尔·埃亚尔,[美]瑞安·胡佛) \n12. 很多企业经营者都错误地认为，新产品只要比原有产品略胜一筹，就足以让用户一见倾心。但是，一旦涉及撼动用户的老习惯这个问题，天真的企业家们就会发现，好产品并不一定总能占据上风，尤其是当众多用户已经选择了其他具有竞争力的产品时\n    <上瘾：让用户养成使用习惯的四大产品逻辑>([美]尼尔·埃亚尔,[美]瑞安·胡佛) \n13. 提高增长速度最关键的因素就是‘病毒循环周期’”\n    <上瘾：让用户养成使用习惯的四大产品逻辑>([美]尼尔·埃亚尔,[美]瑞安·胡佛) \n14. 提高增长速度最关键的因素就是‘病毒循环周期\n    <上瘾：让用户养成使用习惯的四大产品逻辑>([美]尼尔·埃亚尔,[美]瑞安·胡佛) \n15. 提高增长速度最关键的因素就是‘病毒循环周期’”\n    <上瘾：让用户养成使用习惯的四大产品逻辑>([美]尼尔·埃亚尔,[美]瑞安·胡佛) \n16. 压力产生的不良情绪往往会触发这种无意识行为。\n    <上瘾：让用户养成使用习惯的四大产品逻辑>([美]尼尔·埃亚尔,[美]瑞安·胡佛) \n17. 上瘾模型包括四个阶段：触发，行动，多变的酬赏，投入。\n    <上瘾：让用户养成使用习惯的四大产品逻辑>([美]尼尔·埃亚尔,[美]瑞安·胡佛) \n18. 上瘾模型包括四个阶段：触发，行动，多变的酬赏，投\n    <上瘾：让用户养成使用习惯的四大产品逻辑>([美]尼尔·埃亚尔,[美]瑞安·胡佛) \n19. 瘾模型包括四个阶段：触发，行动，多变的酬赏，投入\n    <上瘾：让用户养成使用习惯的四大产品逻辑>([美]尼尔·埃亚尔,[美]瑞安·胡佛) \n20. 集网络连接、海量数据、超快网速三者于一身的技术正在使这个世界上瘾成性。\n    <上瘾：让用户养成使用习惯的四大产品逻辑>([美]尼尔·埃亚尔,[美]瑞安·胡佛) \n21. 苹果已经不再是一个创新者，而是已经成为了主流的象征\n    <苹果首席设计师:乔纳森传 >\n22. 设计不是看起来和感觉起来怎么样，而是用起来怎么样\n    <苹果首席设计师:乔纳森传 >\n23. 就算再索然无味的故事也要有一个结局\n    <那个不为人知的故事 >\n24. 人往往就是这个样子，在相处的过程中，每个人都会发现其他人与自己不同的地方，而当他们意识到这种不同带来的内在差异时，原本积极的感情，也会转化为无形的恶意。\n    <那个不为人知的故事 >\n25. 这很美妙。 当我睁开眼，你和朝阳一起存在。\n    <那个不为人知的故事 >\n26. 站在高处，你可以选择向下看。但是在低处，你别无选择。”\n    <那个不为人知的故事 >\n31. 如果一个人失去了基本尊严，那么他就可以像行尸走肉一样被控制。\n    <那些忧伤的年轻人(十周年纪念版)>(许知远) \n32. 暧昧的怀旧，这是现代人无法挥去的情结。\n    <那些忧伤的年轻人(十周年纪念版)>(许知远) \n33. 将爱情形式化，是一种社会的需要，是随着生活的愈益严酷而愈益迫切的需要。\n    <那些忧伤的年轻人(十周年纪念版)>(许知远) \n34. 我至少拥有青春中一个关键的情感——迷惘。\n    <那些忧伤的年轻人(十周年纪念版)>(许知远) \n35. 如今他们老了，我们也老了，像告别了蜜月期的情侣，我们相互指责对方的叛变，同时谁也无法忘记那些最美妙的时光。\n    <那些忧伤的年轻人(十周年纪念版)>(许知远) \n36. 真正感动人的，从来不是思想，而是年轻的勇气。李敖在这篇文章中，并没有表现出过人的思想，他只是以一个27岁的青年的身份在说话，他毫不掩饰他的感慨，他的愤怒，他的欲望，他的痛苦，和身处困境中却毫不动摇的勇敢……这一切正触动了所有年轻心灵的神经。\n    <那些忧伤的年轻人(十周年纪念版)>(许知远) \n37. 麦肯锡非常强调不是“为客户工作”(work for clients)而是“与客户合作”(work with clients)\n    <麦肯锡方法（经管图书的常青树，外企员工入职必读图书）>(艾森·拉塞尔(Ethan M.Rasiel)) \n38. 一次访谈要从一般性的问题问起，然后进行具体问题的提问。不要一头扎进敏感领域\n    <麦肯锡方法（经管图书的常青树，外企员工入职必读图书）>(艾森·拉塞尔(Ethan M.Rasiel)) \n39. 后退一步，搞清楚我们要解决的问题，然后看看手头的工作，问自己‘这些工作真的最重要吗？’\n    <麦肯锡方法（经管图书的常青树，外企员工入职必读图书）>(艾森·拉塞尔(Ethan M.Rasiel)) \n40. 一次只做一件事，做好本职工作——不要试图去做整个团队的工作\n    <麦肯锡方法（经管图书的常青树，外企员工入职必读图书）>(艾森·拉塞尔(Ethan M.Rasiel)) \n41. 30秒内向客户进行准确无误的解释\n    <麦肯锡方法（经管图书的常青树，外企员工入职必读图书）>(艾森·拉塞尔(Ethan M.Rasiel)) \n42. 假如事实证明你的初始假设是错误的，那就根据事实做出调整。\n    <麦肯锡方法（经管图书的常青树，外企员工入职必读图书）>(艾森·拉塞尔(Ethan M.Rasiel)) \n43. 相互独立、完全穷尽\n    <麦肯锡方法（经管图书的常青树，外企员工入职必读图书）>(艾森·拉塞尔(Ethan M.Rasiel)) \n44. 白家老大败家和老二兴业发家的故事最后凝炼为一个有进口无出口的木匣儿，被村村寨寨一代一代富的穷的庄稼人咀嚼着品味着删改着充实着传给自己的后代，成为本原无可企及的经典性的乡土教材……\n    <白鹿原（茅盾文学奖获奖作品；插图珍藏精装本）>(陈忠实著) \n45. 人能宏道，非道宏人\n    <神游七部合集>(徐公子胜治) \n46. 我见到她之前，从未想到要结婚；我娶了她几十年，从未后悔娶她，也未想过要娶别的女人\n    <且以优雅过一生：杨绛传（参透杨绛先生的百年人生智慧，做一个明媚从容、淡定优雅的女子。不妥协，不慌张，不迷茫，且以优雅过一生。）>(桑妮) \n47. 人，一生中会和很多人相遇，有些人只是为了擦身而过，有些人是等着一见如故\n    <且以优雅过一生：杨绛传（参透杨绛先生的百年人生智慧，做一个明媚从容、淡定优雅的女子。不妥协，不慌张，不迷茫，且以优雅过一生。）>(桑妮) \n48. 望之俨然8，接之也温\n    <且以优雅过一生：杨绛传（参透杨绛先生的百年人生智慧，做一个明媚从容、淡定优雅的女子。不妥协，不慌张，不迷茫，且以优雅过一生。）>(桑妮) \n49. 陪伴是最长情的告白\n    <且以优雅过一生：杨绛传（参透杨绛先生的百年人生智慧，做一个明媚从容、淡定优雅的女子。不妥协，不慌张，不迷茫，且以优雅过一生。）>(桑妮) \n50. 我们曾如此渴望命运的波澜，到最后才发现：人生最曼妙的风景，竟是内心的淡定与从容……我们曾如此期盼外界的认可，到最后才知道：世界是自己的，与他人毫无关系\n    <且以优雅过一生：杨绛传（参透杨绛先生的百年人生智慧，做一个明媚从容、淡定优雅的女子。不妥协，不慌张，不迷茫，且以优雅过一生。）>(桑妮) \n51. 一个人经过不同程度的锻炼，就获得不同程度的修养、不同程度的效益。好比香料，捣得愈碎，磨得愈细，香得愈浓烈。\n    <且以优雅过一生：杨绛传（参透杨绛先生的百年人生智慧，做一个明媚从容、淡定优雅的女子。不妥协，不慌张，不迷茫，且以优雅过一生。）>(桑妮) \n52. 不乱于心，不困于情。不畏将来，不念过往。如此，安好！\n    <且以优雅过一生：杨绛传（参透杨绛先生的百年人生智慧，做一个明媚从容、淡定优雅的女子。不妥协，不慌张，不迷茫，且以优雅过一生。）>(桑妮) \n53. “信任”就是世上绝大多数金钱的唯一后盾。\n    <人类简史：从动物到上帝（图文精编版） (开放历史系列)>(Yuval Noah Harari) \n54. 死虽然可怕，但这也就像是一次出门旅行。既然这个世上的芸芸众生早晚都要走上死的旅途，那么自己想要和最心爱的人，以最美的形式去旅行。\n    <失乐园 (渡边淳一经典作品集)>(渡边淳一) \n55. 葬礼是人生的缩影\n    <失乐园 (渡边淳一经典作品集)>(渡边淳一) \n56. 真正控制科学发展进度表的，也很少是科学家。\n    <人类简史：从动物到上帝（图文精编版） (开放历史系列)>(Yuval Noah Harari) \n57. 恐怕只有性的世界是无所谓进步与退步的。\n    <失乐园 (渡边淳一经典作品集)>(渡边淳一) \n58. 然而，演化本来就没有唯一的目的。器官的演化没有唯一的目的，而器官的使用方式也不断在变化。现在人体的所有器官早在几亿年前就已经出现了原型，而现在所有器官都不只做着原型所做的事。器官之所以演化是为了某种特定功能，但等到器官存在之后，要用作其他功能也并无不可。\n    <人类简史：从动物到上帝（图文精编版） (开放历史系列)>(Yuval Noah Harari) \n59. 事实上，许多人认知的“自然”和“不自然”并不是生物学的概念，而是基督教神学的概念。神学上所谓的“自然”，指的是“符合创造自然的神的旨意”。基督教神学家认为，上帝创造了人的身体，并且让每个肢体和器官都有特定的目的。如\n    <人类简史：从动物到上帝（图文精编版） (开放历史系列)>(Yuval Noah Harari) \n60. 他们认为，个人的价值是由社会阶级、由他人的看法所决定。\n    <人类简史：从动物到上帝（图文精编版） (开放历史系列)>(Yuval Noah Harari) \n61. 奢侈品史上常有这样的情况，就是原本的奢侈品往往最后会成为必需品，而且带来新的义务\n    <人类简史：从动物到上帝（图文精编版） (开放历史系列)>(Yuval Noah Harari) \n62. 病如西子胜三分\n    <红楼梦脂评汇校本 (BookDNA典藏书系)>(曹雪芹;脂砚斋) \n63. 心较比干多一窍\n    <红楼梦脂评汇校本 (BookDNA典藏书系)>(曹雪芹;脂砚斋) \n64. 一双似泣非泣含露目\n    <红楼梦脂评汇校本 (BookDNA典藏书系)>(曹雪芹;脂砚斋) \n65. 两弯似蹙非蹙罥烟眉\n    <红楼梦脂评汇校本 (BookDNA典藏书系)>(曹雪芹;脂砚斋) \n66. 粉面含春威不露，丹唇未启笑先闻\n    <红楼梦脂评汇校本 (BookDNA典藏书系)>(曹雪芹;脂砚斋) \n67. 蛋挞是不能一口全吃掉的。 先咬一口，滚烫得令嘴唇受惊，但舍不得吞。 含在嘴里，暖热而踏实，慢慢吃。此时酥皮会有残屑，顺势撒下，一身都是。又薄又脆，沾衣亦不管。再咬第二口…… 直至连略带焦黄但又香脆无比的底层亦一并干掉，马上开始另一个。 ——通常，第二个没第一个好吃。\n    <饺子>(李碧华) \n68. 气韵是作家的后脑勺。作家自己是看不到的。\n    <罗生门（经典悬疑电影原著，对人性最深刻的拷问） (经典译林)>(芥川龙之介) \n69. 我们究竟为什么喜欢幼小的孩子呢？这个理由的一半，至少是由于用不着担心被小孩子欺骗。\n    <罗生门（经典悬疑电影原著，对人性最深刻的拷问） (经典译林)>(芥川龙之介) \n70. 天才和我们只有一步的间隔。为了理解这一步，我们必须懂得百里路的一半是九十九里的超数学。\n    <罗生门（经典悬疑电影原著，对人性最深刻的拷问） (经典译林)>(芥川龙之介) \n71. 发现民众的愚蠢，并不值得夸耀。但是，发现我们自己也是民众，倒的确值得夸耀。\n    <罗生门（经典悬疑电影原著，对人性最深刻的拷问） (经典译林)>(芥川龙之介) \n72. 舆论常常是一种私刑。私刑又常常是一种娱乐。好比使用新闻记事来取代手枪。\n    <罗生门（经典悬疑电影原著，对人性最深刻的拷问） (经典译林)>(芥川龙之介) \n73. 人生好像缺页很多的书。很难把它说成是一部书，然而它又确实是一部书。\n    <罗生门（经典悬疑电影原著，对人性最深刻的拷问） (经典译林)>(芥川龙之介) \n74. 她们未必懂得丈夫们所为之舍生取义的理念和目标，但她们肯摒弃浮华肯用生命去诠释什么叫做爱情\n    <他们最幸福>(大冰 著) \n75. “要把地面上的人看清楚，就要和地面保持距离”。——卡尔维诺\n    <他们最幸福>(大冰 著) \n76. 我们所观察到的并不是自然本身，而是自然在我们的提问下向我们显现出的面貌\n    <有限与无限的游戏>([美] 詹姆斯·卡斯) \n77. 爱国主义──指的是意欲通过增强一个社会的权力来保护社会中的权力\n    <有限与无限的游戏>([美] 詹姆斯·卡斯) \n78. 这些博物馆的创立初衷并不是保护艺术品免于遭受人民破坏，而是使人民免于接触艺术。\n    <有限与无限的游戏>([美] 詹姆斯·卡斯) \n79. 公共意志及其权力所不及之处，不足以言节。\n    <认得几个字>(张大春) \n80. “不应该”居然是“应该”的产物\n    <认得几个字>(张大春) \n81. 关于梦，神秘的也许不是那些无梦的真人或至人，是每一个人在睡眠中伟大的创作，醒来不记，怕是创作者真正的潇洒。\n    <认得几个字>(张大春) \n82. 这技巧的本质，就是规则\n    <亵渎>(烟雨江南) \n83. 宇宙中有多少生物，就有多少中心。\n    <泛若不系之舟>(傅真) \n84. 如果“无神论”是建立在无知而自大的基础上，那么根本不是一件值得自豪的事情。\n    <泛若不系之舟>(傅真) \n85. 宗教的偏执性其实是来自于人而并非它的本身\n    <泛若不系之舟>(傅真) \n86. 那片土地上传统深植而禁忌丛生，却也一直有人勇敢地打破命运释放灵魂。\n    <泛若不系之舟>(傅真) \n87. 我什么也没忘，但有些事只适合收藏。\n    <去你家玩好吗>(韩寒 监制) \n88. 谁会讲故事，谁就拥有世界\n    <白说>(白岩松) \n89. 比起那些用大嗓门企图压制世界的人，让全世界都安静下来听你小声说话的人更可畏。\n    <告白与告别>(韩寒) \n90. 她的声音被保存下来，这是几百万沉默者中的一声呐喊，虽然这呐喊声是那么的微弱……但它比杀人者的嚎叫声更持久，比这个时代中所有的声音更响亮。\n    <世界文学文库:安妮日记 >(安妮•弗兰克 (Frank.A.)) \n91. 在内心深处，年轻人比老年人更寂寞。\n    <世界文学文库:安妮日记 >(安妮•弗兰克 (Frank.A.)) \n92. 没什么好怒的，大家都想赶时间，但我不想赶着死；大家都想抄捷径，但我不想抄末路。\n    <从你的全世界路过（完美升级版）>(张嘉佳) \n93. 你可以不接受，这是一种自由。但不屑和抨击，翻到另外一个世界观，只能说明你的无知和武断。\n    <从你的全世界路过（完美升级版）>(张嘉佳) \n94. 看到小清新不要说矫情。看到二逼段子不要说脑残。看到文艺范不要说装×。看到诗歌不要说无病呻吟。看到意识流不要说傻×。 每个人有自己的表达方式，如果你不喜欢，只能说明不是为你准备的。\n    <从你的全世界路过（完美升级版）>(张嘉佳) \n95. 我们常说，轻易得来的，不会懂得珍惜。 其实不然，轻易得来的，你会害怕失去。\n    <从你的全世界路过（完美升级版）>(张嘉佳) \n96. 艺术家永远支持鸡蛋，所以鸡蛋和墙碰撞的时候，不去问墙是对的，还是鸡蛋是对的，不管谁是对的，首先支持鸡蛋，\n    <鱼羊野史·第1卷>(高晓松) \n97. 1915年，美国一位名叫特鲁多的医生去世了，他的墓碑上刻着三行字：“偶尔去治愈，常常去帮助，总是在抚慰。”\n    <白说>(白岩松) \n98. 如果总在为未来忧虑，而不能享受此时此刻的时光，你可以把整个余生都搭进去，但你真的打算这么过一辈子吗？要知道，你所担心的事情，只有不超过10%会变成现实，其余的都是自己吓自己。而且生命中有一个很奇妙的逻辑，如果你真的过好今天，明天也还不错。\n    <白说>(白岩松) \n99. 漂亮的失败是另一种成功\n    <白说>(白岩松) \n100. 生命不只是使用，还需要奖励。\n     <白说>(白岩松) ","source":"_posts/Kindle Note.md","raw":"---\ntitle: KindleNote\ndate: 2018-04-14 17:25:10\ntags: Reading\n---\n\n### Update date: 2018/4/14\n\n1. 游戏玩家会为自己的购买行为寻找理由，使自己相信自己并不愚蠢。唯一的解决办法就是不断掏腰包，以继续游戏。\n   <上瘾：让用户养成使用习惯的四大产品逻辑>([美]尼尔·埃亚尔,[美]瑞安·胡佛) \n2. 游戏玩家会为自己的购买行为寻找理由，使自己相信自己并不愚蠢。唯一的解决办法就是不断掏腰包，以继续游戏。\n   <上瘾：让用户养成使用习惯的四大产品逻辑>([美]尼尔·埃亚尔,[美]瑞安·胡佛) \n3. 想想你第一次啜饮啤酒或品尝辛辣食物时的反应，觉得美味吗？应该不太可能。我们的身体对酒精、辣椒素以及使辛辣食物产生热辣感的化合物有一种本能排斥。可是，反复品尝之后，我们会慢慢喜欢上这类口味。看到其他人喜爱这种口味，我们就会多尝上几口，久而久之，我们会渐渐适应这种口味。为避免这种不喜他人之喜的认知失调，我们会慢慢改变自己对过去不喜欢的事物的看法。\n   <上瘾：让用户养成使用习惯的四大产品逻辑>([美]尼尔·埃亚尔,[美]瑞安·胡佛) \n4. 我们总会尽力和过去的行为保持一致\n   <上瘾：让用户养成使用习惯的四大产品逻辑>([美]尼尔·埃亚尔,[美]瑞安·胡佛) \n5. 我们总会尽力和过去的行为保持一\n   <上瘾：让用户养成使用习惯的四大产品逻辑>([美]尼尔·埃亚尔,[美]瑞安·胡佛) \n6. 我们总会高估自己的劳动成果\n   <上瘾：让用户养成使用习惯的四大产品逻辑>([美]尼尔·埃亚尔,[美]瑞安·胡佛) \n7. 图21 变化不定的内容驱使一些用户在信息流中不停地搜索新鲜内容，而对于内容提供者来说，他们的酬赏来\n   <上瘾：让用户养成使用习惯的四大产品逻辑>([美]尼尔·埃亚尔,[美]瑞安·胡佛) \n8. 驱使我们采取行动的，并不是酬赏本身，而是渴望酬赏时产生的那份迫切需要。\n   <上瘾：让用户养成使用习惯的四大产品逻辑>([美]尼尔·埃亚尔,[美]瑞安·胡佛) \n9. 我们通常会以为互联网的优势在于花样翻新，但其实人们只想在网络上继续做自己熟悉的事\n   <上瘾：让用户养成使用习惯的四大产品逻辑>([美]尼尔·埃亚尔,[美]瑞安·胡佛) \n10. 来自朋友或家人的推荐往往是科技传播的核心推动力\n    <上瘾：让用户养成使用习惯的四大产品逻辑>([美]尼尔·埃亚尔,[美]瑞安·胡佛) \n11. 新产品要想在市场上站稳脚跟，略胜一筹是远远不够的，必须要有绝对优势\n    <上瘾：让用户养成使用习惯的四大产品逻辑>([美]尼尔·埃亚尔,[美]瑞安·胡佛) \n12. 很多企业经营者都错误地认为，新产品只要比原有产品略胜一筹，就足以让用户一见倾心。但是，一旦涉及撼动用户的老习惯这个问题，天真的企业家们就会发现，好产品并不一定总能占据上风，尤其是当众多用户已经选择了其他具有竞争力的产品时\n    <上瘾：让用户养成使用习惯的四大产品逻辑>([美]尼尔·埃亚尔,[美]瑞安·胡佛) \n13. 提高增长速度最关键的因素就是‘病毒循环周期’”\n    <上瘾：让用户养成使用习惯的四大产品逻辑>([美]尼尔·埃亚尔,[美]瑞安·胡佛) \n14. 提高增长速度最关键的因素就是‘病毒循环周期\n    <上瘾：让用户养成使用习惯的四大产品逻辑>([美]尼尔·埃亚尔,[美]瑞安·胡佛) \n15. 提高增长速度最关键的因素就是‘病毒循环周期’”\n    <上瘾：让用户养成使用习惯的四大产品逻辑>([美]尼尔·埃亚尔,[美]瑞安·胡佛) \n16. 压力产生的不良情绪往往会触发这种无意识行为。\n    <上瘾：让用户养成使用习惯的四大产品逻辑>([美]尼尔·埃亚尔,[美]瑞安·胡佛) \n17. 上瘾模型包括四个阶段：触发，行动，多变的酬赏，投入。\n    <上瘾：让用户养成使用习惯的四大产品逻辑>([美]尼尔·埃亚尔,[美]瑞安·胡佛) \n18. 上瘾模型包括四个阶段：触发，行动，多变的酬赏，投\n    <上瘾：让用户养成使用习惯的四大产品逻辑>([美]尼尔·埃亚尔,[美]瑞安·胡佛) \n19. 瘾模型包括四个阶段：触发，行动，多变的酬赏，投入\n    <上瘾：让用户养成使用习惯的四大产品逻辑>([美]尼尔·埃亚尔,[美]瑞安·胡佛) \n20. 集网络连接、海量数据、超快网速三者于一身的技术正在使这个世界上瘾成性。\n    <上瘾：让用户养成使用习惯的四大产品逻辑>([美]尼尔·埃亚尔,[美]瑞安·胡佛) \n21. 苹果已经不再是一个创新者，而是已经成为了主流的象征\n    <苹果首席设计师:乔纳森传 >\n22. 设计不是看起来和感觉起来怎么样，而是用起来怎么样\n    <苹果首席设计师:乔纳森传 >\n23. 就算再索然无味的故事也要有一个结局\n    <那个不为人知的故事 >\n24. 人往往就是这个样子，在相处的过程中，每个人都会发现其他人与自己不同的地方，而当他们意识到这种不同带来的内在差异时，原本积极的感情，也会转化为无形的恶意。\n    <那个不为人知的故事 >\n25. 这很美妙。 当我睁开眼，你和朝阳一起存在。\n    <那个不为人知的故事 >\n26. 站在高处，你可以选择向下看。但是在低处，你别无选择。”\n    <那个不为人知的故事 >\n31. 如果一个人失去了基本尊严，那么他就可以像行尸走肉一样被控制。\n    <那些忧伤的年轻人(十周年纪念版)>(许知远) \n32. 暧昧的怀旧，这是现代人无法挥去的情结。\n    <那些忧伤的年轻人(十周年纪念版)>(许知远) \n33. 将爱情形式化，是一种社会的需要，是随着生活的愈益严酷而愈益迫切的需要。\n    <那些忧伤的年轻人(十周年纪念版)>(许知远) \n34. 我至少拥有青春中一个关键的情感——迷惘。\n    <那些忧伤的年轻人(十周年纪念版)>(许知远) \n35. 如今他们老了，我们也老了，像告别了蜜月期的情侣，我们相互指责对方的叛变，同时谁也无法忘记那些最美妙的时光。\n    <那些忧伤的年轻人(十周年纪念版)>(许知远) \n36. 真正感动人的，从来不是思想，而是年轻的勇气。李敖在这篇文章中，并没有表现出过人的思想，他只是以一个27岁的青年的身份在说话，他毫不掩饰他的感慨，他的愤怒，他的欲望，他的痛苦，和身处困境中却毫不动摇的勇敢……这一切正触动了所有年轻心灵的神经。\n    <那些忧伤的年轻人(十周年纪念版)>(许知远) \n37. 麦肯锡非常强调不是“为客户工作”(work for clients)而是“与客户合作”(work with clients)\n    <麦肯锡方法（经管图书的常青树，外企员工入职必读图书）>(艾森·拉塞尔(Ethan M.Rasiel)) \n38. 一次访谈要从一般性的问题问起，然后进行具体问题的提问。不要一头扎进敏感领域\n    <麦肯锡方法（经管图书的常青树，外企员工入职必读图书）>(艾森·拉塞尔(Ethan M.Rasiel)) \n39. 后退一步，搞清楚我们要解决的问题，然后看看手头的工作，问自己‘这些工作真的最重要吗？’\n    <麦肯锡方法（经管图书的常青树，外企员工入职必读图书）>(艾森·拉塞尔(Ethan M.Rasiel)) \n40. 一次只做一件事，做好本职工作——不要试图去做整个团队的工作\n    <麦肯锡方法（经管图书的常青树，外企员工入职必读图书）>(艾森·拉塞尔(Ethan M.Rasiel)) \n41. 30秒内向客户进行准确无误的解释\n    <麦肯锡方法（经管图书的常青树，外企员工入职必读图书）>(艾森·拉塞尔(Ethan M.Rasiel)) \n42. 假如事实证明你的初始假设是错误的，那就根据事实做出调整。\n    <麦肯锡方法（经管图书的常青树，外企员工入职必读图书）>(艾森·拉塞尔(Ethan M.Rasiel)) \n43. 相互独立、完全穷尽\n    <麦肯锡方法（经管图书的常青树，外企员工入职必读图书）>(艾森·拉塞尔(Ethan M.Rasiel)) \n44. 白家老大败家和老二兴业发家的故事最后凝炼为一个有进口无出口的木匣儿，被村村寨寨一代一代富的穷的庄稼人咀嚼着品味着删改着充实着传给自己的后代，成为本原无可企及的经典性的乡土教材……\n    <白鹿原（茅盾文学奖获奖作品；插图珍藏精装本）>(陈忠实著) \n45. 人能宏道，非道宏人\n    <神游七部合集>(徐公子胜治) \n46. 我见到她之前，从未想到要结婚；我娶了她几十年，从未后悔娶她，也未想过要娶别的女人\n    <且以优雅过一生：杨绛传（参透杨绛先生的百年人生智慧，做一个明媚从容、淡定优雅的女子。不妥协，不慌张，不迷茫，且以优雅过一生。）>(桑妮) \n47. 人，一生中会和很多人相遇，有些人只是为了擦身而过，有些人是等着一见如故\n    <且以优雅过一生：杨绛传（参透杨绛先生的百年人生智慧，做一个明媚从容、淡定优雅的女子。不妥协，不慌张，不迷茫，且以优雅过一生。）>(桑妮) \n48. 望之俨然8，接之也温\n    <且以优雅过一生：杨绛传（参透杨绛先生的百年人生智慧，做一个明媚从容、淡定优雅的女子。不妥协，不慌张，不迷茫，且以优雅过一生。）>(桑妮) \n49. 陪伴是最长情的告白\n    <且以优雅过一生：杨绛传（参透杨绛先生的百年人生智慧，做一个明媚从容、淡定优雅的女子。不妥协，不慌张，不迷茫，且以优雅过一生。）>(桑妮) \n50. 我们曾如此渴望命运的波澜，到最后才发现：人生最曼妙的风景，竟是内心的淡定与从容……我们曾如此期盼外界的认可，到最后才知道：世界是自己的，与他人毫无关系\n    <且以优雅过一生：杨绛传（参透杨绛先生的百年人生智慧，做一个明媚从容、淡定优雅的女子。不妥协，不慌张，不迷茫，且以优雅过一生。）>(桑妮) \n51. 一个人经过不同程度的锻炼，就获得不同程度的修养、不同程度的效益。好比香料，捣得愈碎，磨得愈细，香得愈浓烈。\n    <且以优雅过一生：杨绛传（参透杨绛先生的百年人生智慧，做一个明媚从容、淡定优雅的女子。不妥协，不慌张，不迷茫，且以优雅过一生。）>(桑妮) \n52. 不乱于心，不困于情。不畏将来，不念过往。如此，安好！\n    <且以优雅过一生：杨绛传（参透杨绛先生的百年人生智慧，做一个明媚从容、淡定优雅的女子。不妥协，不慌张，不迷茫，且以优雅过一生。）>(桑妮) \n53. “信任”就是世上绝大多数金钱的唯一后盾。\n    <人类简史：从动物到上帝（图文精编版） (开放历史系列)>(Yuval Noah Harari) \n54. 死虽然可怕，但这也就像是一次出门旅行。既然这个世上的芸芸众生早晚都要走上死的旅途，那么自己想要和最心爱的人，以最美的形式去旅行。\n    <失乐园 (渡边淳一经典作品集)>(渡边淳一) \n55. 葬礼是人生的缩影\n    <失乐园 (渡边淳一经典作品集)>(渡边淳一) \n56. 真正控制科学发展进度表的，也很少是科学家。\n    <人类简史：从动物到上帝（图文精编版） (开放历史系列)>(Yuval Noah Harari) \n57. 恐怕只有性的世界是无所谓进步与退步的。\n    <失乐园 (渡边淳一经典作品集)>(渡边淳一) \n58. 然而，演化本来就没有唯一的目的。器官的演化没有唯一的目的，而器官的使用方式也不断在变化。现在人体的所有器官早在几亿年前就已经出现了原型，而现在所有器官都不只做着原型所做的事。器官之所以演化是为了某种特定功能，但等到器官存在之后，要用作其他功能也并无不可。\n    <人类简史：从动物到上帝（图文精编版） (开放历史系列)>(Yuval Noah Harari) \n59. 事实上，许多人认知的“自然”和“不自然”并不是生物学的概念，而是基督教神学的概念。神学上所谓的“自然”，指的是“符合创造自然的神的旨意”。基督教神学家认为，上帝创造了人的身体，并且让每个肢体和器官都有特定的目的。如\n    <人类简史：从动物到上帝（图文精编版） (开放历史系列)>(Yuval Noah Harari) \n60. 他们认为，个人的价值是由社会阶级、由他人的看法所决定。\n    <人类简史：从动物到上帝（图文精编版） (开放历史系列)>(Yuval Noah Harari) \n61. 奢侈品史上常有这样的情况，就是原本的奢侈品往往最后会成为必需品，而且带来新的义务\n    <人类简史：从动物到上帝（图文精编版） (开放历史系列)>(Yuval Noah Harari) \n62. 病如西子胜三分\n    <红楼梦脂评汇校本 (BookDNA典藏书系)>(曹雪芹;脂砚斋) \n63. 心较比干多一窍\n    <红楼梦脂评汇校本 (BookDNA典藏书系)>(曹雪芹;脂砚斋) \n64. 一双似泣非泣含露目\n    <红楼梦脂评汇校本 (BookDNA典藏书系)>(曹雪芹;脂砚斋) \n65. 两弯似蹙非蹙罥烟眉\n    <红楼梦脂评汇校本 (BookDNA典藏书系)>(曹雪芹;脂砚斋) \n66. 粉面含春威不露，丹唇未启笑先闻\n    <红楼梦脂评汇校本 (BookDNA典藏书系)>(曹雪芹;脂砚斋) \n67. 蛋挞是不能一口全吃掉的。 先咬一口，滚烫得令嘴唇受惊，但舍不得吞。 含在嘴里，暖热而踏实，慢慢吃。此时酥皮会有残屑，顺势撒下，一身都是。又薄又脆，沾衣亦不管。再咬第二口…… 直至连略带焦黄但又香脆无比的底层亦一并干掉，马上开始另一个。 ——通常，第二个没第一个好吃。\n    <饺子>(李碧华) \n68. 气韵是作家的后脑勺。作家自己是看不到的。\n    <罗生门（经典悬疑电影原著，对人性最深刻的拷问） (经典译林)>(芥川龙之介) \n69. 我们究竟为什么喜欢幼小的孩子呢？这个理由的一半，至少是由于用不着担心被小孩子欺骗。\n    <罗生门（经典悬疑电影原著，对人性最深刻的拷问） (经典译林)>(芥川龙之介) \n70. 天才和我们只有一步的间隔。为了理解这一步，我们必须懂得百里路的一半是九十九里的超数学。\n    <罗生门（经典悬疑电影原著，对人性最深刻的拷问） (经典译林)>(芥川龙之介) \n71. 发现民众的愚蠢，并不值得夸耀。但是，发现我们自己也是民众，倒的确值得夸耀。\n    <罗生门（经典悬疑电影原著，对人性最深刻的拷问） (经典译林)>(芥川龙之介) \n72. 舆论常常是一种私刑。私刑又常常是一种娱乐。好比使用新闻记事来取代手枪。\n    <罗生门（经典悬疑电影原著，对人性最深刻的拷问） (经典译林)>(芥川龙之介) \n73. 人生好像缺页很多的书。很难把它说成是一部书，然而它又确实是一部书。\n    <罗生门（经典悬疑电影原著，对人性最深刻的拷问） (经典译林)>(芥川龙之介) \n74. 她们未必懂得丈夫们所为之舍生取义的理念和目标，但她们肯摒弃浮华肯用生命去诠释什么叫做爱情\n    <他们最幸福>(大冰 著) \n75. “要把地面上的人看清楚，就要和地面保持距离”。——卡尔维诺\n    <他们最幸福>(大冰 著) \n76. 我们所观察到的并不是自然本身，而是自然在我们的提问下向我们显现出的面貌\n    <有限与无限的游戏>([美] 詹姆斯·卡斯) \n77. 爱国主义──指的是意欲通过增强一个社会的权力来保护社会中的权力\n    <有限与无限的游戏>([美] 詹姆斯·卡斯) \n78. 这些博物馆的创立初衷并不是保护艺术品免于遭受人民破坏，而是使人民免于接触艺术。\n    <有限与无限的游戏>([美] 詹姆斯·卡斯) \n79. 公共意志及其权力所不及之处，不足以言节。\n    <认得几个字>(张大春) \n80. “不应该”居然是“应该”的产物\n    <认得几个字>(张大春) \n81. 关于梦，神秘的也许不是那些无梦的真人或至人，是每一个人在睡眠中伟大的创作，醒来不记，怕是创作者真正的潇洒。\n    <认得几个字>(张大春) \n82. 这技巧的本质，就是规则\n    <亵渎>(烟雨江南) \n83. 宇宙中有多少生物，就有多少中心。\n    <泛若不系之舟>(傅真) \n84. 如果“无神论”是建立在无知而自大的基础上，那么根本不是一件值得自豪的事情。\n    <泛若不系之舟>(傅真) \n85. 宗教的偏执性其实是来自于人而并非它的本身\n    <泛若不系之舟>(傅真) \n86. 那片土地上传统深植而禁忌丛生，却也一直有人勇敢地打破命运释放灵魂。\n    <泛若不系之舟>(傅真) \n87. 我什么也没忘，但有些事只适合收藏。\n    <去你家玩好吗>(韩寒 监制) \n88. 谁会讲故事，谁就拥有世界\n    <白说>(白岩松) \n89. 比起那些用大嗓门企图压制世界的人，让全世界都安静下来听你小声说话的人更可畏。\n    <告白与告别>(韩寒) \n90. 她的声音被保存下来，这是几百万沉默者中的一声呐喊，虽然这呐喊声是那么的微弱……但它比杀人者的嚎叫声更持久，比这个时代中所有的声音更响亮。\n    <世界文学文库:安妮日记 >(安妮•弗兰克 (Frank.A.)) \n91. 在内心深处，年轻人比老年人更寂寞。\n    <世界文学文库:安妮日记 >(安妮•弗兰克 (Frank.A.)) \n92. 没什么好怒的，大家都想赶时间，但我不想赶着死；大家都想抄捷径，但我不想抄末路。\n    <从你的全世界路过（完美升级版）>(张嘉佳) \n93. 你可以不接受，这是一种自由。但不屑和抨击，翻到另外一个世界观，只能说明你的无知和武断。\n    <从你的全世界路过（完美升级版）>(张嘉佳) \n94. 看到小清新不要说矫情。看到二逼段子不要说脑残。看到文艺范不要说装×。看到诗歌不要说无病呻吟。看到意识流不要说傻×。 每个人有自己的表达方式，如果你不喜欢，只能说明不是为你准备的。\n    <从你的全世界路过（完美升级版）>(张嘉佳) \n95. 我们常说，轻易得来的，不会懂得珍惜。 其实不然，轻易得来的，你会害怕失去。\n    <从你的全世界路过（完美升级版）>(张嘉佳) \n96. 艺术家永远支持鸡蛋，所以鸡蛋和墙碰撞的时候，不去问墙是对的，还是鸡蛋是对的，不管谁是对的，首先支持鸡蛋，\n    <鱼羊野史·第1卷>(高晓松) \n97. 1915年，美国一位名叫特鲁多的医生去世了，他的墓碑上刻着三行字：“偶尔去治愈，常常去帮助，总是在抚慰。”\n    <白说>(白岩松) \n98. 如果总在为未来忧虑，而不能享受此时此刻的时光，你可以把整个余生都搭进去，但你真的打算这么过一辈子吗？要知道，你所担心的事情，只有不超过10%会变成现实，其余的都是自己吓自己。而且生命中有一个很奇妙的逻辑，如果你真的过好今天，明天也还不错。\n    <白说>(白岩松) \n99. 漂亮的失败是另一种成功\n    <白说>(白岩松) \n100. 生命不只是使用，还需要奖励。\n     <白说>(白岩松) ","slug":"Kindle Note","published":1,"updated":"2018-04-14T10:42:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcqk30wx0004pu9k2jaew5pa","content":"<h3 id=\"Update-date-2018-4-14\"><a href=\"#Update-date-2018-4-14\" class=\"headerlink\" title=\"Update date: 2018/4/14\"></a>Update date: 2018/4/14</h3><ol>\n<li>游戏玩家会为自己的购买行为寻找理由，使自己相信自己并不愚蠢。唯一的解决办法就是不断掏腰包，以继续游戏。<br>&lt;上瘾：让用户养成使用习惯的四大产品逻辑&gt;([美]尼尔·埃亚尔,[美]瑞安·胡佛) </li>\n<li>游戏玩家会为自己的购买行为寻找理由，使自己相信自己并不愚蠢。唯一的解决办法就是不断掏腰包，以继续游戏。<br>&lt;上瘾：让用户养成使用习惯的四大产品逻辑&gt;([美]尼尔·埃亚尔,[美]瑞安·胡佛) </li>\n<li>想想你第一次啜饮啤酒或品尝辛辣食物时的反应，觉得美味吗？应该不太可能。我们的身体对酒精、辣椒素以及使辛辣食物产生热辣感的化合物有一种本能排斥。可是，反复品尝之后，我们会慢慢喜欢上这类口味。看到其他人喜爱这种口味，我们就会多尝上几口，久而久之，我们会渐渐适应这种口味。为避免这种不喜他人之喜的认知失调，我们会慢慢改变自己对过去不喜欢的事物的看法。<br>&lt;上瘾：让用户养成使用习惯的四大产品逻辑&gt;([美]尼尔·埃亚尔,[美]瑞安·胡佛) </li>\n<li>我们总会尽力和过去的行为保持一致<br>&lt;上瘾：让用户养成使用习惯的四大产品逻辑&gt;([美]尼尔·埃亚尔,[美]瑞安·胡佛) </li>\n<li>我们总会尽力和过去的行为保持一<br>&lt;上瘾：让用户养成使用习惯的四大产品逻辑&gt;([美]尼尔·埃亚尔,[美]瑞安·胡佛) </li>\n<li>我们总会高估自己的劳动成果<br>&lt;上瘾：让用户养成使用习惯的四大产品逻辑&gt;([美]尼尔·埃亚尔,[美]瑞安·胡佛) </li>\n<li>图21 变化不定的内容驱使一些用户在信息流中不停地搜索新鲜内容，而对于内容提供者来说，他们的酬赏来<br>&lt;上瘾：让用户养成使用习惯的四大产品逻辑&gt;([美]尼尔·埃亚尔,[美]瑞安·胡佛) </li>\n<li>驱使我们采取行动的，并不是酬赏本身，而是渴望酬赏时产生的那份迫切需要。<br>&lt;上瘾：让用户养成使用习惯的四大产品逻辑&gt;([美]尼尔·埃亚尔,[美]瑞安·胡佛) </li>\n<li>我们通常会以为互联网的优势在于花样翻新，但其实人们只想在网络上继续做自己熟悉的事<br>&lt;上瘾：让用户养成使用习惯的四大产品逻辑&gt;([美]尼尔·埃亚尔,[美]瑞安·胡佛) </li>\n<li>来自朋友或家人的推荐往往是科技传播的核心推动力<br>&lt;上瘾：让用户养成使用习惯的四大产品逻辑&gt;([美]尼尔·埃亚尔,[美]瑞安·胡佛) </li>\n<li>新产品要想在市场上站稳脚跟，略胜一筹是远远不够的，必须要有绝对优势<br>&lt;上瘾：让用户养成使用习惯的四大产品逻辑&gt;([美]尼尔·埃亚尔,[美]瑞安·胡佛) </li>\n<li>很多企业经营者都错误地认为，新产品只要比原有产品略胜一筹，就足以让用户一见倾心。但是，一旦涉及撼动用户的老习惯这个问题，天真的企业家们就会发现，好产品并不一定总能占据上风，尤其是当众多用户已经选择了其他具有竞争力的产品时<br>&lt;上瘾：让用户养成使用习惯的四大产品逻辑&gt;([美]尼尔·埃亚尔,[美]瑞安·胡佛) </li>\n<li>提高增长速度最关键的因素就是‘病毒循环周期’”<br>&lt;上瘾：让用户养成使用习惯的四大产品逻辑&gt;([美]尼尔·埃亚尔,[美]瑞安·胡佛) </li>\n<li>提高增长速度最关键的因素就是‘病毒循环周期<br>&lt;上瘾：让用户养成使用习惯的四大产品逻辑&gt;([美]尼尔·埃亚尔,[美]瑞安·胡佛) </li>\n<li>提高增长速度最关键的因素就是‘病毒循环周期’”<br>&lt;上瘾：让用户养成使用习惯的四大产品逻辑&gt;([美]尼尔·埃亚尔,[美]瑞安·胡佛) </li>\n<li>压力产生的不良情绪往往会触发这种无意识行为。<br>&lt;上瘾：让用户养成使用习惯的四大产品逻辑&gt;([美]尼尔·埃亚尔,[美]瑞安·胡佛) </li>\n<li>上瘾模型包括四个阶段：触发，行动，多变的酬赏，投入。<br>&lt;上瘾：让用户养成使用习惯的四大产品逻辑&gt;([美]尼尔·埃亚尔,[美]瑞安·胡佛) </li>\n<li>上瘾模型包括四个阶段：触发，行动，多变的酬赏，投<br>&lt;上瘾：让用户养成使用习惯的四大产品逻辑&gt;([美]尼尔·埃亚尔,[美]瑞安·胡佛) </li>\n<li>瘾模型包括四个阶段：触发，行动，多变的酬赏，投入<br>&lt;上瘾：让用户养成使用习惯的四大产品逻辑&gt;([美]尼尔·埃亚尔,[美]瑞安·胡佛) </li>\n<li>集网络连接、海量数据、超快网速三者于一身的技术正在使这个世界上瘾成性。<br>&lt;上瘾：让用户养成使用习惯的四大产品逻辑&gt;([美]尼尔·埃亚尔,[美]瑞安·胡佛) </li>\n<li>苹果已经不再是一个创新者，而是已经成为了主流的象征<br>&lt;苹果首席设计师:乔纳森传 &gt;</li>\n<li>设计不是看起来和感觉起来怎么样，而是用起来怎么样<br>&lt;苹果首席设计师:乔纳森传 &gt;</li>\n<li>就算再索然无味的故事也要有一个结局<br>&lt;那个不为人知的故事 &gt;</li>\n<li>人往往就是这个样子，在相处的过程中，每个人都会发现其他人与自己不同的地方，而当他们意识到这种不同带来的内在差异时，原本积极的感情，也会转化为无形的恶意。<br>&lt;那个不为人知的故事 &gt;</li>\n<li>这很美妙。 当我睁开眼，你和朝阳一起存在。<br>&lt;那个不为人知的故事 &gt;</li>\n<li>站在高处，你可以选择向下看。但是在低处，你别无选择。”<br>&lt;那个不为人知的故事 &gt;</li>\n<li>如果一个人失去了基本尊严，那么他就可以像行尸走肉一样被控制。<br>&lt;那些忧伤的年轻人(十周年纪念版)&gt;(许知远) </li>\n<li>暧昧的怀旧，这是现代人无法挥去的情结。<br>&lt;那些忧伤的年轻人(十周年纪念版)&gt;(许知远) </li>\n<li>将爱情形式化，是一种社会的需要，是随着生活的愈益严酷而愈益迫切的需要。<br>&lt;那些忧伤的年轻人(十周年纪念版)&gt;(许知远) </li>\n<li>我至少拥有青春中一个关键的情感——迷惘。<br>&lt;那些忧伤的年轻人(十周年纪念版)&gt;(许知远) </li>\n<li>如今他们老了，我们也老了，像告别了蜜月期的情侣，我们相互指责对方的叛变，同时谁也无法忘记那些最美妙的时光。<br>&lt;那些忧伤的年轻人(十周年纪念版)&gt;(许知远) </li>\n<li>真正感动人的，从来不是思想，而是年轻的勇气。李敖在这篇文章中，并没有表现出过人的思想，他只是以一个27岁的青年的身份在说话，他毫不掩饰他的感慨，他的愤怒，他的欲望，他的痛苦，和身处困境中却毫不动摇的勇敢……这一切正触动了所有年轻心灵的神经。<br>&lt;那些忧伤的年轻人(十周年纪念版)&gt;(许知远) </li>\n<li>麦肯锡非常强调不是“为客户工作”(work for clients)而是“与客户合作”(work with clients)<br>&lt;麦肯锡方法（经管图书的常青树，外企员工入职必读图书）&gt;(艾森·拉塞尔(Ethan M.Rasiel)) </li>\n<li>一次访谈要从一般性的问题问起，然后进行具体问题的提问。不要一头扎进敏感领域<br>&lt;麦肯锡方法（经管图书的常青树，外企员工入职必读图书）&gt;(艾森·拉塞尔(Ethan M.Rasiel)) </li>\n<li>后退一步，搞清楚我们要解决的问题，然后看看手头的工作，问自己‘这些工作真的最重要吗？’<br>&lt;麦肯锡方法（经管图书的常青树，外企员工入职必读图书）&gt;(艾森·拉塞尔(Ethan M.Rasiel)) </li>\n<li>一次只做一件事，做好本职工作——不要试图去做整个团队的工作<br>&lt;麦肯锡方法（经管图书的常青树，外企员工入职必读图书）&gt;(艾森·拉塞尔(Ethan M.Rasiel)) </li>\n<li>30秒内向客户进行准确无误的解释<br>&lt;麦肯锡方法（经管图书的常青树，外企员工入职必读图书）&gt;(艾森·拉塞尔(Ethan M.Rasiel)) </li>\n<li>假如事实证明你的初始假设是错误的，那就根据事实做出调整。<br>&lt;麦肯锡方法（经管图书的常青树，外企员工入职必读图书）&gt;(艾森·拉塞尔(Ethan M.Rasiel)) </li>\n<li>相互独立、完全穷尽<br>&lt;麦肯锡方法（经管图书的常青树，外企员工入职必读图书）&gt;(艾森·拉塞尔(Ethan M.Rasiel)) </li>\n<li>白家老大败家和老二兴业发家的故事最后凝炼为一个有进口无出口的木匣儿，被村村寨寨一代一代富的穷的庄稼人咀嚼着品味着删改着充实着传给自己的后代，成为本原无可企及的经典性的乡土教材……<br>&lt;白鹿原（茅盾文学奖获奖作品；插图珍藏精装本）&gt;(陈忠实著) </li>\n<li>人能宏道，非道宏人<br>&lt;神游七部合集&gt;(徐公子胜治) </li>\n<li>我见到她之前，从未想到要结婚；我娶了她几十年，从未后悔娶她，也未想过要娶别的女人<br>&lt;且以优雅过一生：杨绛传（参透杨绛先生的百年人生智慧，做一个明媚从容、淡定优雅的女子。不妥协，不慌张，不迷茫，且以优雅过一生。）&gt;(桑妮) </li>\n<li>人，一生中会和很多人相遇，有些人只是为了擦身而过，有些人是等着一见如故<br>&lt;且以优雅过一生：杨绛传（参透杨绛先生的百年人生智慧，做一个明媚从容、淡定优雅的女子。不妥协，不慌张，不迷茫，且以优雅过一生。）&gt;(桑妮) </li>\n<li>望之俨然8，接之也温<br>&lt;且以优雅过一生：杨绛传（参透杨绛先生的百年人生智慧，做一个明媚从容、淡定优雅的女子。不妥协，不慌张，不迷茫，且以优雅过一生。）&gt;(桑妮) </li>\n<li>陪伴是最长情的告白<br>&lt;且以优雅过一生：杨绛传（参透杨绛先生的百年人生智慧，做一个明媚从容、淡定优雅的女子。不妥协，不慌张，不迷茫，且以优雅过一生。）&gt;(桑妮) </li>\n<li>我们曾如此渴望命运的波澜，到最后才发现：人生最曼妙的风景，竟是内心的淡定与从容……我们曾如此期盼外界的认可，到最后才知道：世界是自己的，与他人毫无关系<br>&lt;且以优雅过一生：杨绛传（参透杨绛先生的百年人生智慧，做一个明媚从容、淡定优雅的女子。不妥协，不慌张，不迷茫，且以优雅过一生。）&gt;(桑妮) </li>\n<li>一个人经过不同程度的锻炼，就获得不同程度的修养、不同程度的效益。好比香料，捣得愈碎，磨得愈细，香得愈浓烈。<br>&lt;且以优雅过一生：杨绛传（参透杨绛先生的百年人生智慧，做一个明媚从容、淡定优雅的女子。不妥协，不慌张，不迷茫，且以优雅过一生。）&gt;(桑妮) </li>\n<li>不乱于心，不困于情。不畏将来，不念过往。如此，安好！<br>&lt;且以优雅过一生：杨绛传（参透杨绛先生的百年人生智慧，做一个明媚从容、淡定优雅的女子。不妥协，不慌张，不迷茫，且以优雅过一生。）&gt;(桑妮) </li>\n<li>“信任”就是世上绝大多数金钱的唯一后盾。<br>&lt;人类简史：从动物到上帝（图文精编版） (开放历史系列)&gt;(Yuval Noah Harari) </li>\n<li>死虽然可怕，但这也就像是一次出门旅行。既然这个世上的芸芸众生早晚都要走上死的旅途，那么自己想要和最心爱的人，以最美的形式去旅行。<br>&lt;失乐园 (渡边淳一经典作品集)&gt;(渡边淳一) </li>\n<li>葬礼是人生的缩影<br>&lt;失乐园 (渡边淳一经典作品集)&gt;(渡边淳一) </li>\n<li>真正控制科学发展进度表的，也很少是科学家。<br>&lt;人类简史：从动物到上帝（图文精编版） (开放历史系列)&gt;(Yuval Noah Harari) </li>\n<li>恐怕只有性的世界是无所谓进步与退步的。<br>&lt;失乐园 (渡边淳一经典作品集)&gt;(渡边淳一) </li>\n<li>然而，演化本来就没有唯一的目的。器官的演化没有唯一的目的，而器官的使用方式也不断在变化。现在人体的所有器官早在几亿年前就已经出现了原型，而现在所有器官都不只做着原型所做的事。器官之所以演化是为了某种特定功能，但等到器官存在之后，要用作其他功能也并无不可。<br>&lt;人类简史：从动物到上帝（图文精编版） (开放历史系列)&gt;(Yuval Noah Harari) </li>\n<li>事实上，许多人认知的“自然”和“不自然”并不是生物学的概念，而是基督教神学的概念。神学上所谓的“自然”，指的是“符合创造自然的神的旨意”。基督教神学家认为，上帝创造了人的身体，并且让每个肢体和器官都有特定的目的。如<br>&lt;人类简史：从动物到上帝（图文精编版） (开放历史系列)&gt;(Yuval Noah Harari) </li>\n<li>他们认为，个人的价值是由社会阶级、由他人的看法所决定。<br>&lt;人类简史：从动物到上帝（图文精编版） (开放历史系列)&gt;(Yuval Noah Harari) </li>\n<li>奢侈品史上常有这样的情况，就是原本的奢侈品往往最后会成为必需品，而且带来新的义务<br>&lt;人类简史：从动物到上帝（图文精编版） (开放历史系列)&gt;(Yuval Noah Harari) </li>\n<li>病如西子胜三分<br>&lt;红楼梦脂评汇校本 (BookDNA典藏书系)&gt;(曹雪芹;脂砚斋) </li>\n<li>心较比干多一窍<br>&lt;红楼梦脂评汇校本 (BookDNA典藏书系)&gt;(曹雪芹;脂砚斋) </li>\n<li>一双似泣非泣含露目<br>&lt;红楼梦脂评汇校本 (BookDNA典藏书系)&gt;(曹雪芹;脂砚斋) </li>\n<li>两弯似蹙非蹙罥烟眉<br>&lt;红楼梦脂评汇校本 (BookDNA典藏书系)&gt;(曹雪芹;脂砚斋) </li>\n<li>粉面含春威不露，丹唇未启笑先闻<br>&lt;红楼梦脂评汇校本 (BookDNA典藏书系)&gt;(曹雪芹;脂砚斋) </li>\n<li>蛋挞是不能一口全吃掉的。 先咬一口，滚烫得令嘴唇受惊，但舍不得吞。 含在嘴里，暖热而踏实，慢慢吃。此时酥皮会有残屑，顺势撒下，一身都是。又薄又脆，沾衣亦不管。再咬第二口…… 直至连略带焦黄但又香脆无比的底层亦一并干掉，马上开始另一个。 ——通常，第二个没第一个好吃。<br>&lt;饺子&gt;(李碧华) </li>\n<li>气韵是作家的后脑勺。作家自己是看不到的。<br>&lt;罗生门（经典悬疑电影原著，对人性最深刻的拷问） (经典译林)&gt;(芥川龙之介) </li>\n<li>我们究竟为什么喜欢幼小的孩子呢？这个理由的一半，至少是由于用不着担心被小孩子欺骗。<br>&lt;罗生门（经典悬疑电影原著，对人性最深刻的拷问） (经典译林)&gt;(芥川龙之介) </li>\n<li>天才和我们只有一步的间隔。为了理解这一步，我们必须懂得百里路的一半是九十九里的超数学。<br>&lt;罗生门（经典悬疑电影原著，对人性最深刻的拷问） (经典译林)&gt;(芥川龙之介) </li>\n<li>发现民众的愚蠢，并不值得夸耀。但是，发现我们自己也是民众，倒的确值得夸耀。<br>&lt;罗生门（经典悬疑电影原著，对人性最深刻的拷问） (经典译林)&gt;(芥川龙之介) </li>\n<li>舆论常常是一种私刑。私刑又常常是一种娱乐。好比使用新闻记事来取代手枪。<br>&lt;罗生门（经典悬疑电影原著，对人性最深刻的拷问） (经典译林)&gt;(芥川龙之介) </li>\n<li>人生好像缺页很多的书。很难把它说成是一部书，然而它又确实是一部书。<br>&lt;罗生门（经典悬疑电影原著，对人性最深刻的拷问） (经典译林)&gt;(芥川龙之介) </li>\n<li>她们未必懂得丈夫们所为之舍生取义的理念和目标，但她们肯摒弃浮华肯用生命去诠释什么叫做爱情<br>&lt;他们最幸福&gt;(大冰 著) </li>\n<li>“要把地面上的人看清楚，就要和地面保持距离”。——卡尔维诺<br>&lt;他们最幸福&gt;(大冰 著) </li>\n<li>我们所观察到的并不是自然本身，而是自然在我们的提问下向我们显现出的面貌<br>&lt;有限与无限的游戏&gt;([美] 詹姆斯·卡斯) </li>\n<li>爱国主义──指的是意欲通过增强一个社会的权力来保护社会中的权力<br>&lt;有限与无限的游戏&gt;([美] 詹姆斯·卡斯) </li>\n<li>这些博物馆的创立初衷并不是保护艺术品免于遭受人民破坏，而是使人民免于接触艺术。<br>&lt;有限与无限的游戏&gt;([美] 詹姆斯·卡斯) </li>\n<li>公共意志及其权力所不及之处，不足以言节。<br>&lt;认得几个字&gt;(张大春) </li>\n<li>“不应该”居然是“应该”的产物<br>&lt;认得几个字&gt;(张大春) </li>\n<li>关于梦，神秘的也许不是那些无梦的真人或至人，是每一个人在睡眠中伟大的创作，醒来不记，怕是创作者真正的潇洒。<br>&lt;认得几个字&gt;(张大春) </li>\n<li>这技巧的本质，就是规则<br>&lt;亵渎&gt;(烟雨江南) </li>\n<li>宇宙中有多少生物，就有多少中心。<br>&lt;泛若不系之舟&gt;(傅真) </li>\n<li>如果“无神论”是建立在无知而自大的基础上，那么根本不是一件值得自豪的事情。<br>&lt;泛若不系之舟&gt;(傅真) </li>\n<li>宗教的偏执性其实是来自于人而并非它的本身<br>&lt;泛若不系之舟&gt;(傅真) </li>\n<li>那片土地上传统深植而禁忌丛生，却也一直有人勇敢地打破命运释放灵魂。<br>&lt;泛若不系之舟&gt;(傅真) </li>\n<li>我什么也没忘，但有些事只适合收藏。<br>&lt;去你家玩好吗&gt;(韩寒 监制) </li>\n<li>谁会讲故事，谁就拥有世界<br>&lt;白说&gt;(白岩松) </li>\n<li>比起那些用大嗓门企图压制世界的人，让全世界都安静下来听你小声说话的人更可畏。<br>&lt;告白与告别&gt;(韩寒) </li>\n<li>她的声音被保存下来，这是几百万沉默者中的一声呐喊，虽然这呐喊声是那么的微弱……但它比杀人者的嚎叫声更持久，比这个时代中所有的声音更响亮。<br>&lt;世界文学文库:安妮日记 &gt;(安妮•弗兰克 (Frank.A.)) </li>\n<li>在内心深处，年轻人比老年人更寂寞。<br>&lt;世界文学文库:安妮日记 &gt;(安妮•弗兰克 (Frank.A.)) </li>\n<li>没什么好怒的，大家都想赶时间，但我不想赶着死；大家都想抄捷径，但我不想抄末路。<br>&lt;从你的全世界路过（完美升级版）&gt;(张嘉佳) </li>\n<li>你可以不接受，这是一种自由。但不屑和抨击，翻到另外一个世界观，只能说明你的无知和武断。<br>&lt;从你的全世界路过（完美升级版）&gt;(张嘉佳) </li>\n<li>看到小清新不要说矫情。看到二逼段子不要说脑残。看到文艺范不要说装×。看到诗歌不要说无病呻吟。看到意识流不要说傻×。 每个人有自己的表达方式，如果你不喜欢，只能说明不是为你准备的。<br>&lt;从你的全世界路过（完美升级版）&gt;(张嘉佳) </li>\n<li>我们常说，轻易得来的，不会懂得珍惜。 其实不然，轻易得来的，你会害怕失去。<br>&lt;从你的全世界路过（完美升级版）&gt;(张嘉佳) </li>\n<li>艺术家永远支持鸡蛋，所以鸡蛋和墙碰撞的时候，不去问墙是对的，还是鸡蛋是对的，不管谁是对的，首先支持鸡蛋，<br>&lt;鱼羊野史·第1卷&gt;(高晓松) </li>\n<li>1915年，美国一位名叫特鲁多的医生去世了，他的墓碑上刻着三行字：“偶尔去治愈，常常去帮助，总是在抚慰。”<br>&lt;白说&gt;(白岩松) </li>\n<li>如果总在为未来忧虑，而不能享受此时此刻的时光，你可以把整个余生都搭进去，但你真的打算这么过一辈子吗？要知道，你所担心的事情，只有不超过10%会变成现实，其余的都是自己吓自己。而且生命中有一个很奇妙的逻辑，如果你真的过好今天，明天也还不错。<br>&lt;白说&gt;(白岩松) </li>\n<li>漂亮的失败是另一种成功<br>&lt;白说&gt;(白岩松) </li>\n<li>生命不只是使用，还需要奖励。<br>&lt;白说&gt;(白岩松) </li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Update-date-2018-4-14\"><a href=\"#Update-date-2018-4-14\" class=\"headerlink\" title=\"Update date: 2018/4/14\"></a>Update date: 2018/4/14</h3><ol>\n<li>游戏玩家会为自己的购买行为寻找理由，使自己相信自己并不愚蠢。唯一的解决办法就是不断掏腰包，以继续游戏。<br>&lt;上瘾：让用户养成使用习惯的四大产品逻辑&gt;([美]尼尔·埃亚尔,[美]瑞安·胡佛) </li>\n<li>游戏玩家会为自己的购买行为寻找理由，使自己相信自己并不愚蠢。唯一的解决办法就是不断掏腰包，以继续游戏。<br>&lt;上瘾：让用户养成使用习惯的四大产品逻辑&gt;([美]尼尔·埃亚尔,[美]瑞安·胡佛) </li>\n<li>想想你第一次啜饮啤酒或品尝辛辣食物时的反应，觉得美味吗？应该不太可能。我们的身体对酒精、辣椒素以及使辛辣食物产生热辣感的化合物有一种本能排斥。可是，反复品尝之后，我们会慢慢喜欢上这类口味。看到其他人喜爱这种口味，我们就会多尝上几口，久而久之，我们会渐渐适应这种口味。为避免这种不喜他人之喜的认知失调，我们会慢慢改变自己对过去不喜欢的事物的看法。<br>&lt;上瘾：让用户养成使用习惯的四大产品逻辑&gt;([美]尼尔·埃亚尔,[美]瑞安·胡佛) </li>\n<li>我们总会尽力和过去的行为保持一致<br>&lt;上瘾：让用户养成使用习惯的四大产品逻辑&gt;([美]尼尔·埃亚尔,[美]瑞安·胡佛) </li>\n<li>我们总会尽力和过去的行为保持一<br>&lt;上瘾：让用户养成使用习惯的四大产品逻辑&gt;([美]尼尔·埃亚尔,[美]瑞安·胡佛) </li>\n<li>我们总会高估自己的劳动成果<br>&lt;上瘾：让用户养成使用习惯的四大产品逻辑&gt;([美]尼尔·埃亚尔,[美]瑞安·胡佛) </li>\n<li>图21 变化不定的内容驱使一些用户在信息流中不停地搜索新鲜内容，而对于内容提供者来说，他们的酬赏来<br>&lt;上瘾：让用户养成使用习惯的四大产品逻辑&gt;([美]尼尔·埃亚尔,[美]瑞安·胡佛) </li>\n<li>驱使我们采取行动的，并不是酬赏本身，而是渴望酬赏时产生的那份迫切需要。<br>&lt;上瘾：让用户养成使用习惯的四大产品逻辑&gt;([美]尼尔·埃亚尔,[美]瑞安·胡佛) </li>\n<li>我们通常会以为互联网的优势在于花样翻新，但其实人们只想在网络上继续做自己熟悉的事<br>&lt;上瘾：让用户养成使用习惯的四大产品逻辑&gt;([美]尼尔·埃亚尔,[美]瑞安·胡佛) </li>\n<li>来自朋友或家人的推荐往往是科技传播的核心推动力<br>&lt;上瘾：让用户养成使用习惯的四大产品逻辑&gt;([美]尼尔·埃亚尔,[美]瑞安·胡佛) </li>\n<li>新产品要想在市场上站稳脚跟，略胜一筹是远远不够的，必须要有绝对优势<br>&lt;上瘾：让用户养成使用习惯的四大产品逻辑&gt;([美]尼尔·埃亚尔,[美]瑞安·胡佛) </li>\n<li>很多企业经营者都错误地认为，新产品只要比原有产品略胜一筹，就足以让用户一见倾心。但是，一旦涉及撼动用户的老习惯这个问题，天真的企业家们就会发现，好产品并不一定总能占据上风，尤其是当众多用户已经选择了其他具有竞争力的产品时<br>&lt;上瘾：让用户养成使用习惯的四大产品逻辑&gt;([美]尼尔·埃亚尔,[美]瑞安·胡佛) </li>\n<li>提高增长速度最关键的因素就是‘病毒循环周期’”<br>&lt;上瘾：让用户养成使用习惯的四大产品逻辑&gt;([美]尼尔·埃亚尔,[美]瑞安·胡佛) </li>\n<li>提高增长速度最关键的因素就是‘病毒循环周期<br>&lt;上瘾：让用户养成使用习惯的四大产品逻辑&gt;([美]尼尔·埃亚尔,[美]瑞安·胡佛) </li>\n<li>提高增长速度最关键的因素就是‘病毒循环周期’”<br>&lt;上瘾：让用户养成使用习惯的四大产品逻辑&gt;([美]尼尔·埃亚尔,[美]瑞安·胡佛) </li>\n<li>压力产生的不良情绪往往会触发这种无意识行为。<br>&lt;上瘾：让用户养成使用习惯的四大产品逻辑&gt;([美]尼尔·埃亚尔,[美]瑞安·胡佛) </li>\n<li>上瘾模型包括四个阶段：触发，行动，多变的酬赏，投入。<br>&lt;上瘾：让用户养成使用习惯的四大产品逻辑&gt;([美]尼尔·埃亚尔,[美]瑞安·胡佛) </li>\n<li>上瘾模型包括四个阶段：触发，行动，多变的酬赏，投<br>&lt;上瘾：让用户养成使用习惯的四大产品逻辑&gt;([美]尼尔·埃亚尔,[美]瑞安·胡佛) </li>\n<li>瘾模型包括四个阶段：触发，行动，多变的酬赏，投入<br>&lt;上瘾：让用户养成使用习惯的四大产品逻辑&gt;([美]尼尔·埃亚尔,[美]瑞安·胡佛) </li>\n<li>集网络连接、海量数据、超快网速三者于一身的技术正在使这个世界上瘾成性。<br>&lt;上瘾：让用户养成使用习惯的四大产品逻辑&gt;([美]尼尔·埃亚尔,[美]瑞安·胡佛) </li>\n<li>苹果已经不再是一个创新者，而是已经成为了主流的象征<br>&lt;苹果首席设计师:乔纳森传 &gt;</li>\n<li>设计不是看起来和感觉起来怎么样，而是用起来怎么样<br>&lt;苹果首席设计师:乔纳森传 &gt;</li>\n<li>就算再索然无味的故事也要有一个结局<br>&lt;那个不为人知的故事 &gt;</li>\n<li>人往往就是这个样子，在相处的过程中，每个人都会发现其他人与自己不同的地方，而当他们意识到这种不同带来的内在差异时，原本积极的感情，也会转化为无形的恶意。<br>&lt;那个不为人知的故事 &gt;</li>\n<li>这很美妙。 当我睁开眼，你和朝阳一起存在。<br>&lt;那个不为人知的故事 &gt;</li>\n<li>站在高处，你可以选择向下看。但是在低处，你别无选择。”<br>&lt;那个不为人知的故事 &gt;</li>\n<li>如果一个人失去了基本尊严，那么他就可以像行尸走肉一样被控制。<br>&lt;那些忧伤的年轻人(十周年纪念版)&gt;(许知远) </li>\n<li>暧昧的怀旧，这是现代人无法挥去的情结。<br>&lt;那些忧伤的年轻人(十周年纪念版)&gt;(许知远) </li>\n<li>将爱情形式化，是一种社会的需要，是随着生活的愈益严酷而愈益迫切的需要。<br>&lt;那些忧伤的年轻人(十周年纪念版)&gt;(许知远) </li>\n<li>我至少拥有青春中一个关键的情感——迷惘。<br>&lt;那些忧伤的年轻人(十周年纪念版)&gt;(许知远) </li>\n<li>如今他们老了，我们也老了，像告别了蜜月期的情侣，我们相互指责对方的叛变，同时谁也无法忘记那些最美妙的时光。<br>&lt;那些忧伤的年轻人(十周年纪念版)&gt;(许知远) </li>\n<li>真正感动人的，从来不是思想，而是年轻的勇气。李敖在这篇文章中，并没有表现出过人的思想，他只是以一个27岁的青年的身份在说话，他毫不掩饰他的感慨，他的愤怒，他的欲望，他的痛苦，和身处困境中却毫不动摇的勇敢……这一切正触动了所有年轻心灵的神经。<br>&lt;那些忧伤的年轻人(十周年纪念版)&gt;(许知远) </li>\n<li>麦肯锡非常强调不是“为客户工作”(work for clients)而是“与客户合作”(work with clients)<br>&lt;麦肯锡方法（经管图书的常青树，外企员工入职必读图书）&gt;(艾森·拉塞尔(Ethan M.Rasiel)) </li>\n<li>一次访谈要从一般性的问题问起，然后进行具体问题的提问。不要一头扎进敏感领域<br>&lt;麦肯锡方法（经管图书的常青树，外企员工入职必读图书）&gt;(艾森·拉塞尔(Ethan M.Rasiel)) </li>\n<li>后退一步，搞清楚我们要解决的问题，然后看看手头的工作，问自己‘这些工作真的最重要吗？’<br>&lt;麦肯锡方法（经管图书的常青树，外企员工入职必读图书）&gt;(艾森·拉塞尔(Ethan M.Rasiel)) </li>\n<li>一次只做一件事，做好本职工作——不要试图去做整个团队的工作<br>&lt;麦肯锡方法（经管图书的常青树，外企员工入职必读图书）&gt;(艾森·拉塞尔(Ethan M.Rasiel)) </li>\n<li>30秒内向客户进行准确无误的解释<br>&lt;麦肯锡方法（经管图书的常青树，外企员工入职必读图书）&gt;(艾森·拉塞尔(Ethan M.Rasiel)) </li>\n<li>假如事实证明你的初始假设是错误的，那就根据事实做出调整。<br>&lt;麦肯锡方法（经管图书的常青树，外企员工入职必读图书）&gt;(艾森·拉塞尔(Ethan M.Rasiel)) </li>\n<li>相互独立、完全穷尽<br>&lt;麦肯锡方法（经管图书的常青树，外企员工入职必读图书）&gt;(艾森·拉塞尔(Ethan M.Rasiel)) </li>\n<li>白家老大败家和老二兴业发家的故事最后凝炼为一个有进口无出口的木匣儿，被村村寨寨一代一代富的穷的庄稼人咀嚼着品味着删改着充实着传给自己的后代，成为本原无可企及的经典性的乡土教材……<br>&lt;白鹿原（茅盾文学奖获奖作品；插图珍藏精装本）&gt;(陈忠实著) </li>\n<li>人能宏道，非道宏人<br>&lt;神游七部合集&gt;(徐公子胜治) </li>\n<li>我见到她之前，从未想到要结婚；我娶了她几十年，从未后悔娶她，也未想过要娶别的女人<br>&lt;且以优雅过一生：杨绛传（参透杨绛先生的百年人生智慧，做一个明媚从容、淡定优雅的女子。不妥协，不慌张，不迷茫，且以优雅过一生。）&gt;(桑妮) </li>\n<li>人，一生中会和很多人相遇，有些人只是为了擦身而过，有些人是等着一见如故<br>&lt;且以优雅过一生：杨绛传（参透杨绛先生的百年人生智慧，做一个明媚从容、淡定优雅的女子。不妥协，不慌张，不迷茫，且以优雅过一生。）&gt;(桑妮) </li>\n<li>望之俨然8，接之也温<br>&lt;且以优雅过一生：杨绛传（参透杨绛先生的百年人生智慧，做一个明媚从容、淡定优雅的女子。不妥协，不慌张，不迷茫，且以优雅过一生。）&gt;(桑妮) </li>\n<li>陪伴是最长情的告白<br>&lt;且以优雅过一生：杨绛传（参透杨绛先生的百年人生智慧，做一个明媚从容、淡定优雅的女子。不妥协，不慌张，不迷茫，且以优雅过一生。）&gt;(桑妮) </li>\n<li>我们曾如此渴望命运的波澜，到最后才发现：人生最曼妙的风景，竟是内心的淡定与从容……我们曾如此期盼外界的认可，到最后才知道：世界是自己的，与他人毫无关系<br>&lt;且以优雅过一生：杨绛传（参透杨绛先生的百年人生智慧，做一个明媚从容、淡定优雅的女子。不妥协，不慌张，不迷茫，且以优雅过一生。）&gt;(桑妮) </li>\n<li>一个人经过不同程度的锻炼，就获得不同程度的修养、不同程度的效益。好比香料，捣得愈碎，磨得愈细，香得愈浓烈。<br>&lt;且以优雅过一生：杨绛传（参透杨绛先生的百年人生智慧，做一个明媚从容、淡定优雅的女子。不妥协，不慌张，不迷茫，且以优雅过一生。）&gt;(桑妮) </li>\n<li>不乱于心，不困于情。不畏将来，不念过往。如此，安好！<br>&lt;且以优雅过一生：杨绛传（参透杨绛先生的百年人生智慧，做一个明媚从容、淡定优雅的女子。不妥协，不慌张，不迷茫，且以优雅过一生。）&gt;(桑妮) </li>\n<li>“信任”就是世上绝大多数金钱的唯一后盾。<br>&lt;人类简史：从动物到上帝（图文精编版） (开放历史系列)&gt;(Yuval Noah Harari) </li>\n<li>死虽然可怕，但这也就像是一次出门旅行。既然这个世上的芸芸众生早晚都要走上死的旅途，那么自己想要和最心爱的人，以最美的形式去旅行。<br>&lt;失乐园 (渡边淳一经典作品集)&gt;(渡边淳一) </li>\n<li>葬礼是人生的缩影<br>&lt;失乐园 (渡边淳一经典作品集)&gt;(渡边淳一) </li>\n<li>真正控制科学发展进度表的，也很少是科学家。<br>&lt;人类简史：从动物到上帝（图文精编版） (开放历史系列)&gt;(Yuval Noah Harari) </li>\n<li>恐怕只有性的世界是无所谓进步与退步的。<br>&lt;失乐园 (渡边淳一经典作品集)&gt;(渡边淳一) </li>\n<li>然而，演化本来就没有唯一的目的。器官的演化没有唯一的目的，而器官的使用方式也不断在变化。现在人体的所有器官早在几亿年前就已经出现了原型，而现在所有器官都不只做着原型所做的事。器官之所以演化是为了某种特定功能，但等到器官存在之后，要用作其他功能也并无不可。<br>&lt;人类简史：从动物到上帝（图文精编版） (开放历史系列)&gt;(Yuval Noah Harari) </li>\n<li>事实上，许多人认知的“自然”和“不自然”并不是生物学的概念，而是基督教神学的概念。神学上所谓的“自然”，指的是“符合创造自然的神的旨意”。基督教神学家认为，上帝创造了人的身体，并且让每个肢体和器官都有特定的目的。如<br>&lt;人类简史：从动物到上帝（图文精编版） (开放历史系列)&gt;(Yuval Noah Harari) </li>\n<li>他们认为，个人的价值是由社会阶级、由他人的看法所决定。<br>&lt;人类简史：从动物到上帝（图文精编版） (开放历史系列)&gt;(Yuval Noah Harari) </li>\n<li>奢侈品史上常有这样的情况，就是原本的奢侈品往往最后会成为必需品，而且带来新的义务<br>&lt;人类简史：从动物到上帝（图文精编版） (开放历史系列)&gt;(Yuval Noah Harari) </li>\n<li>病如西子胜三分<br>&lt;红楼梦脂评汇校本 (BookDNA典藏书系)&gt;(曹雪芹;脂砚斋) </li>\n<li>心较比干多一窍<br>&lt;红楼梦脂评汇校本 (BookDNA典藏书系)&gt;(曹雪芹;脂砚斋) </li>\n<li>一双似泣非泣含露目<br>&lt;红楼梦脂评汇校本 (BookDNA典藏书系)&gt;(曹雪芹;脂砚斋) </li>\n<li>两弯似蹙非蹙罥烟眉<br>&lt;红楼梦脂评汇校本 (BookDNA典藏书系)&gt;(曹雪芹;脂砚斋) </li>\n<li>粉面含春威不露，丹唇未启笑先闻<br>&lt;红楼梦脂评汇校本 (BookDNA典藏书系)&gt;(曹雪芹;脂砚斋) </li>\n<li>蛋挞是不能一口全吃掉的。 先咬一口，滚烫得令嘴唇受惊，但舍不得吞。 含在嘴里，暖热而踏实，慢慢吃。此时酥皮会有残屑，顺势撒下，一身都是。又薄又脆，沾衣亦不管。再咬第二口…… 直至连略带焦黄但又香脆无比的底层亦一并干掉，马上开始另一个。 ——通常，第二个没第一个好吃。<br>&lt;饺子&gt;(李碧华) </li>\n<li>气韵是作家的后脑勺。作家自己是看不到的。<br>&lt;罗生门（经典悬疑电影原著，对人性最深刻的拷问） (经典译林)&gt;(芥川龙之介) </li>\n<li>我们究竟为什么喜欢幼小的孩子呢？这个理由的一半，至少是由于用不着担心被小孩子欺骗。<br>&lt;罗生门（经典悬疑电影原著，对人性最深刻的拷问） (经典译林)&gt;(芥川龙之介) </li>\n<li>天才和我们只有一步的间隔。为了理解这一步，我们必须懂得百里路的一半是九十九里的超数学。<br>&lt;罗生门（经典悬疑电影原著，对人性最深刻的拷问） (经典译林)&gt;(芥川龙之介) </li>\n<li>发现民众的愚蠢，并不值得夸耀。但是，发现我们自己也是民众，倒的确值得夸耀。<br>&lt;罗生门（经典悬疑电影原著，对人性最深刻的拷问） (经典译林)&gt;(芥川龙之介) </li>\n<li>舆论常常是一种私刑。私刑又常常是一种娱乐。好比使用新闻记事来取代手枪。<br>&lt;罗生门（经典悬疑电影原著，对人性最深刻的拷问） (经典译林)&gt;(芥川龙之介) </li>\n<li>人生好像缺页很多的书。很难把它说成是一部书，然而它又确实是一部书。<br>&lt;罗生门（经典悬疑电影原著，对人性最深刻的拷问） (经典译林)&gt;(芥川龙之介) </li>\n<li>她们未必懂得丈夫们所为之舍生取义的理念和目标，但她们肯摒弃浮华肯用生命去诠释什么叫做爱情<br>&lt;他们最幸福&gt;(大冰 著) </li>\n<li>“要把地面上的人看清楚，就要和地面保持距离”。——卡尔维诺<br>&lt;他们最幸福&gt;(大冰 著) </li>\n<li>我们所观察到的并不是自然本身，而是自然在我们的提问下向我们显现出的面貌<br>&lt;有限与无限的游戏&gt;([美] 詹姆斯·卡斯) </li>\n<li>爱国主义──指的是意欲通过增强一个社会的权力来保护社会中的权力<br>&lt;有限与无限的游戏&gt;([美] 詹姆斯·卡斯) </li>\n<li>这些博物馆的创立初衷并不是保护艺术品免于遭受人民破坏，而是使人民免于接触艺术。<br>&lt;有限与无限的游戏&gt;([美] 詹姆斯·卡斯) </li>\n<li>公共意志及其权力所不及之处，不足以言节。<br>&lt;认得几个字&gt;(张大春) </li>\n<li>“不应该”居然是“应该”的产物<br>&lt;认得几个字&gt;(张大春) </li>\n<li>关于梦，神秘的也许不是那些无梦的真人或至人，是每一个人在睡眠中伟大的创作，醒来不记，怕是创作者真正的潇洒。<br>&lt;认得几个字&gt;(张大春) </li>\n<li>这技巧的本质，就是规则<br>&lt;亵渎&gt;(烟雨江南) </li>\n<li>宇宙中有多少生物，就有多少中心。<br>&lt;泛若不系之舟&gt;(傅真) </li>\n<li>如果“无神论”是建立在无知而自大的基础上，那么根本不是一件值得自豪的事情。<br>&lt;泛若不系之舟&gt;(傅真) </li>\n<li>宗教的偏执性其实是来自于人而并非它的本身<br>&lt;泛若不系之舟&gt;(傅真) </li>\n<li>那片土地上传统深植而禁忌丛生，却也一直有人勇敢地打破命运释放灵魂。<br>&lt;泛若不系之舟&gt;(傅真) </li>\n<li>我什么也没忘，但有些事只适合收藏。<br>&lt;去你家玩好吗&gt;(韩寒 监制) </li>\n<li>谁会讲故事，谁就拥有世界<br>&lt;白说&gt;(白岩松) </li>\n<li>比起那些用大嗓门企图压制世界的人，让全世界都安静下来听你小声说话的人更可畏。<br>&lt;告白与告别&gt;(韩寒) </li>\n<li>她的声音被保存下来，这是几百万沉默者中的一声呐喊，虽然这呐喊声是那么的微弱……但它比杀人者的嚎叫声更持久，比这个时代中所有的声音更响亮。<br>&lt;世界文学文库:安妮日记 &gt;(安妮•弗兰克 (Frank.A.)) </li>\n<li>在内心深处，年轻人比老年人更寂寞。<br>&lt;世界文学文库:安妮日记 &gt;(安妮•弗兰克 (Frank.A.)) </li>\n<li>没什么好怒的，大家都想赶时间，但我不想赶着死；大家都想抄捷径，但我不想抄末路。<br>&lt;从你的全世界路过（完美升级版）&gt;(张嘉佳) </li>\n<li>你可以不接受，这是一种自由。但不屑和抨击，翻到另外一个世界观，只能说明你的无知和武断。<br>&lt;从你的全世界路过（完美升级版）&gt;(张嘉佳) </li>\n<li>看到小清新不要说矫情。看到二逼段子不要说脑残。看到文艺范不要说装×。看到诗歌不要说无病呻吟。看到意识流不要说傻×。 每个人有自己的表达方式，如果你不喜欢，只能说明不是为你准备的。<br>&lt;从你的全世界路过（完美升级版）&gt;(张嘉佳) </li>\n<li>我们常说，轻易得来的，不会懂得珍惜。 其实不然，轻易得来的，你会害怕失去。<br>&lt;从你的全世界路过（完美升级版）&gt;(张嘉佳) </li>\n<li>艺术家永远支持鸡蛋，所以鸡蛋和墙碰撞的时候，不去问墙是对的，还是鸡蛋是对的，不管谁是对的，首先支持鸡蛋，<br>&lt;鱼羊野史·第1卷&gt;(高晓松) </li>\n<li>1915年，美国一位名叫特鲁多的医生去世了，他的墓碑上刻着三行字：“偶尔去治愈，常常去帮助，总是在抚慰。”<br>&lt;白说&gt;(白岩松) </li>\n<li>如果总在为未来忧虑，而不能享受此时此刻的时光，你可以把整个余生都搭进去，但你真的打算这么过一辈子吗？要知道，你所担心的事情，只有不超过10%会变成现实，其余的都是自己吓自己。而且生命中有一个很奇妙的逻辑，如果你真的过好今天，明天也还不错。<br>&lt;白说&gt;(白岩松) </li>\n<li>漂亮的失败是另一种成功<br>&lt;白说&gt;(白岩松) </li>\n<li>生命不只是使用，还需要奖励。<br>&lt;白说&gt;(白岩松) </li>\n</ol>\n"},{"title":"Windows平台最优秀的解压软件：Bandizip","date":"2018-01-26T00:56:16.000Z","_content":"\nWindows平台常用的解压缩软件有很多，例如WinRAR、WinZIP、好压、7zip。然而好压、快压五花八门的广告植入和7zip的画风过于极客都无法满足我对软件的优雅的要求。终于一款界面简洁又不失设计感的解压软件出现在了我的眼前——Bandizip。\n\n### Bandizip简介\n\nBandizip压缩软件是一款轻量级的免费解压缩工具，来自韩国。支持查看ZIP、7Z、RAR后缀的绝大多数windows压缩文档格式，TAR、GZ、TGZ等UNIX格式，以及CD/DVD镜像等文件格式。\n\n### 特点介绍\n\n1. 文件预览\n\n   当我们右击压缩包时，Bandizip会自动进行文件预览，能够让你更加方便快捷的看到压缩包总的内容，从而帮助你决定是否要解压，这比通常双击之后还要继续右击解压的操作要便捷得多。\n\n   ![文件预览](http://ww1.sinaimg.cn/large/ab97666ely1fnszlsvjpcj20gb092aa4.jpg)\n\n2. 【自动解压】命令\n\n   从前我们总是会遇到解压一个压缩包，解压之后发现解压的文件铺满了屏幕，或者是选择解压到某一文件夹中然后发现多嵌套了一层文件夹，这让许多有强迫症的同学内心极度崩溃。然而Bandizip最为使用的一个特点就是可以进行自动解压。\n\n   ![自动解压](http://ww1.sinaimg.cn/large/ab97666ely1fnszlsurn6j20cs03y746.jpg)\n\n   Bandizip会自动识别压缩文件中是只有单一文件夹，如果是那么就直接解压文件，若有多个文件，则新建与压缩包同名的文件夹，在此文件夹中解压。\n\n3. 图片预览\n\n   当需要从压缩文件中找到特定的图片时，Bandizip内建的缩略图浏览器就显得十分必要，双击进入压缩文件就可以预览所有图片\n\n   ![图片预览](http://ww1.sinaimg.cn/large/ab97666ely1fnszlt1fqij20mc0glwiw.jpg)\n\n4. 图标颜色区分\n\n   Bandizip对于不同压缩格式文件的图标颜色显示是不一样的。例如，zip文件是蓝色，7z文件是绿色\n\n   ![图标颜色](http://ww1.sinaimg.cn/large/ab97666ely1fnszlsuo5rj207b03qq2u.jpg)\n\n5. 界面风格\n\n   6.0版本之后Bandizip的界面与Win10系统的风格很接近\n\n   ![界面](http://ww1.sinaimg.cn/large/ab97666ely1fnszlszjf1j20md0gjgo2.jpg)\n\n   ​\n\n### 总结\n\n压缩软件作为我们日常办公学习的常用软件，就是要做到简洁、高效。而Bandizip恰恰做到了简洁统一的界面和易用高效的使用体验。并且Bandizip十分轻量，免费，无广告。它配得上被称为Windows平台最优秀的一款压缩软件。\n\n[Bandizip官网](https://www.bandisoft.com/bandizip/cn/)","source":"_posts/Windows平台最优秀的解压软件：Bandizip.md","raw":"---\ntitle: Windows平台最优秀的解压软件：Bandizip\ndate: 2018-01-25 16:56:16\ntags: Softwares\n---\n\nWindows平台常用的解压缩软件有很多，例如WinRAR、WinZIP、好压、7zip。然而好压、快压五花八门的广告植入和7zip的画风过于极客都无法满足我对软件的优雅的要求。终于一款界面简洁又不失设计感的解压软件出现在了我的眼前——Bandizip。\n\n### Bandizip简介\n\nBandizip压缩软件是一款轻量级的免费解压缩工具，来自韩国。支持查看ZIP、7Z、RAR后缀的绝大多数windows压缩文档格式，TAR、GZ、TGZ等UNIX格式，以及CD/DVD镜像等文件格式。\n\n### 特点介绍\n\n1. 文件预览\n\n   当我们右击压缩包时，Bandizip会自动进行文件预览，能够让你更加方便快捷的看到压缩包总的内容，从而帮助你决定是否要解压，这比通常双击之后还要继续右击解压的操作要便捷得多。\n\n   ![文件预览](http://ww1.sinaimg.cn/large/ab97666ely1fnszlsvjpcj20gb092aa4.jpg)\n\n2. 【自动解压】命令\n\n   从前我们总是会遇到解压一个压缩包，解压之后发现解压的文件铺满了屏幕，或者是选择解压到某一文件夹中然后发现多嵌套了一层文件夹，这让许多有强迫症的同学内心极度崩溃。然而Bandizip最为使用的一个特点就是可以进行自动解压。\n\n   ![自动解压](http://ww1.sinaimg.cn/large/ab97666ely1fnszlsurn6j20cs03y746.jpg)\n\n   Bandizip会自动识别压缩文件中是只有单一文件夹，如果是那么就直接解压文件，若有多个文件，则新建与压缩包同名的文件夹，在此文件夹中解压。\n\n3. 图片预览\n\n   当需要从压缩文件中找到特定的图片时，Bandizip内建的缩略图浏览器就显得十分必要，双击进入压缩文件就可以预览所有图片\n\n   ![图片预览](http://ww1.sinaimg.cn/large/ab97666ely1fnszlt1fqij20mc0glwiw.jpg)\n\n4. 图标颜色区分\n\n   Bandizip对于不同压缩格式文件的图标颜色显示是不一样的。例如，zip文件是蓝色，7z文件是绿色\n\n   ![图标颜色](http://ww1.sinaimg.cn/large/ab97666ely1fnszlsuo5rj207b03qq2u.jpg)\n\n5. 界面风格\n\n   6.0版本之后Bandizip的界面与Win10系统的风格很接近\n\n   ![界面](http://ww1.sinaimg.cn/large/ab97666ely1fnszlszjf1j20md0gjgo2.jpg)\n\n   ​\n\n### 总结\n\n压缩软件作为我们日常办公学习的常用软件，就是要做到简洁、高效。而Bandizip恰恰做到了简洁统一的界面和易用高效的使用体验。并且Bandizip十分轻量，免费，无广告。它配得上被称为Windows平台最优秀的一款压缩软件。\n\n[Bandizip官网](https://www.bandisoft.com/bandizip/cn/)","slug":"Windows平台最优秀的解压软件：Bandizip","published":1,"updated":"2018-01-25T10:48:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcqk30wy0005pu9kdim89e9o","content":"<p>Windows平台常用的解压缩软件有很多，例如WinRAR、WinZIP、好压、7zip。然而好压、快压五花八门的广告植入和7zip的画风过于极客都无法满足我对软件的优雅的要求。终于一款界面简洁又不失设计感的解压软件出现在了我的眼前——Bandizip。</p>\n<h3 id=\"Bandizip简介\"><a href=\"#Bandizip简介\" class=\"headerlink\" title=\"Bandizip简介\"></a>Bandizip简介</h3><p>Bandizip压缩软件是一款轻量级的免费解压缩工具，来自韩国。支持查看ZIP、7Z、RAR后缀的绝大多数windows压缩文档格式，TAR、GZ、TGZ等UNIX格式，以及CD/DVD镜像等文件格式。</p>\n<h3 id=\"特点介绍\"><a href=\"#特点介绍\" class=\"headerlink\" title=\"特点介绍\"></a>特点介绍</h3><ol>\n<li><p>文件预览</p>\n<p>当我们右击压缩包时，Bandizip会自动进行文件预览，能够让你更加方便快捷的看到压缩包总的内容，从而帮助你决定是否要解压，这比通常双击之后还要继续右击解压的操作要便捷得多。</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/ab97666ely1fnszlsvjpcj20gb092aa4.jpg\" alt=\"文件预览\"></p>\n</li>\n<li><p>【自动解压】命令</p>\n<p>从前我们总是会遇到解压一个压缩包，解压之后发现解压的文件铺满了屏幕，或者是选择解压到某一文件夹中然后发现多嵌套了一层文件夹，这让许多有强迫症的同学内心极度崩溃。然而Bandizip最为使用的一个特点就是可以进行自动解压。</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/ab97666ely1fnszlsurn6j20cs03y746.jpg\" alt=\"自动解压\"></p>\n<p>Bandizip会自动识别压缩文件中是只有单一文件夹，如果是那么就直接解压文件，若有多个文件，则新建与压缩包同名的文件夹，在此文件夹中解压。</p>\n</li>\n<li><p>图片预览</p>\n<p>当需要从压缩文件中找到特定的图片时，Bandizip内建的缩略图浏览器就显得十分必要，双击进入压缩文件就可以预览所有图片</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/ab97666ely1fnszlt1fqij20mc0glwiw.jpg\" alt=\"图片预览\"></p>\n</li>\n<li><p>图标颜色区分</p>\n<p>Bandizip对于不同压缩格式文件的图标颜色显示是不一样的。例如，zip文件是蓝色，7z文件是绿色</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/ab97666ely1fnszlsuo5rj207b03qq2u.jpg\" alt=\"图标颜色\"></p>\n</li>\n<li><p>界面风格</p>\n<p>6.0版本之后Bandizip的界面与Win10系统的风格很接近</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/ab97666ely1fnszlszjf1j20md0gjgo2.jpg\" alt=\"界面\"></p>\n<p>​</p>\n</li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>压缩软件作为我们日常办公学习的常用软件，就是要做到简洁、高效。而Bandizip恰恰做到了简洁统一的界面和易用高效的使用体验。并且Bandizip十分轻量，免费，无广告。它配得上被称为Windows平台最优秀的一款压缩软件。</p>\n<p><a href=\"https://www.bandisoft.com/bandizip/cn/\" target=\"_blank\" rel=\"noopener\">Bandizip官网</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Windows平台常用的解压缩软件有很多，例如WinRAR、WinZIP、好压、7zip。然而好压、快压五花八门的广告植入和7zip的画风过于极客都无法满足我对软件的优雅的要求。终于一款界面简洁又不失设计感的解压软件出现在了我的眼前——Bandizip。</p>\n<h3 id=\"Bandizip简介\"><a href=\"#Bandizip简介\" class=\"headerlink\" title=\"Bandizip简介\"></a>Bandizip简介</h3><p>Bandizip压缩软件是一款轻量级的免费解压缩工具，来自韩国。支持查看ZIP、7Z、RAR后缀的绝大多数windows压缩文档格式，TAR、GZ、TGZ等UNIX格式，以及CD/DVD镜像等文件格式。</p>\n<h3 id=\"特点介绍\"><a href=\"#特点介绍\" class=\"headerlink\" title=\"特点介绍\"></a>特点介绍</h3><ol>\n<li><p>文件预览</p>\n<p>当我们右击压缩包时，Bandizip会自动进行文件预览，能够让你更加方便快捷的看到压缩包总的内容，从而帮助你决定是否要解压，这比通常双击之后还要继续右击解压的操作要便捷得多。</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/ab97666ely1fnszlsvjpcj20gb092aa4.jpg\" alt=\"文件预览\"></p>\n</li>\n<li><p>【自动解压】命令</p>\n<p>从前我们总是会遇到解压一个压缩包，解压之后发现解压的文件铺满了屏幕，或者是选择解压到某一文件夹中然后发现多嵌套了一层文件夹，这让许多有强迫症的同学内心极度崩溃。然而Bandizip最为使用的一个特点就是可以进行自动解压。</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/ab97666ely1fnszlsurn6j20cs03y746.jpg\" alt=\"自动解压\"></p>\n<p>Bandizip会自动识别压缩文件中是只有单一文件夹，如果是那么就直接解压文件，若有多个文件，则新建与压缩包同名的文件夹，在此文件夹中解压。</p>\n</li>\n<li><p>图片预览</p>\n<p>当需要从压缩文件中找到特定的图片时，Bandizip内建的缩略图浏览器就显得十分必要，双击进入压缩文件就可以预览所有图片</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/ab97666ely1fnszlt1fqij20mc0glwiw.jpg\" alt=\"图片预览\"></p>\n</li>\n<li><p>图标颜色区分</p>\n<p>Bandizip对于不同压缩格式文件的图标颜色显示是不一样的。例如，zip文件是蓝色，7z文件是绿色</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/ab97666ely1fnszlsuo5rj207b03qq2u.jpg\" alt=\"图标颜色\"></p>\n</li>\n<li><p>界面风格</p>\n<p>6.0版本之后Bandizip的界面与Win10系统的风格很接近</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/ab97666ely1fnszlszjf1j20md0gjgo2.jpg\" alt=\"界面\"></p>\n<p>​</p>\n</li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>压缩软件作为我们日常办公学习的常用软件，就是要做到简洁、高效。而Bandizip恰恰做到了简洁统一的界面和易用高效的使用体验。并且Bandizip十分轻量，免费，无广告。它配得上被称为Windows平台最优秀的一款压缩软件。</p>\n<p><a href=\"https://www.bandisoft.com/bandizip/cn/\" target=\"_blank\" rel=\"noopener\">Bandizip官网</a></p>\n"},{"title":"Leetcode_Summary","date":"2020-01-20T21:02:27.000Z","_content":"\nSources:\n1. summer\n2. 1-50\n3. Top Interview Questions (before 200)\n\n## DFS + memo\n\n### 98. Validate Binary Search Tree (Medium) [@](https://leetcode.com/problems/validate-binary-search-tree/)\n\n> Given a binary tree, determine if it is a valid binary search tree (BST).\n>\n> Assume a BST is defined as follows:\n>\n> - The left subtree of a node contains only nodes with keys **less than** the node's key.\n> - The right subtree of a node contains only nodes with keys **greater than** the node's key.\n> - Both the left and right subtrees must also be binary search trees.\n>\n\n**Solution 1 Recursion**\n\n```java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    private boolean helper(TreeNode node, Integer lower, Integer upper) {\n        if (node == null) return true;\n        \n        int val = node.val;\n        if (lower != null && val <= lower) return false;\n        if (upper != null && val >= upper) return false;\n        \n        if (!helper(node.left, lower, val)) return false;\n        if (!helper(node.right, val, upper)) return false;\n        return true;\n    }\n    public boolean isValidBST(TreeNode root) {\n        return helper(root, null, null);\n    }\n}\n```\n**Solution 2 Iteration**\n\n```java\n    LinkedList<TreeNode> stack = new LinkedList();\n    LinkedList<Integer> uppers = new LinkedList(), lowers = new LinkedList();\n    \n    private void update(TreeNode root, Integer lower, Integer upper) {\n        stack.add(root);\n        uppers.add(upper);\n        lowers.add(lower);\n    }\n    public boolean isValidBST(TreeNode root) {\n        Integer lower = null, upper = null, val;\n        update(root, lower, upper);\n        \n        while (!stack.isEmpty()) {\n            root = stack.poll();\n            lower = lowers.poll();\n            upper = uppers.poll();\n            \n            if (root == null) continue;\n            val = root.val;\n            if (lower != null && val <= lower) return false;\n            if (upper != null && val >= upper) return false;\n            update(root.left, lower, val);\n            update(root.right, val, upper);\n        }\n        return true;\n    }\n```\n**Solution 3 Inorder Traversal**\n\n```java\n    public boolean isValidBST(TreeNode root) {\n        Stack<TreeNode> stack = new Stack();\n        double inorder = - Double.MAX_VALUE;\n        \n        while (!stack.isEmpty() || root != null) {\n            while (root != null) {\n                stack.push(root);\n                root = root.left;\n            }\n            root = stack.pop();\n            if (root.val <= inorder) return false;\n            inorder = root.val;\n            root = root.right;\n        }\n        return true;\n    }\n```\n\n### 101. Symmetric Tree (Easy) [@](https://leetcode.com/problems/symmetric-tree/)\n\n> Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).\n>\n> For example, this binary tree `[1,2,2,3,4,4,3]` is symmetric:\n>\n> ```\n>  1\n> / \\\n> 2   2\n> / \\ / \\\n> 3  4 4  3\n> ```\n>\n> \n>\n> But the following `[1,2,2,null,3,null,3]` is not:\n>\n> ```\n>  1\n> / \\\n> 2   2\n> \\   \\\n> 3    3\n> ```\n\n**Solution 1 Recursion**\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    private boolean isMirror(TreeNode t1, TreeNode t2) {\n        if (t1 == null && t2 == null) return true;\n        if (t1 == null || t2 == null) return false;\n        return (t1.val == t2.val) && isMirror(t1.right, t2.left) && isMirror(t1.left, t2.right);\n    }\n    public boolean isSymmetric(TreeNode root) {\n        if (root == null) \n            return true;\n        else\n            return isMirror(root.left, root.right);\n    }\n}\n```\n**Solution 2 Iteration**\n\n```java\npublic boolean isSymmetric(TreeNode root) {\n    if (root == null) return true;\n\n    Queue<TreeNode> q = new LinkedList();\n    q.add(root.left);\n    q.add(root.right);\n    while (!q.isEmpty()) {\n        TreeNode t1 = q.poll();\n        TreeNode t2 = q.poll();\n        if (t1 == null && t2 == null) continue;\n        if (t1 == null || t2 == null) return false;\n        if (t1.val != t2.val) return false;\n        q.add(t1.left);\n        q.add(t2.right);\n        q.add(t1.right);\n        q.add(t2.left);\n    }\n    return true;\n}\n```\n\n### 104. Maximum Depth of Binary Tree (Easy) [@](https://leetcode.com/problems/maximum-depth-of-binary-tree/)\n\n> Given a binary tree, find its maximum depth.\n>\n> The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\n>\n> **Note:** A leaf is a node with no children.\n>\n> **Example:**\n>\n> Given binary tree `[3,9,20,null,null,15,7]`,\n>\n> ```\n>  3\n> / \\\n> 9  20\n>  /  \\\n> 15   7\n> ```\n>\n> return its depth = 3.\n\n**Solution 1 Recursion**\n\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) return 0;\n        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n    }\n}\n```\n**Solution 2 Iteration (BFS)**\n\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) return 0;\n        \n        LinkedList<TreeNode> queue = new LinkedList<TreeNode>();\n        int level = 0;\n        queue.add(root);\n        int curNum = 1, nextNum = 0;\n        \n        while (!queue.isEmpty()) {\n            TreeNode node = queue.poll();\n            curNum--;\n            if (node.left != null) {\n                nextNum++;\n                queue.add(node.left);\n            }\n            if (node.right != null) {\n                nextNum++;\n                queue.add(node.right);\n            }\n            if (curNum == 0) {\n                curNum = nextNum;\n                nextNum = 0;\n                level++;\n            }\n        }\n        return level;\n    }\n}\n```\n### 105.  Construct Binary Tree from Preorder and Inorder Traversal (Medium) [@](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)\n\n> Given preorder and inorder traversal of a tree, construct the binary tree.\n>\n> **Note:**\n> You may assume that duplicates do not exist in the tree.\n>\n> For example, given\n>\n> ```\n> preorder = [3,9,20,15,7]\n> inorder = [9,3,15,20,7]\n> ```\n>\n> Return the following binary tree:\n>\n> ```\n>  3\n> / \\\n> 9  20\n>  /  \\\n> 15   7\n> ```\n\n**Solution Divide and Conquer + Recursion** \n\n```java\nclass Solution {\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        TreeNode root = createTree(preorder, 0, preorder.length-1, inorder, 0, inorder.length-1);\n        return root;\n    }\n    private TreeNode createTree(int[] preorder, int startPre, int endPre, int[] inorder, int startIn, int endIn) {\n        if (startPre > endPre || startIn > endIn) return null;\n        TreeNode root = new TreeNode(preorder[startPre]);\n        \n        for (int i = startIn; i <= endIn; i++) {\n            if (inorder[i] == preorder[startPre]) {\n                //i-startIn是左子树长度\n                root.left = createTree(preorder, startPre + 1, startPre + i - startIn, inorder, startIn, i-1);\n                //右子树开始节点是从左子树开始节点加上左子树的长度\n                root.right = createTree(preorder, startPre + 1 + i - startIn, endPre, inorder, i + 1, endIn);\n            }\n        }\n        return root;\n    }\n}\n```\n### 108. Convert Sorted Array to Binary Search Tree (Easy) [@](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/)\n\n> Given an array where elements are sorted in ascending order, convert it to a height balanced BST.\n>\n> For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of *every* node never differ by more than 1.\n>\n> **Example:**\n>\n> ```\n> Given the sorted array: [-10,-3,0,5,9],\n> \n> One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:\n> \n>    0\n>   / \\\n> -3   9\n> /   /\n> -10  5\n> ```\n\n**Solution 1 Recursion**\n\n```java\nclass Solution {\n    public TreeNode sortedArrayToBST(int[] nums) {\n        return dfs(nums, 0, nums.length-1);\n    }\n    private TreeNode dfs(int[] nums, int start, int end) {\n        if (start > end) return null;\n        int mid = (start + end) / 2;\n        TreeNode root = new TreeNode(nums[mid]);\n        root.left = dfs(nums, start, mid - 1);\n        root.right = dfs(nums, mid + 1, end);\n        return root;\n    }\n}\n```\n### 116. Populating Next Right Pointers in Each Node (Medium) [@](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/)\n\n> You are given a **perfect binary tree** where all leaves are on the same level, and every parent has two children.\n>\n> Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to `NULL`.\n>\n> Initially, all next pointers are set to `NULL`.\n>\n> **Follow up:**\n>\n> - You may only use constant extra space.\n> - Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem.\n\n**Solution 1 Recursion**\n\n这道题解法还是挺直白的，如果当前节点有左孩子，那么左孩子的next就指向右孩子。如果当前节点有右孩子，那么判断，如果当前节点的next是null，说明当前节点已经到了最右边，那么右孩子也是最右边的，所以右孩子指向null。如果当前节点的next不是null，那么当前节点的右孩子的next就需要指向当前节点next的左孩子。递归求解就好。\n\n```java\n/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public Node left;\n    public Node right;\n    public Node next;\n\n    public Node() {}\n    \n    public Node(int _val) {\n        val = _val;\n    }\n\n    public Node(int _val, Node _left, Node _right, Node _next) {\n        val = _val;\n        left = _left;\n        right = _right;\n        next = _next;\n    }\n};\n*/\nclass Solution {\n    public Node connect(Node root) {\n        if (root == null) return null;\n        if (root.left != null) {\n            root.left.next = root.right;\n        }\n        if (root.right != null) {\n            if (root.next != null) {\n                root.right.next = root.next.left;\n            }else {\n                root.right.next = null;\n            }\n        }\n        connect(root.left);\n        connect(root.right);\n        return root;\n    }\n}\n```\n\n### 124. Binary Tree Maximum Path Sum (Hard) [@](https://leetcode.com/problems/binary-tree-maximum-path-sum/)\n\n> Given a **non-empty** binary tree, find the maximum path sum.\n>\n> For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain **at least one node** and does not need to go through the root.\n>\n> **Example 1:**\n>\n> ```\n> Input: [1,2,3]\n> \n>     1\n>    / \\\n>   2   3\n> \n> Output: 6\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: [-10,9,20,null,null,15,7]\n> \n> -10\n> / \\\n> 9  20\n>  /  \\\n> 15   7\n> \n> Output: 42\n> ```\n\n- 递归的思想，DFS，从下到上\n- 每个节点可以与其左右节点结合，但每个节点作为子节点返回时，只能选去该节点的值和其较大子节点的值的和返回\nSolution\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    int res = Integer.MIN_VALUE;\n    public int maxPathSum(TreeNode root) {\n        helper(root);\n        return res;\n    }\n    private int helper(TreeNode root) {\n        if (root == null) return 0;\n        int left = Math.max(helper(root.left), 0);\n        int right = Math.max(helper(root.right), 0);\n        res = Math.max(res, left + right + root.val);\n        return Math.max(left, right) + root.val;\n    }\n}\n```\n\n### 130. Surrounded Regions (Medium) [@](https://leetcode.com/problems/surrounded-regions/)\n\n> Given a 2D board containing `'X'` and `'O'` (**the letter O**), capture all regions surrounded by `'X'`.\n>\n> A region is captured by flipping all `'O'`s into `'X'`s in that surrounded region.\n>\n> **Example:**\n>\n> ```\n> X X X X\n> X O O X\n> X X O X\n> X O X X\n> ```\n>\n> After running your function, the board should be:\n>\n> ```\n> X X X X\n> X X X X\n> X X X X\n> X O X X\n> ```\n>\n> **Explanation:**\n>\n> Surrounded regions shouldn’t be on the border, which means that any `'O'` on the border of the board are not flipped to `'X'`. Any `'O'` that is not on the border and it is not connected to an `'O'` on the border will be flipped to `'X'`. Two cells are connected if they are adjacent cells connected horizontally or vertically.\n\n**Solution Recursion**\n\n```java\nclass Solution {\n    public void solve(char[][] board) {\n        if (board == null) return;\n        int rows = board.length;\n        if (rows <= 0) return;\n        int cols = board[0].length;\n        if (cols <= 0) return;\n        // 找到边缘‘O’\n        for (int i = 0; i < rows; i++) {\n            if (board[i][0] == 'O')\n                dfs(board, i, 0);\n            if (board[i][cols-1] == 'O')\n                dfs(board, i, cols-1);\n        }\n        for (int i = 0; i < cols; i++) {\n            if (board[0][i] == 'O')\n                dfs(board, 0, i);\n            if (board[rows-1][i] == 'O')\n                dfs(board, rows-1, i);\n        }\n        \n        for (int i = 0; i < rows; i++){\n            for (int j = 0; j < cols; j++) {\n                if (board[i][j] == '#')\n                    board[i][j] = 'O';\n                else if (board[i][j] == 'O')\n                    board[i][j] = 'X';\n            }\n        }\n    }\n    //每遇到‘O’后，向四个方向递归搜索，所有相邻‘O’变为‘#’\n    private void dfs(char[][] board, int i, int j) {\n        if (board[i][j] == 'O') {\n            board[i][j] = '#';\n\t\t// 跳过四周边缘\n            if (i < board.length - 2)\n                dfs(board, i + 1, j);\n            if (i > 1)\n                dfs(board, i - 1, j);\n            if (j < board[0].length - 2)\n                dfs(board, i, j + 1);\n            if (j > 1) \n                dfs(board, i, j - 1);\n        }\n    }\n}\n```\n\n### 200. Number of Islands (Medium) [@](https://leetcode.com/problems/number-of-islands/)\n\n> Given a 2d grid map of `'1'`s (land) and `'0'`s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n>\n> **Example 1:**\n>\n> ```\n> Input:\n> 11110\n> 11010\n> 11000\n> 00000\n> \n> Output: 1\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input:\n> 11000\n> 11000\n> 00100\n> 00011\n> \n> Output: 3\n> ```\n\n**Solution DFS + Recursion**\n\n- 采用DFS，访问过的‘1’转为‘0’，继续遍历\n```java\nclass Solution {\n    public int numIslands(char[][] grid) {\n        if (grid == null || grid.length == 0 || grid[0].length == 0)\n            return 0;\n        int rows = grid.length;\n        int cols = grid[0].length;\n        int count = 0;\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (grid[i][j] == '1'){\n                    count++;\n                    dfs(grid, i, j);    \n                }\n            }\n        }\n        return count;\n    }\n    private void dfs(char[][] grid, int i, int j) {\n        if (i < 0 || i > grid.length-1 || j < 0 || j > grid[0].length-1)\n            return;\n        if (grid[i][j] == '0') {\n            return;\n        }else if (grid[i][j] == '1') {\n            grid[i][j] = '0';\n            dfs(grid, i-1, j);\n            dfs(grid, i+1, j);\n            dfs(grid, i, j-1);\n            dfs(grid, i, j+1);\n        }\n    }\n}\n```\n\n### 207. Course Schedule (Medium) [@](https://leetcode.com/problems/course-schedule/)\n\n> There are a total of *n* courses you have to take, labeled from `0` to `n-1`.\n>\n> Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: `[0,1]`\n>\n> Given the total number of courses and a list of prerequisite **pairs**, is it possible for you to finish all courses?\n>\n> **Example 1:**\n>\n> ```\n> Input: 2, [[1,0]] \n> Output: true\n> Explanation: There are a total of 2 courses to take. \n>           To take course 1 you should have finished course 0. So it is possible.\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: 2, [[1,0],[0,1]]\n> Output: false\n> Explanation: There are a total of 2 courses to take. \n>           To take course 1 you should have finished course 0, and to take course 0 you should\n>           also have finished course 1. So it is impossible.\n> ```\n>\n> **Note:**\n>\n> 1. The input prerequisites is a graph represented by **a list of edges**, not adjacency matrices. Read more about [how a graph is represented](https://www.khanacademy.org/computing/computer-science/algorithms/graph-representation/a/representing-graphs).\n> 2. You may assume that there are no duplicate edges in the input prerequisites.\n\n**Solution Topology**\n\n- 此问题等价于图中是否有无环的存在（拓扑排序解决问题）\n```java\nclass Solution {\n    public boolean canFinish(int numCourses, int[][] prerequisites) {\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        int[] indegree = new int[numCourses]; \n        //初始化图，利用hashmap\n        for (int i = 0; i < prerequisites.length; i++) {\n            int s_node = prerequisites[i][0];\n            int e_node = prerequisites[i][1];\n            if (!map.containsKey(s_node))\n                map.put(s_node, new ArrayList<>());\n            map.get(s_node).add(e_node);\n            indegree[e_node]++;//更新每个点的入度\n        }\n        //储存所有入度为0的节点->拓扑排序起始点\n        Queue<Integer> q = new LinkedList<>();\n        for (int i = 0; i < numCourses; i++) {\n            if (indegree[i] == 0)\n                q.offer(i);\n        }\n        //计算可拓扑排序的节点个数\n        int count = 0;\n        while (!q.isEmpty()) {\n            int val = q.poll();\n            count++;\n            \n            if (map.containsKey(val)) {\n                List<Integer> tmp = map.get(val);\n                for (int i = 0; i < tmp.size(); i++) {\n                    int idx = tmp.get(i);\n                    indegree[idx]--;\n                    if (indegree[idx] == 0)\n                        q.offer(idx);\n                }\n            }\n        }\n        return count == numCourses;\n    }\n}\n```\n\n### 210. Course Schedule II (Medium) [@](https://leetcode.com/problems/course-schedule-ii/)\n\n> There are a total of *n* courses you have to take, labeled from `0` to `n-1`.\n>\n> Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: `[0,1]`\n>\n> Given the total number of courses and a list of prerequisite **pairs**, return the ordering of courses you should take to finish all courses.\n>\n> There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.\n>\n> **Example 1:**\n>\n> ```\n> Input: 2, [[1,0]] \n> Output: [0,1]\n> Explanation: There are a total of 2 courses to take. To take course 1 you should have finished   \n>           course 0. So the correct course order is [0,1] .\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: 4, [[1,0],[2,0],[3,1],[3,2]]\n> Output: [0,1,2,3] or [0,2,1,3]\n> Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both     \n>           courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. \n>           So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3] .\n> ```\n>\n> **Note:**\n>\n> 1. The input prerequisites is a graph represented by **a list of edges**, not adjacency matrices. Read more about [how a graph is represented](https://www.khanacademy.org/computing/computer-science/algorithms/graph-representation/a/representing-graphs).\n> 2. You may assume that there are no duplicate edges in the input prerequisites.\n\n**Solution Topology**\n\n```java\nclass Solution {\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        int[] indegree = new int[numCourses]; \n        int[] res = new int[numCourses];\n        //初始化图，利用hashmap\n        for (int i = 0; i < prerequisites.length; i++) {\n            int s_node = prerequisites[i][0];\n            int e_node = prerequisites[i][1];\n            if (!map.containsKey(s_node))\n                map.put(s_node, new ArrayList<>());\n            map.get(s_node).add(e_node);\n            indegree[e_node]++;//更新每个点的入度\n        }\n        //储存所有入度为0的节点->拓扑排序起始点\n        int index = numCourses - 1;\n        Queue<Integer> q = new LinkedList<>();\n        for (int i = 0; i < numCourses; i++) {\n            if (indegree[i] == 0) {\n                q.offer(i);\n                res[index--] = i;\n            }\n        }\n        //拓扑排序\n        while (!q.isEmpty()) {\n            int val = q.poll();\n            //获取val指向的节点\n            if (map.containsKey(val)) {\n                List<Integer> tmp = map.get(val);\n                for (int i = 0; i < tmp.size(); i++) {\n                    int idx = tmp.get(i);\n                    indegree[idx]--;\n                    if (indegree[idx] == 0) {\n                        q.offer(idx);\n                        res[index--] = idx;\n                    }\n                }\n            }\n        }\n        if (index != -1)\n            return new int[0];\n        else\n            return res;\n    }\n}\n```\n## BFS\n\n### 102. Binary Tree Level Order Traversal (Medium) [@](https://leetcode.com/problems/binary-tree-level-order-traversal/)\n\n> Given a binary tree, return the *level order* traversal of its nodes' values. (ie, from left to right, level by level).\n>\n> For example:\n> Given binary tree `[3,9,20,null,null,15,7]`,\n>\n> ```\n>  3\n> / \\\n> 9  20\n>  /  \\\n> 15   7\n> ```\n>\n> \n>\n> return its level order traversal as:\n>\n> ```\n> [\n> [3],\n> [9,20],\n> [15,7]\n> ]\n> ```\n\n**Solution 1 Recursion**\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\n        helper(root, res, 0);\n        return res;\n    }\n    private void helper(TreeNode root, List<List<Integer>> res, int level) {\n        if (root == null) return;\n        if (res.size() < level+1) {\n            res.add(new ArrayList<Integer> ());\n        }\n        res.get(level).add(root.val);\n        \n        helper(root.left, res, level+1);\n        helper(root.right, res, level+1);\n    }\n}\n```\n**Solution 2 Iteration (Queue)**\n\n```java\nclass Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\n        if (root == null) return res;\n        \n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\n        queue.offer(root);\n        int level = 0;\n        while (!queue.isEmpty()) {\n            //start current level\n            res.add(new ArrayList<Integer>());\n            //num of elements in current level\n            int len = queue.size();\n            \n            for (int i = 0; i < len; i++) {\n                TreeNode node = queue.poll();\n                //get the val in each level\n                res.get(level).add(node.val);\n                //add child nodes to queue\n                if (node.left != null) queue.offer(node.left);\n                if (node.right != null) queue.offer(node.right);\n            }\n            //go to next level\n            level++;\n        }\n        return res;\n    }\n}\n```\n\n### 103. Binary Tree Zigzag Level Order Traversal (Medium) [@](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/)\n\n> Given a binary tree, return the *zigzag level order* traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).\n>\n> For example:\n> Given binary tree `[3,9,20,null,null,15,7]`,\n>\n> ```\n>  3\n> / \\\n> 9  20\n>  /  \\\n> 15   7\n> ```\n>\n> \n>\n> return its zigzag level order traversal as:\n>\n> ```\n> [\n> [3],\n> [20,9],\n> [15,7]\n> ]\n> ```\n\n**Solution Recursion**\n\n- based on 102, add a flag to identify reverse\n```java\nclass Solution {\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\n        helper(root, res, 0, false);\n        return res;\n    }\n    private void helper(TreeNode root, List<List<Integer>> res, int level, boolean flag) {\n        if (root == null) return;\n        if (res.size() < level+1) {\n            res.add(new LinkedList<Integer> ());\n        }\n        if (flag) {\n            //convert to LinkedList\n            ((LinkedList<Integer>)res.get(level)).addFirst(root.val);\n        }else {\n            res.get(level).add(root.val);\n        }\n        \n        helper(root.left, res, level+1, !flag);\n        helper(root.right, res, level+1, !flag);\n    }\n}\n```\n\n### 127. Word Ladder (Medium) [@](https://leetcode.com/problems/word-ladder/)\n\n> Given two words (*beginWord* and *endWord*), and a dictionary's word list, find the length of shortest transformation sequence from *beginWord* to *endWord*, such that:\n>\n> 1. Only one letter can be changed at a time.\n> 2. Each transformed word must exist in the word list. Note that *beginWord* is *not* a transformed word.\n>\n> **Note:**\n>\n> - Return 0 if there is no such transformation sequence.\n> - All words have the same length.\n> - All words contain only lowercase alphabetic characters.\n> - You may assume no duplicates in the word list.\n> - You may assume *beginWord* and *endWord* are non-empty and are not the same.\n>\n> **Example 1:**\n>\n> ```\n> Input:\n> beginWord = \"hit\",\n> endWord = \"cog\",\n> wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n> \n> Output: 5\n> \n> Explanation: As one shortest transformation is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\",\n> return its length 5.\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input:\n> beginWord = \"hit\"\n> endWord = \"cog\"\n> wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\n> \n> Output: 0\n> \n> Explanation: The endWord \"cog\" is not in wordList, therefore no \n> ```\n\n**Solution 1 BFS (Time Limit Exceeded)**\n\n```java\nclass Solution {\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        Queue<String> queue = new LinkedList<String>();\n        queue.offer(beginWord);\n        HashMap<String, Integer> maps = new HashMap<String, Integer>(); //store the level of each string\n        maps.put(beginWord, 1);\n        if (wordList.contains(beginWord)) wordList.remove(beginWord);\n        \n        while (!queue.isEmpty()) {\n            String top = queue.poll();\n            int len = top.length();\n            StringBuilder builder;\n            \n            int level = maps.get(top);\n            for (int i = 0; i < len; i++) {\n                //find the strings which is one char diff with top\n                builder = new StringBuilder(top);\n                for (char c = 'a'; c <= 'z'; c++) {\n                    builder.setCharAt(i, c);\n                    String tmpStr = builder.toString();\n                    if (tmpStr.equals(top))//match top\n                        continue;\n                    //add to next level\n                    if (wordList.contains(tmpStr)) {\n                        if (tmpStr.equals(endWord))//match endWord->return \n                            return level+1;\n                        queue.offer(tmpStr);\n                        wordList.remove(tmpStr);\n                        maps.put(tmpStr, level+1);\n                    }\n                }\n            }\n        }\n        return 0;\n    }\n}\n```\n\nSolution 2 Bidirectional Breadth First Search\n```java\nclass Solution {\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if(!wordList.contains(endWord)) return 0;\n        //top->down\n        Queue<String> queue1 = new LinkedList<>();\n        queue1.add(beginWord);\n        //down->top\n        Queue<String> queue2 = new LinkedList<>();\n        queue2.add(endWord);\n        \n        Set<String> visited = new HashSet<>();\n        visited.add(endWord);\n        \n        int step = 1;\n        while(queue1.size() > 0 && queue2.size() > 0) {\n            // always start from smaller number of queue \n            if(queue1.size() > queue2.size()) {\n                Queue<String> temp = queue1;\n                queue1 = queue2;\n                queue2 = temp;\n            }\n            \n            Queue<String> nextQueue = new LinkedList<>();\n            while(!queue1.isEmpty()) {\n                String cur = queue1.poll();\n                for(String word: wordList) {\n                    if(valid(cur, word)) {\n                        if(queue2.contains(word)) {\n                            return step+1;\n                        }\n                        \n                        if(!visited.contains(word)) {\n                            nextQueue.add(word);\n                            visited.add(word);                            \n                        }\n                    }\n                }\n            }\n            queue1 = nextQueue;\n            step++;\n        }\n        return 0;\n    }\n    //whether step==1\n    boolean valid(String a, String b) {\n        int diff = 0;\n        for(int i = 0; i < a.length(); ++i) {\n            if(a.charAt(i) != b.charAt(i)) {\n                diff++;\n                if(diff >= 2) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\n```\n\n## DP (DP<-->DFS + memo)\n\n### 53.Maximum Subarray (Easy) [@](https://leetcode.com/problems/maximum-subarray/)\n\n> Given an integer array `nums`, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n>\n> **Example:**\n>\n> ```\n> Input: [-2,1,-3,4,-1,2,1,-5,4],\n> Output: 6\n> Explanation: [4,-1,2,1] has the largest sum = 6.\n> ```\n>\n> **Follow up:**\n>\n> If you have figured out the O(*n*) solution, try coding another solution using the divide and conquer approach, which is more subtle.\n\n**Solution 1**\n\n- 遍历所有子序列O(n^3) -> 住需要遍历从起始位置开始的子序列 O(n^2) ->\n- 起始位置为负时，显然不是最大子序列和起始点。所以从负数部位最大子序列和的起点出发 O(n)\n```java\nclass Solution {\n    public int maxSubArray(int[] nums) {\n        int nSize = nums.length;\n        if (nSize == 0) return 0;\n        int maxSum = Integer.MIN_VALUE;\n        int nSum = 0;\n        for (int i = 0; i < nSize; i++) {\n            nSum += nums[i];\n            if (nSum > maxSum)\n                maxSum = nSum;\n            if (nSum < 0)\n                nSum = 0;\n        }\n        return maxSum;\n    }\n}\n```\n\n### 62. Unique Paths (Medium) [@](https://leetcode.com/problems/unique-paths/)\n\n> A robot is located at the top-left corner of a *m* x *n* grid (marked 'Start' in the diagram below).\n>\n> The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).\n>\n> How many possible unique paths are there?\n>\n> **Note:** *m* and *n* will be at most 100.\n>\n> **Example 1:**\n>\n> ```\n> Input: m = 3, n = 2\n> Output: 3\n> Explanation:\n> From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\n> 1. Right -> Right -> Down\n> 2. Right -> Down -> Right\n> 3. Down -> Right -> Right\n> ```\n\n**Solution 1** \n\n- dp[i] [j] = dp[i-1] [j] + dp[i] [j-1]\n- O(m*n)\n```java\nclass Solution {\n    public int uniquePaths(int m, int n) {\n        //dp[i][j] = dp[i-1][j] + dp[i][j-1];\n        int[][] dp = new int[m][n];\n        dp[0][0] = 1;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i > 0)\n                    dp[i][j] += dp[i-1][j];\n                if (j > 0)\n                    dp[i][j] += dp[i][j-1];\n            }\n        }\n        return dp[m-1][n-1];\n    }\n}\n```\n\n**Solution 2**\n\n- 空间复杂度 O(m*n) -> O(n)\n- dp[j]: (0,0) -> (i,j)\n- dp[j-1]表示dp[j]上方的值\n- dp[j] = dp[j] + dp[j-1]\n- 一列一列更新，只保存一列的数据\n```java\nclass Solution {\n    public int uniquePaths(int m, int n) {\n        //dp[j]: num of paths from (0,0) to (i-1,j)\n        int[] dp = new int[n];\n        dp[0] = 1;\n        for (int i = 0; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                dp[j] += dp[j-1];\n            }\n        }\n        return dp[n-1];\n    }\n}\n```\n\n### 70. Climbing Stairs (Easy) [@](https://leetcode.com/problems/climbing-stairs/)\n\n> You are climbing a stair case. It takes *n* steps to reach to the top.\n>\n> Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n>\n> **Note:** Given *n* will be a positive integer.\n>\n> **Example 1:**\n>\n> ```\n> Input: 2\n> Output: 2\n> Explanation: There are two ways to climb to the top.\n> 1. 1 step + 1 step\n> 2. 2 steps\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: 3\n> Output: 3\n> Explanation: There are three ways to climb to the top.\n> 1. 1 step + 1 step + 1 step\n> 2. 1 step + 2 steps\n> 3. 2 steps + 1 step\n> ```\n\nSolution 1 DP\n- 假设梯子有n层，那么如何爬到第n层呢，因为每次只能怕1或2步，那么爬到第n层的方法要么是从第n-1层一步上来的，要不就是从n-2层2步上来的，所以递推公式非常容易的就得出了\n```java\nclass Solution {\n    public int climbStairs(int n) {\n        //dp[i] = dp[i-1] + dp[i-2];\n        if (n == 1) return 1;\n        int[] dp = new int[n+1];\n        dp[1] = 1;\n        dp[2] = 2;\n        for (int i = 3; i <= n; i++) {\n            dp[i] = dp[i - 1] + dp[i - 2];\n        }\n        return dp[n];\n    }\n}\n```\nSolution 2 Fibonacci Number\n```java\nclass Solution {\n    public int climbStairs(int n) {\n        if (n == 1) return 1;\n        int first = 1;\n        int second = 2;\n        for (int i = 3; i <= n; i++) {\n            int third = first + second;\n            first = second;\n            second = third;\n        }\n        return second;\n    }\n}\n```\n\n### 91. Decode Ways (Medium) [@](https://leetcode.com/problems/decode-ways/)\n\n> A message containing letters from `A-Z` is being encoded to numbers using the following mapping:\n>\n> ```\n> 'A' -> 1\n> 'B' -> 2\n> ...\n> 'Z' -> 26\n> ```\n>\n> Given a **non-empty** string containing only digits, determine the total number of ways to decode it.\n>\n> **Example 1:**\n>\n> ```\n> Input: \"12\"\n> Output: 2\n> Explanation: It could be decoded as \"AB\" (1 2) or \"L\" (12).\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: \"226\"\n> Output: 3\n> Explanation: It could be decoded as \"BZ\" (2 26), \"VF\" (22 6), or \"BBF\" (2 2 6).\n> ```\n\n**Solution**\n\n- 设定状态为：`dp[i]`表示`s`从`0`开始，长度为`i`的子串的解码方式数量，于是我们最终要求的答案便是`dp[n]`。\n\n  那么如何求解`dp[i]`呢？这个很简单，枚举最后一个字母对应1位还是2位，将f转化为规模更小的子问题。\n\n  - 设`dp[i] = 0`\n  - 枚举最后一个字母对应1位（要求`s[i - 1] != '0'`)，那么有`dp[i] += dp[i-1]`；\n  - 枚举最后一个字母对应2位（要求`i > 1`且`s[i - 2]`和`s[i - 1]`组成的字符串在`\"10\"~\"26\"`的范围内），那么有`dp[i] += dp[i - 2]`；\n\n- 也就是说，我们可以通过dp[i - 1]和dp[i - 2]计算出dp[i]来，这就是我们的状态和转移方程。\n\n- 在具体实现中，我们可以按照i从1到n的顺序，依次计算出所有的dp[i]。\n```java\nclass Solution {\n    public int numDecodings(String s) {\n        if (s.length() == 0) return 0;\n        int[] dp = new int[s.length()+1];\n        dp[0] = 1;\n        //dp[i] 表示s从0开始，长度为i的字串的解码方式数量\n        for (int i = 1; i < s.length()+1; i++) {\n            if (s.charAt(i-1) != '0') \n                dp[i] += dp[i-1];\n            if (i >= 2 && (s.substring(i-2, i).compareTo(\"10\") >= 0 && s.substring(i-2, i).compareTo(\"26\") <= 0))\n                dp[i] += dp[i - 2];\n        }\n        return dp[s.length()];\n    }\n}\n```\n\n### 121. Best Time to Buy and Sell Stock (Easy) [@](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)\n\n>  \n\n**Solution**\n\n如果是动态规划的思路， 基本上我们要定义状态dp[i]， 然后看dp[i]和dp[i-1]或者dp[i-k]之间的关系。\n假设我们定义dp[i]是在i天的最大利润， 那么和前面的重叠子问题的关系是什么呢？\n\n- 一种情况当然是前面子问题里面的最大利润已经是整体的最大利润， 那么dp[i]=dp[i-1]\n  还有一种情况是， 前面虽然取得了利润， 但是第i天卖出（对应到前面某一天买入)会产生更大的利润\n  这时候，dp[i] = prices[i] - prices[j]\n  也就是说, 整个递推公式是: dp[i] = Math.max(dp[i-1], prices[i]-prices[j]), 其中, j<i\n  这样， 对于每个dp[i], 都只和之前的状态和数据有关， 和后面的选择已经无关了。\n  然后这时候要考虑， prices[j]是哪个值会产生最大利润？ 当然是目前为止的最小值。\n  也就是说， dp[j] = min prices so far， 而且这个值的好处是， 在一次遍历的过程中，可以直接随着遍历更新这个值。那么， 可以保存一个min值， 这样整体一次遍历就可以了。\n- 有一个错误的思路， 就是一次遍历求出最小价格和最大价格， 然后得出利润。\n  这个解法的错误的地方在于， 最大价格可能是最小价格的前面， 不能直接使用。\n  反例比如[3,1,2]\n- 前面的错误在于把顺序不符合要求的情况包括进去了，\n  当然， 这个过程可以更简化。 甚至可以不需要用这么复杂的动态规划的思路, 直接对问题进行分析。\n  对于最大利润的买入和卖出位置， 虽然买入和卖出可能出现在任意位置， 但是我们考虑如果固定其中一个价格会怎么样？\n  实际上， 如果买入的位置已经选中， 那么卖出的位置也确定了。 反过来也成立， 如果卖出的位置已经选择， 那么买入的位置也确定了。\n\n这里假设卖出的位置是i, 那么， 买入的位置就是在i前面的价格里面的最小价格。\n那么，如果我们从左向右遍历， 每次保存目前已经遇到过的最小价格， 那么，prices[i]-min就是在i这个位置卖出的最大利润，这样就可以在一次遍历的过程中求解整体的最大利润。\n\n```\nclass Solution {\n    public int maxProfit(int[] prices) {\n        if (prices.length == 0) return 0;\n        int[] dp = new int[prices.length];\n        int min = prices[0];\n        \n        for (int i = 1; i < prices.length; i++) {\n            min = Math.min(prices[i], min);\n            dp[i] = Math.max(dp[i-1], prices[i] - min);\n        }\n        return dp[prices.length - 1];\n    }\n}\n```\n- 可将dp[]换为max，降低空间复杂度\n\n### 139. Word Break (Medium) [@](https://leetcode.com/problems/word-break/)\n\nSolution 1\n\n1. 一个直观的思路是暴力解，首先从头开始，看看每个单词能不能成为成为字符串的开头， 如果匹配上了， 可以对后面的继续这个过程\n2. 但是这个过程有一点重复， 其实每次计算都是计算的时候，问题是判断某一个子字符串是不是满足要求， 而某一个子字符串，在这个问题里面其实就是原始字符串的index， 那么， 这个子问题可能是重叠的。\n   比如， 针对\"abcdef\"和[“ab”, “cd”, “abcd”]\n   那么， 针对index=4 （从1开始计数， 可以有ab+cd 或者abcd两种方式， 那么，一个计算过了，后面的就不需要再计算了。\n3. 这样，就可以应用动态规划的思想， 设置dp[i]表示在i位已经满足要求的， 然后从前向后遍历，看看每一位是否可以走到更多的位；\n4. 动态规划的常用套路，就是看prefix， 因为计算prefix的时候，问题已经求解过了，固定了； 当然要从postfix去理解也可以， 但是那样通常会是解问题的自然思路，但是从动态规划bottom up的方式，往往不是那么好理解。\n   而当然，如果用记忆化递归的方式去理解，也是可以的。 但是同样要抽象出需要记忆的状态。 对于每个substring， 其实也是要用index来定义状态。 当然，完全用string做key也可能可以， 但是那样会浪费很多空间。\n\n```java\nclass Solution {\n    public boolean wordBreak(String s, List<String> wordDict) {\n        Set<String> wordSet = new HashSet<>(wordDict);\n        boolean[] dp = new boolean[s.length() + 1];\n        dp[0] = true;\n        //i--开始位置\n        for (int i = 0; i < s.length(); i++) {\n            if (!dp[i]) continue;\n            //j--结束位置\n            for (int j = i+1; j <= s.length(); j++) {\n                String subStr = s.substring(i, j);\n                if (wordSet.contains(subStr)) {\n                    dp[j] = true;\n                }\n            }\n        }\n        return dp[s.length()];\n    }\n}\n```\n\n### 140. Word Break II (Hard) [@](https://leetcode.com/problems/word-break-ii/)\n> Given a **non-empty** string *s* and a dictionary *wordDict* containing a list of **non-empty** words, add spaces in *s* to construct a sentence where each word is a valid dictionary word. Return all such possible sentences.\n>\n> **Note:**\n>\n> - The same word in the dictionary may be reused multiple times in the segmentation.\n> - You may assume the dictionary does not contain duplicate words.\n>\n> **Example 1:**\n>\n> ```\n> Input:\n> s = \"catsanddog\"\n> wordDict = [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"]\n> Output:\n> [\n>   \"cats and dog\",\n>   \"cat sand dog\"\n> ]\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input:\n> s = \"pineapplepenapple\"\n> wordDict = [\"apple\", \"pen\", \"applepen\", \"pine\", \"pineapple\"]\n> Output:\n> [\n>   \"pine apple pen apple\",\n>   \"pineapple pen apple\",\n>   \"pine applepen apple\"\n> ]\n> Explanation: Note that you are allowed to reuse a dictionary word.\n> ```\n>\n> **Example 3:**\n>\n> ```\n> Input:\n> s = \"catsandog\"\n> wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]\n> Output:\n> []\n> ```\n\nSolution Recursion\n\n- Python\n- 递归调用wordBerak()\n- [Youtube 题解](https://www.youtube.com/watch?v=JqOIRBC0_9c)\n- ![leetcode_140.png](:/ce516b8d2d2e441d9d46426147b9d38c)\n\n```python\nclass Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\n        words = set(wordDict)\n        memo = {}\n        def wordBreak(s):\n            # already in memory, return directly\n            if s in memo: \n                return memo[s]\n            # answer for s\n            ans = []\n            if s in words:\n                ans.append(s)\n            for i in range(1, len(s)):\n                # check whether right part is a word\n                right = s[i:]\n                if right not in words:\n                    continue\n                # append to the answer for left part\n                ans += [w + \" \" + right for w in wordBreak(s[0:i])]\n            memo[s] = ans\n            return memo[s]\n        return wordBreak(s)\n```\n\n### 152. Maximum Product Subarray (Medium) [@](https://leetcode.com/problems/maximum-product-subarray/)\n\n> Given an integer array `nums`, find the contiguous subarray within an array (containing at least one number) which has the largest product.\n>\n> **Example 1:**\n>\n> ```\n> Input: [2,3,-2,4]\n> Output: 6\n> Explanation: [2,3] has the largest product 6.\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: [-2,0,-1]\n> Output: 0\n> Explanation: The result cannot be 2, because [-2,-1] is not a subarray.\n> ```\n\nSolution DP\n\n- 同时记录最大积和最小积，dp[i][0]表示以nums[i]结尾的子序列的最小积，dp[i][1]表示以nums[i]结尾的子序列的最大积。初始状态：\n  dp[0] [0] = nums[0];\n  dp[0] [1] = nums[0];\n- 由于可能存在负数，所以有三个数参与判断，状态转移方程：\n  dp[i] [0] = min( min(dp[i - 1] [0] * nums[i], dp[i - 1] [1] * nums[i]), nums[i])\n  dp[i] [1] = max( max(dp[i - 1] [0] * nums[i], dp[i - 1] [1] * nums[i]), nums[i])\n- 可以在用一个变量result记录结果，每次计算出最大积时就更新一下result，最后返回result就行，见下面我的代码1，时间复杂度是O(n)O(n)，空间复杂度是O(n)O(n)\n- 通过状态转移方程可以看出计算dp[i] []时只需要用到dp[i - 1] []，与dp[i - 2] []及前面的结果没有关系，因此空间复杂度可以进一步优化，只用两个变量localMin和localMax存储前一个位置的最大积和最小积\n\n```java\nclass Solution {\n    public int maxProduct(int[] nums) {\n        if (nums == null || nums.length == 0) return 0;\n        int localMin = nums[0];\n        int localMax = nums[0];\n        int globalMax = nums[0];\n        for (int i = 1; i < nums.length; i++) {\n            int tmp = localMin;\n            localMin = Math.min(Math.min(tmp * nums[i], localMax * nums[i]), nums[i]);\n            localMax = Math.max(Math.max(localMax * nums[i], tmp * nums[i]), nums[i]);\n            globalMax = Math.max(localMax, globalMax);\n        }\n        return globalMax;\n    }\n}\n```\n\n### 198.House Robber (Easy) [@](https://leetcode.com/problems/house-robber/)\n\n> You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\n>\n> Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight **without alerting the police**.\n>\n> **Example 1:**\n>\n> ```\n> Input: [1,2,3,1]\n> Output: 4\n> Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\n>           Total amount you can rob = 1 + 3 = 4.\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: [2,7,9,3,1]\n> Output: 12\n> Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\n>           Total amount you can rob = 2 + 9 + 1 = 12.\n> ```\n\nSolution 1 DP\n\n- 递推公式\n\n~~~\ndp[0] = num[0] （当i=0时）\ndp[1] = max(num[0], num[1]) （当i=1时）\ndp[i] = max(num[i] + dp[i - 2], dp[i - 1])   （当i !=0 and i != 1时）\n~~~\n\n```java\nclass Solution {\n    public int rob(int[] nums) {\n        if (nums == null || nums.length == 0) \n            return 0;\n        int[] dp = new int[nums.length+1];\n        for (int i = 0; i < nums.length; i++) {\n            if (i == 0)\n                dp[i] = nums[i];\n            else if (i == 1)\n                dp[i] = Math.max(nums[i], nums[i-1]);\n            else\n                dp[i] = Math.max(dp[i-2]+nums[i], dp[i-1]);\n        }\n        return dp[nums.length-1];\n    }\n}\n```\nSolution 2\n\n- 优化空间复杂度 O(1)\n\n```java\n    public int rob(int[] nums) {\n        int rob = 0, notrob = 0;\n        for (int i = 0; i < nums.length; i++) {\n            int temp = rob;\n            rob = notrob + nums[i];\n            notrob = Math.max(temp, notrob);\n        }\n        return Math.max(rob, notrob);\n    }\n```\n\n## Binary Search\n\n### 69. Sqrt(x) (Easy) [@](https://leetcode.com/problems/sqrtx/)\n\n> Implement `int sqrt(int x)`.\n>\n> Compute and return the square root of *x*, where *x* is guaranteed to be a non-negative integer.\n>\n> Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.\n>\n> **Example 1:**\n>\n> ```\n> Input: 4\n> Output: 2\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: 8\n> Output: 2\n> Explanation: The square root of 8 is 2.82842..., and since \n>           the decimal part is truncated, 2 is returned.\n> ```\n\n```\nclass Solution {\n    public int mySqrt(int x) {\n        if (x < 2) return x;\n        int left = 0;\n        int right = x/2+1;\n        long mid = 0;\n        while (left <= right) {\n            mid = (left + right) / 2;\n            if (mid * mid == x) {\n                return (int)mid;\n            }else if (mid * mid > x) {\n                right = (int)mid -1;\n            }else {\n                left = (int)mid + 1;\n            }\n        }\n        return right;\n    }\n}\n```\n### 162. Find Peak Element (Medium) [@](https://leetcode.com/problems/find-peak-element/)\n\n> A peak element is an element that is greater than its neighbors.\n>\n> Given an input array `nums`, where `nums[i] ≠ nums[i+1]`, find a peak element and return its index.\n>\n> The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.\n>\n> You may imagine that `nums[-1] = nums[n] = -∞`.\n>\n> **Example 1:**\n>\n> ```\n> Input: nums = [1,2,3,1]\n> Output: 2\n> Explanation: 3 is a peak element and your function should return the index number 2.\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: nums = [1,2,1,3,5,6,4]\n> Output: 1 or 5 \n> Explanation: Your function can return either index number 1 where the peak element is 2, \n>           or index number 5 where the peak element is 6.\n> ```\n\nSolution\n- 因为nums[-1] = nums[n] = -∞, 所以当nums[mid] < nums[mid+1] 时，mid右侧必定有peak，同理点那个nums[mid] >= nums[mid+1]时，mid及其左侧必有peak\n```\nclass Solution {\n    public int findPeakElement(int[] nums) {\n        int n = nums.length;\n        int left = 0, right = n-1;\n        while (left < right) {\n            int mid = (left + right) / 2;\n            if (nums[mid] < nums[mid+1]) {\n                //mid右侧必定有peak\n                left = mid + 1;\n            }else {\n                //包括mid在内左侧必有peak\n                right = mid;\n            }\n        }\n        return left;\n    }\n}\n```\n\n## Greedy\n\n### 55. Jump Game (Medium) [@](https://leetcode.com/problems/jump-game/)\n\n> Given an array of non-negative integers, you are initially positioned at the first index of the array.\n>\n> Each element in the array represents your maximum jump length at that position.\n>\n> Determine if you are able to reach the last index.\n>\n> **Example 1:**\n>\n> ```\n> Input: [2,3,1,1,4]\n> Output: true\n> Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: [3,2,1,0,4]\n> Output: false\n> Explanation: You will always arrive at index 3 no matter what. Its maximum\n>           jump length is 0, which makes it impossible to reach the last index.\n> ```\n\nSolution 1 Greedy\n- 维护一个reach（最远可达距离），每次前进一步，如果i一直在reach范围内，则可达\n```\nclass Solution {\n    public boolean canJump(int[] nums) {\n        int reach = 0;\n        for (int i = 0; i < nums.length; i++) {\n            if (i > reach)\n                return false;\n            reach = Math.max(reach, i + nums[i]);\n        }\n        return true;\n    }\n}\n```\n\nSolution 2 Zero Point\n- 若无0点则一定可达任一点\n- 故只需考虑0点，判断可否跳过此0点即此0点向前数第k个位置的元素大于k即可跳过\n```\nclass Solution {\n    public boolean canJump(int[] nums) {\n        int i = nums.length - 2; //0点\n        while(i >= 0) {\n            if (nums[i] == 0) {\n                int j = i - 1;//向前找可以跳过0点的位置\n                while (j >= 0) {\n                    if (j + nums[j] > i) {\n                        break;\n                    }\n                    j--;\n                }\n                if (j == -1)\n                    return false;\n            }\n            i--;\n        }\n        return true;\n    }\n}\n```\n\n### 122. Best Time to Buy and Sell Stock II (Easy) [@](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/)\n> Say you have an array for which the *i*th element is the price of a given stock on day *i*.\n>\n> Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).\n>\n> **Note:** You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).\n>\n> **Example 1:**\n>\n> ```\n> Input: [7,1,5,3,6,4]\n> Output: 7\n> Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\n>           Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: [1,2,3,4,5]\n> Output: 4\n> Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\n>           Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are\n>           engaging multiple transactions at the same time. You must sell before buying again.\n> ```\n>\n> **Example 3:**\n>\n> ```\n> Input: [7,6,4,3,1]\n> Output: 0\n> Explanation: In this case, no transaction is done, i.e. max profit = 0.\n> ```\n\nSolution Greedy\n\n- 累计所有前低后高的差值\n```\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int profit = 0;\n        for (int i = 1; i < prices.length; i++) {\n            if (prices[i] - prices[i-1] > 0)\n                profit += prices[i] - prices[i-1];\n        }\n        return profit;\n    }\n}\n```\n\n### 134. Gas Station (Medium) [@](https://leetcode.com/problems/gas-station/)\n\n> There are *N* gas stations along a circular route, where the amount of gas at station *i* is `gas[i]`.\n>\n> You have a car with an unlimited gas tank and it costs `cost[i]` of gas to travel from station *i* to its next station (*i*+1). You begin the journey with an empty tank at one of the gas stations.\n>\n> Return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1.\n>\n> **Note:**\n>\n> - If there exists a solution, it is guaranteed to be unique.\n> - Both input arrays are non-empty and have the same length.\n> - Each element in the input arrays is a non-negative integer.\n>\n> **Example 1:**\n>\n> ```\n> Input: \n> gas  = [1,2,3,4,5]\n> cost = [3,4,5,1,2]\n> \n> Output: 3\n> \n> Explanation:\n> Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\n> Travel to station 4. Your tank = 4 - 1 + 5 = 8\n> Travel to station 0. Your tank = 8 - 2 + 1 = 7\n> Travel to station 1. Your tank = 7 - 3 + 2 = 6\n> Travel to station 2. Your tank = 6 - 4 + 3 = 5\n> Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.\n> Therefore, return 3 as the starting index.\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: \n> gas  = [2,3,4]\n> cost = [3,4,3]\n> \n> Output: -1\n> \n> Explanation:\n> You can't start at station 0 or 1, as there is not enough gas to travel to the next station.\n> Let's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\n> Travel to station 0. Your tank = 4 - 3 + 2 = 3\n> Travel to station 1. Your tank = 3 - 3 + 3 = 3\n> You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.\n> Therefore, you can't travel around the circuit once no matter where you start.\n> ```\n\nSolution Greedy\n- sum(gas) >= sum(cost) => 有解\n- 只要找到一个起点i，从这个点出发的所有gas的和总比cost和打即可\n```\nclass Solution {\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n        int sum = 0, subsum = 0, begin = 0;\n        for (int i = 0; i < gas.length; i++) {\n            sum += gas[i] - cost[i];\n            subsum += gas[i] - cost[i];\n            if (subsum < 0) {\n                subsum = 0;\n                begin = i + 1;\n            }\n        }\n        if (sum < 0) return -1;\n        return begin;\n    }\n}\n```\n## Tree\n\n### 94. Binary Tree Inorder Traversal (Medium)  [@](https://leetcode.com/problems/binary-tree-inorder-traversal/)\n\n> Given a binary tree, return the *inorder* traversal of its nodes' values.\n>\n> **Example:**\n>\n> ```\n> Input: [1,null,2,3]\n> 1\n>  \\\n>   2\n>  /\n> 3\n> \n> Output: [1,3,2]\n> ```\n>\n> **Follow up:** Recursive solution is trivial, could you do it iteratively?\n\nSolution 1 Recursion\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> res = new ArrayList<>();\n        helper(root, res);\n        return res;\n    }\n    private void helper(TreeNode root, List<Integer> res) {\n        if (root != null) {\n            if (root.left != null) {\n                helper(root.left, res);\n            }\n            res.add(root.val);\n            if (root.right != null) {\n                helper(root.right, res);\n            }\n        }\n    }\n}\n```\n\nSolution 2 Stack\n\n```java\nclass Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> res = new ArrayList<>();\n        Stack<TreeNode> stack = new Stack<>();\n        TreeNode cur = root;\n        while (cur != null || !stack.isEmpty()) {\n            while (cur != null) {\n                stack.push(cur);\n                cur = cur.left;\n            }\n            cur = stack.pop();\n            res.add(cur.val);\n            cur = cur.right;\n        }\n        return res;\n    }\n}\n```\n\n## Backtracking\n\n### 78. Subsets (Medium) [@](https://leetcode.com/problems/subsets/)\n\n> Given a set of **distinct** integers, *nums*, return all possible subsets (the power set).\n>\n> **Note:** The solution set must not contain duplicate subsets.\n>\n> **Example:**\n>\n> ```\n> Input: nums = [1,2,3]\n> Output:\n> [\n> [3],\n> [1],\n> [2],\n> [1,2,3],\n> [1,3],\n> [2,3],\n> [1,2],\n> []\n> ]\n> ```\n\nSolution 1 Recursion\n```java\nclass Solution {\n    public List<List<Integer>> subsets(int[] nums) {\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\n        List<Integer> cur = new ArrayList<Integer>();\n        backtrack(res, cur, nums, 0);\n        return res;\n    }\n    private void backtrack(List<List<Integer>> res, List<Integer> cur, int[] nums, int j) {\n        res.add(new ArrayList<Integer>(cur));\n        for (int i = j; i < nums.length; i++) {\n            cur.add(nums[i]);//add nums[i]\n            backtrack(res, cur, nums, i+1);// Recursion\n            cur.remove(cur.size()-1);//remove nums[i]\n        }\n    }\n}\n```\nSolution 2 Iteration\n```java\nclass Solution {\n    public List<List<Integer>> subsets(int[] nums) {\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\n        res.add(new ArrayList<Integer>());\n        for (int num : nums) { //pick up each element from nums\n            int size = res.size();\n            for (int i = 0; i < size; i++) {\n                //pick up each element in current res\n                List<Integer> temp = new ArrayList<Integer>(res.get(i));\n                temp.add(num);//put num into temp\n                res.add(temp);//add temp into res\n            }\n        }\n        return res;\n    }\n}\n```\n\n### 79. Word Search (Medium) [@](https://leetcode.com/problems/word-search/)\n\n> Given a 2D board and a word, find if the word exists in the grid.\n>\n> The word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\n>\n> **Example:**\n>\n> ```\n> board =\n> [\n> ['A','B','C','E'],\n> ['S','F','C','S'],\n> ['A','D','E','E']\n> ]\n> \n> Given word = \"ABCCED\", return true.\n> Given word = \"SEE\", return true.\n> Given word = \"ABCB\", return false.\n> ```\n\nSolution dfs + backtrack\n```java\nclass Solution {\n    //direction: right, down, left, up\n    int[] drow = {0, 1, 0, -1};\n    int[] dcol = {1, 0, -1, 0};\n    public boolean exist(char[][] board, String word) {\n        boolean[][] isVisited = new boolean[board.length][board[0].length];\n        for (int i = 0; i < board.length; i++) {\n            for (int j = 0; j < board[0].length; j++) {\n                if (isThisWay(board, word, i, j, 0, isVisited))\n                    return true;\n            }\n        }\n        return false;\n    }\n    \n    private boolean isThisWay(char[][] board, String word, int row, int col, int index, boolean[][] isVisited) {\n        if (row < 0 || row >= board.length || col < 0 || col >= board[0].length || isVisited[row][col] || board[row][col] != word.charAt(index))\n            return false;\n        if (++index == word.length())\n            return true; // complete matching\n        isVisited[row][col] = true;\n        for (int i = 0; i < 4; i++) {\n            if (isThisWay(board, word, row + drow[i], col + dcol[i], index, isVisited))\n                return true;\n        }\n        isVisited[row][col] = false;//backtrack if false\n        return false;\n    }\n}\n```\n\n### 131. Palindrome Partitioning (Medium) [@](https://leetcode.com/problems/palindrome-partitioning/)\n\nSolution DFS + backtracking\n- 递归寻找子问题，如果子串回文，则加入res\n```java\nclass Solution {\n    public List<List<String>> partition(String s) {\n        List<List<String>> res = new ArrayList<List<String>>();\n        List<String> cur = new ArrayList<String>();\n        if (s.length() == 0 || s == null) return res;\n        \n        backtrack(s, 0, cur, res);\n        return res;\n    }\n    \n    private void backtrack(String s, int start, List<String> cur, List<List<String>> res) {\n        //recursion complete condition\n        if (start == s.length()) {\n            res.add(new ArrayList<String>(cur));\n            return;\n        }\n        for (int i = start; i < s.length(); i++) {\n            String str = s.substring(start, i + 1);\n            if (isPalindrome(str)) {\n                cur.add(str);\n                backtrack(s, i+1, cur, res);\n                cur.remove(cur.size()-1);\n            }\n        }\n    }\n    \n    private boolean isPalindrome(String str) {\n        int left = 0, right = str.length() - 1;\n        while (left < right) {\n            if (str.charAt(left) != str.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        return true;\n    }\n}\n```\n### 212. Word Search II (Hard) [@](https://leetcode.com/problems/word-search-ii/)\n\n> Given a 2D board and a list of words from the dictionary, find all words in the board.\n>\n> Each word must be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\n>\n> \n>\n> **Example:**\n>\n> ```\n> Input: \n> board = [\n> ['o','a','a','n'],\n> ['e','t','a','e'],\n> ['i','h','k','r'],\n> ['i','f','l','v']\n> ]\n> words = [\"oath\",\"pea\",\"eat\",\"rain\"]\n> \n> Output: [\"eat\",\"oath\"]\n> ```\n>\n> \n>\n> **Note:**\n>\n> 1. All inputs are consist of lowercase letters `a-z`.\n> 2. The values of `words` are distinct.\n\n[Solution](https://www.cnblogs.com/Dylan-Java-NYC/p/4944555.html) Tire + DFS\n\n> [Word Search](http://www.cnblogs.com/Dylan-Java-NYC/p/4944270.html)的进阶版题目，同时可以利用[Implement Trie (Prefix Tree)](http://www.cnblogs.com/Dylan-Java-NYC/p/4888830.html).\n>\n> 生成Trie树，把所有的词都insert进去。\n>\n> 然后从board上的每一个char开始dfs查找。\n>\n> 终止条件有两个， 一个 i 和 j 出界，或者board[i][j]已经用过了. 另一个是把board[i][j]加到当前item后，若没有以更新过item为prefix的时候就可以返回了.\n>\n> search 更新过的item, 若是有就加到res中, **并且继续，这里不能return,** 因为有可能有 \"aabc\" \"aabcb\"两个词同时存在的情况，只检查了\"aabc\"就return会漏掉\"aabcb\".\n>\n> 标记当前used为true, 然后board四个方向都做recursion. used再改回来.\n>\n> Note: 如果board 是[a a], words 只有一个[a], 此时小心重复加了，所以要用HashSet生成res, 最后再用res生成的List返回。\n>\n> m = board.length, n = board[0].length, k = words.length, l 是 word的平均长度.\n>\n> Time Complexity: O(k*l + m*n*l*4^l). k*l是简历Trie用时间. m*n是外部循环, l是search Trie时间, 4^l是recursion + backtracking的时间.\n>\n> Space: O(k*l + l). k*l是Trie数的大小. 用了l层stack.\n\n```java\npublic class Solution {\n    public List<String> findWords(char[][] board, String[] words) {\n        HashSet<String> res = new HashSet<String>();\n        if(words == null || words.length == 0 || board == null || board.length == 0 || board[0].length == 0){\n            return new ArrayList(res);\n        }\n        Trie trie = new Trie();\n        for(int i = 0; i<words.length; i++){\n            trie.insert(words[i]);\n        }\n        \n        boolean [][] used = new boolean[board.length][board[0].length];\n        for(int i = 0; i<board.length; i++){\n            for(int j = 0; j<board[0].length; j++){\n                findHelper(board,trie,used,\"\",i,j,res);\n            }\n        }\n        return new ArrayList(res);\n    }\n    private void findHelper(char[][] board, Trie trie, boolean [][] used, String item, int i, int j, HashSet<String> res){\n        \n        if(i<0 || j<0 || i>= board.length || j>=board[0].length || used[i][j]){\n            return;\n        }\n        \n        item = item+board[i][j];\n        if(!trie.startsWith(item)){\n            return;\n        }\n        if(trie.search(item)){\n            res.add(item);\n        }\n        used[i][j] = true;\n        findHelper(board,trie,used,item,i+1,j,res);\n        findHelper(board,trie,used,item,i-1,j,res);\n        findHelper(board,trie,used,item,i,j+1,res);\n        findHelper(board,trie,used,item,i,j-1,res);\n        used[i][j] = false;\n    }\n}\n\n\nclass TrieNode{\n    String val = \"\";\n    TrieNode [] nexts;\n    public TrieNode(){\n        nexts = new TrieNode[26];\n    }\n}\nclass Trie{\n    private TrieNode root;\n    public Trie(){\n        root = new TrieNode();\n    }\n    \n    public void insert(String word){\n        TrieNode p = root;\n        for(char c : word.toCharArray()){\n            if(p.nexts[c-'a'] == null){\n                p.nexts[c-'a'] = new TrieNode();\n            }\n            p = p.nexts[c-'a'];\n        }\n        p.val = word;\n    }\n    \n    public boolean search(String word){\n        TrieNode p = root;\n        for(char c : word.toCharArray()){\n            if(p.nexts[c-'a'] == null){\n                return false;\n            }\n            p = p.nexts[c-'a'];\n        }\n        return p.val.equals(word);\n    }\n    \n    public boolean startsWith(String prefix){\n        TrieNode p = root;\n        for(char c : prefix.toCharArray()){\n            if(p.nexts[c-'a'] == null){\n                return false;\n            }\n            p = p.nexts[c-'a'];\n        }\n        return true;\n    }\n}\n```\n## String\n\n### 12. Integer to Roman (Easy) [@](https://leetcode.com/problems/integer-to-roman/)\n\n> Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D` and `M`.\n>\n> ```\n> Symbol       Value\n> I             1\n> V             5\n> X             10\n> L             50\n> C             100\n> D             500\n> M             1000\n> ```\n>\n> For example, two is written as `II` in Roman numeral, just two one's added together. Twelve is written as, `XII`, which is simply `X` + `II`. The number twenty seven is written as `XXVII`, which is `XX` + `V` + `II`.\n>\n> Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not `IIII`. Instead, the number four is written as `IV`. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as `IX`. There are six instances where subtraction is used:\n>\n> - `I` can be placed before `V` (5) and `X` (10) to make 4 and 9. \n> - `X` can be placed before `L` (50) and `C` (100) to make 40 and 90. \n> - `C` can be placed before `D` (500) and `M` (1000) to make 400 and 900.\n>\n> Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.\n>\n> **Example 1:**\n>\n> ```\n> Input: 3\n> Output: \"III\"\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: 4\n> Output: \"IV\"\n> ```\n>\n> **Example 3:**\n>\n> ```\n> Input: 9\n> Output: \"IX\"\n> ```\n>\n> **Example 4:**\n>\n> ```\n> Input: 58\n> Output: \"LVIII\"\n> Explanation: L = 50, V = 5, III = 3.\n> ```\n\nSolution\n\n- 计算每个位的值，并用对应字符串表示\n\n```java\nclass Solution {\n    public String intToRoman(int num) {\n        String[] M = {\"\", \"M\", \"MM\", \"MMM\"};\n        String[] C = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\n        String[] X = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\n        String[] I = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\n        \n        return M[(num/1000)]+C[(num%1000)/100]+X[(num%100)/10]+I[(num%10)];\n    }\n}\n```\n\n\n\n### 13. Roman to Integer (Easy) [@](https://leetcode.com/problems/roman-to-integer/)\n\n> Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D` and `M`.\n>\n> ```\n> Symbol       Value\n> I             1\n> V             5\n> X             10\n> L             50\n> C             100\n> D             500\n> M             1000\n> ```\n>\n> For example, two is written as `II` in Roman numeral, just two one's added together. Twelve is written as, `XII`, which is simply `X` + `II`. The number twenty seven is written as `XXVII`, which is `XX` + `V` + `II`.\n>\n> Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not `IIII`. Instead, the number four is written as `IV`. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as `IX`. There are six instances where subtraction is used:\n>\n> - `I` can be placed before `V` (5) and `X` (10) to make 4 and 9. \n> - `X` can be placed before `L` (50) and `C` (100) to make 40 and 90. \n> - `C` can be placed before `D` (500) and `M` (1000) to make 400 and 900.\n>\n> Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.\n>\n> **Example 1:**\n>\n> ```\n> Input: \"III\"\n> Output: 3\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: \"IV\"\n> Output: 4\n> ```\n>\n> **Example 3:**\n>\n> ```\n> Input: \"IX\"\n> Output: 9\n> ```\n>\n> **Example 4:**\n>\n> ```\n> Input: \"LVIII\"\n> Output: 58\n> Explanation: L = 50, V= 5, III = 3.\n> ```\n>\n> **Example 5:**\n>\n> ```\n> Input: \"MCMXCIV\"\n> Output: 1994\n> Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n> ```\n\nSolution 1\n\n```java\nclass Solution {\n    public int romanToInt(String s) {\n        HashMap<Character, Integer> hm = new HashMap<Character, Integer>();\n        hm.put('I', 1);\n        hm.put('V', 5);\n        hm.put('X', 10);\n        hm.put('L', 50);\n        hm.put('C', 100);\n        hm.put('D', 500);\n        hm.put('M', 1000);\n        \n        int maxDigit = 0, val = 0;\n        for (int i = s.length() - 1; i >= 0; i--) {\n            int cur = hm.get(s.charAt(i));\n            if (cur >= maxDigit) {\n                val += cur;\n                maxDigit = cur;\n            }else {\n                val -= cur;\n            }\n        }\n        return val;\n    }\n}\n```\n\nSolution 2\n\n- 仅有 I X C 可能成为前缀，所以遇到需要考虑是否更新前缀\n\n```java\nclass Solution {\n    public static int romanToInt(String s) {\n        int x = 0;\n        char prev = ' ';\n        for (int i = 0; i < s.length(); i++) {\n            // if (prev == ' ') prev = s.charAt(i);\n            \n            switch (s.charAt(i)) {\n                case 'M':\n                    x += prev == 'C' ? 900 : 1000;\n                    break;\n                case 'D':\n                    x += prev == 'C' ? 400 : 500;\n                    break;\n                case 'C':\n                    if (i < s.length() - 1 && (s.charAt(i + 1) == 'D' || s.charAt(i + 1) == 'M')) {\n                        prev = 'C';\n                    } else {\n                        x += prev == 'X' ? 90 : 100;\n                    }\n                    break;\n                case 'L':\n                    x += prev == 'X' ? 40 : 50;\n                    break;\n                case 'X':\n                    if (i < s.length() - 1 && (s.charAt(i + 1) == 'L' || s.charAt(i + 1) == 'C')) {\n                        prev = 'X';\n                    } else {\n                        x += prev == 'I' ? 9 : 10;\n                    }\n                    break;\n                case 'V':\n                    x += prev == 'I' ? 4 : 5;\n                    break;\n                case 'I':\n                    if (i < s.length() - 1 && (s.charAt(i + 1) == 'V' || s.charAt(i + 1) == 'X')) {\n                        prev = 'I';\n                    } else {\n                        x += 1;\n                    }\n                    break;\n            }\n        }\n        return x;\n    }\n}\n```\n\n\n\n### 14. Longest Common Prefix (Easy) [@](https://leetcode.com/problems/longest-common-prefix/)\n\n> Write a function to find the longest common prefix string amongst an array of strings.\n>\n> If there is no common prefix, return an empty string `\"\"`.\n>\n> **Example 1:**\n>\n> ```\n> Input: [\"flower\",\"flow\",\"flight\"]\n> Output: \"fl\"\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: [\"dog\",\"racecar\",\"car\"]\n> Output: \"\"\n> Explanation: There is no common prefix among the input strings.\n> ```\n>\n> **Note:**\n>\n> All given inputs are in lowercase letters `a-z`.\n\nSolution 1 Recursion + Divide and Conquer\n\n- 二分所有串，一半一半考虑找出commonPrefix\n\n```java\nclass Solution {\n    public String longestCommonPrefix(String[] strs) {\n        if (strs.length == 0 || strs == null) return \"\"; //特殊情况\n        return longestCommonPrefix(strs, 0, strs.length-1);\n    }\n    private String longestCommonPrefix(String[] strs, int l, int r) {\n        if (l == r) {\n            return strs[l];\n        }else {\n            int mid = (l+r)/2;\n            String lcpLeft = longestCommonPrefix(strs, l, mid);//左区间\n            String lcpRight = longestCommonPrefix(strs, mid+1, r);//右区间\n            return commonPrefix(lcpLeft, lcpRight);\n        }\n    }\n    private String commonPrefix(String ls, String rs) {\n        int min = Math.min(ls.length(), rs.length());\n        for (int i = 0; i<min; i++) {\n            if (ls.charAt(i) != rs.charAt(i)) {\n                return ls.substring(0,i);\n            }\n        }\n        return ls.substring(0,min);\n    }\n}\n```\n\nSolution 2 Divide and Conquer\n\n- 假设commonPrefix长度，二分最短串长度\n- 如果存在，则l和r最后汇聚在commonPrefix的尾部\n\n```java\nclass Solution {\n    public String longestCommonPrefix(String[] strs) {\n        if (strs.length == 0 || strs == null) {\n            return \"\";\n        }\n        \n        int minLen = Integer.MAX_VALUE;\n        for (int i = 0; i < strs.length; i++) {\n            minLen = Math.min(strs[i].length(), minLen);\n        }\n        int l = 0, r = minLen;\n        while (l <= r) {\n            int mid = (l + r) / 2;\n            if (isCommonPrefix(strs, mid)) {\n                l = mid + 1;\n            }else {\n                r= mid - 1;\n            }\n        }\n        return strs[0].substring(0, (l+r)/2);\n    }\n    private boolean isCommonPrefix(String[] strs, int len) {\n        String s = strs[0].substring(0, len);\n        for (int i = 1; i < strs.length; i++) {\n            if (!strs[i].startsWith(s)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n\n\n### 28. Implement strStr()  (Easy)  [@](https://leetcode.com/problems/implement-strstr/)\n\n> Implement [strStr()](http://www.cplusplus.com/reference/cstring/strstr/).\n>\n> Return the index of the first occurrence of needle in haystack, or **-1** if needle is not part of haystack.\n>\n> **Example 1:**\n>\n> ```\n> Input: haystack = \"hello\", needle = \"ll\"\n> Output: 2\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: haystack = \"aaaaa\", needle = \"bba\"\n> Output: -1\n> ```\n\nSolution 1 Iteration\n\n```java\nclass Solution {\n    public int strStr(String haystack, String needle) {\n        if (needle.length() == 0) return 0;\n        for (int i = 0; i < haystack.length() - needle.length() + 1; i++) {\n            if (haystack.charAt(i) == needle.charAt(0)) {\n                int j = 1;\n                while (j < needle.length() && haystack.charAt(i+j) == needle.charAt(j)) {\n                    j++;\n                }\n                if (j == needle.length())\n                    return i;\n            }\n        }\n        return -1;\n    }\n}\n```\n\nSolution 2 KMP (Knuth–Morris–Pratt [string-searching algorithm](https://en.wikipedia.org/wiki/String-searching_algorithm))\n\n- 核心是PMT(Partial Match Table)数组：前缀B -- A=BS (S为非空字符串)；PMT 中的值是字符串的前缀集合与后缀集合的交集中最长元素的长度\n- ![IMG_0923.JPG](:/67dad347bcda4fb7998271ac90779b10)\n\n```java\nclass Solution {\n    public int strStr(String haystack, String needle) {\n        if (needle.length() == 0) return 0;\n        int i = 0, j = -1, N = needle.length(), M = haystack.length();\n        int[] next = new int[N];\n        next[0] = -1;\n        while (i < N-1) {// generate next array\n            if (j == -1 || needle.charAt(i) == needle.charAt(j)) {\n                i++;\n                j++;\n                next[i] = j;\n            }else {\n                j = next[j];\n            }\n        }\n        \n        i = 0; j = 0;\n        while (i < M && j < N) {\n            if (j == -1 || haystack.charAt(i) == needle.charAt(j)) {\n                i++;\n                j++;\n            }else {\n                j = next[j];\n            }\n        }\n        if (j == N) \n            return i-j;\n        return -1;\n    }\n}\n```\n\nSolution 3 HashMap\n\n- 直接containsKey匹配子串\n\n```java\nclass Solution {\n    public int strStr(String haystack, String needle) {\n        if (needle.length() == 0) return 0;\n        if (needle.length() > haystack.length()) return -1;\n        \n        HashMap<String, Integer> map = new HashMap<>();\n        map.put(haystack, 0);\n        //put each needle-len substring of haystack into the hashmap\n        for (int i = 0; i <= haystack.length() - needle.length(); i++) {\n            if (map.containsKey(needle)) {\n                return map.get(needle);\n            }\n            map.put(haystack.substring(i, i+needle.length()), i);\n        }\n        return map.getOrDefault(needle, -1);\n    }\n}\n```\n\n\n\n### 38. Count and Say (Easy) [@](https://leetcode.com/problems/count-and-say/)\n\n> The count-and-say sequence is the sequence of integers with the first five terms as following:\n>\n> ```\n> 1.     1\n> 2.     11\n> 3.     21\n> 4.     1211\n> 5.     111221\n> ```\n>\n> `1` is read off as `\"one 1\"` or `11`.\n> `11` is read off as `\"two 1s\"` or `21`.\n> `21` is read off as `\"one 2`, then `one 1\"` or `1211`.\n>\n> Given an integer *n* where 1 ≤ *n* ≤ 30, generate the *n*th term of the count-and-say sequence. You can do so recursively, in other words from the previous member read off the digits, counting the number of digits in groups of the same digit.\n>\n> Note: Each term of the sequence of integers will be represented as a string.\n>\n>  \n>\n> **Example 1:**\n>\n> ```\n> Input: 1\n> Output: \"1\"\n> Explanation: This is the base case.\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: 4\n> Output: \"1211\"\n> Explanation: For n = 3 the term was \"21\" in which we have two groups \"2\" and \"1\", \"2\" can be read as \"12\" which means frequency = 1 and value = 2, the same way \"1\" is read as \"11\", so the answer is the concatenation of \"12\" and \"11\" which is \"1211\".\n> ```\n\nSolution 1 Recursion\n\n```java\nclass Solution {\n    public String countAndSay(int n) {\n        if (n == 1) {\n            return \"1\";\n        }else {\n            String preStr = countAndSay(n-1);\n            String res = \"\";\n            int len = 1; //len of same char\n            int i = 1; //idx of preStr\n            //scan preStr to determine the following string\n            while (i < preStr.length()) {\n                if (preStr.charAt(i) == preStr.charAt(i-1)) {\n                    len++;\n                }else {\n                    res += String.valueOf(len) + String.valueOf(preStr.charAt(i-1));\n                    len = 1; //reset len of same char\n                }\n                i++;\n            }\n            res += String.valueOf(len) + String.valueOf(preStr.charAt(i-1));\n            return res.toString();\n        }\n    }\n}\n```\n\nSolution 1 Improvement \n\n```java\nclass Solution {\n    public String countAndSay(int n) {\n        if (n == 1) {\n            return \"1\";\n        }else {\n            String preStr = countAndSay(n-1);\n            StringBuilder res = new StringBuilder();\n            int len = 1; //len of same char\n            int i = 1; //idx of preStr\n            //scan preStr to determine the following string\n            while (i < preStr.length()) {\n                if (preStr.charAt(i) == preStr.charAt(i-1)) {\n                    len++;\n                }else {\n                    // res += String.valueOf(len) + String.valueOf(preStr.charAt(i-1));\n                    res.append(len).append(preStr.charAt(i-1));\n                    len = 1; //reset len of same char\n                }\n                i++;\n            }\n            // res += String.valueOf(len) + String.valueOf(preStr.charAt(i-1));\n            res.append(len).append(preStr.charAt(i-1));\n            return res.toString();\n        }\n    }\n}\n```\n\n\n\nSolution 2 Recursion\n\n```java\nclass Solution {\n    public String countAndSay(int n) {\n        if (n == 1) {\n            return \"1\";\n        }\n        return read(countAndSay(n-1));\n    }\n    private String read(String preStr) {\n        StringBuilder res = new StringBuilder();\n        for (int i = 0; i < preStr.length(); i++) {\n            char c = preStr.charAt(i); //current char\n            int len = 1; //len of same char\n            //find and append next \"len+c\"\n            while ((i+1) < preStr.length()) {\n                if (preStr.charAt(i+1) != c) {\n                    break;\n                } else {\n                    i++;\n                    len++;\n                }\n            }\n            res.append(len).append(c);\n        }\n        return res.toString();\n    }\n}\n```\n\n\n\n### 49. Group Anagrams (Medium) [@](https://leetcode.com/problems/group-anagrams/)\n\n> Given an array of strings, group anagrams together.\n>\n> **Example:**\n>\n> ```\n> Input: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"],\n> Output:\n> [\n> [\"ate\",\"eat\",\"tea\"],\n> [\"nat\",\"tan\"],\n> [\"bat\"]\n> ]\n> ```\n>\n> **Note:**\n>\n> - All inputs will be in lowercase.\n> - The order of your output does not matter.\n\nSolution 1 Hash Map\n\n- sort(str) 找到同字母的串\n\n```java\nclass Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        if(strs == null || strs.length == 0) {\n            List<List<String>> ans = new ArrayList<List<String>>();\n            return ans;\n        }\n        \n        HashMap<String, List<String>> hash = new HashMap<String, List<String>>();\n        for (String str:strs) {\n            char[] c = str.toCharArray();\n            Arrays.sort(c);\n            String temp = String.valueOf(c);\n            if (!hash.containsKey(temp)) {\n                List<String> vals = new ArrayList<String>();\n                vals.add(str);\n                hash.put(temp, vals);\n            }else {\n                hash.get(temp).add(str);\n            }\n        }\n        List<List<String>> ans = new ArrayList<List<String>>();\n        ans.addAll(hash.values());\n        return ans;\n    }\n}\n```\n\nSolution 2 Hash Map + Prime Number\n\n- 每个字母对应一个质数，计算所有字符串的积\n\n```java\nclass Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        //26个质数对应26个字母\n        int[] primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103};\n        List<List<String>> ans = new ArrayList<List<String>>();\n        HashMap<Integer, List<String>> hash = new HashMap<Integer, List<String>>();\n        for (String str:strs) {\n            int key = 1;\n            for (char c : str.toCharArray()) {\n                key *= primes[c-'a'];\n            }\n            if (!hash.containsKey(key)) {\n                List<String> vals = new ArrayList<String>();\n                vals.add(str);\n                hash.put(key, vals);\n            } else {\n                hash.get(key).add(str);\n            }\n        }\n        ans.addAll(hash.values());\n        return ans;\n    }\n}\n```\n\n\n\n### 58. Length of Last Word (Easy) [@](https://leetcode.com/problems/length-of-last-word/)\n\n> Given a string *s* consists of upper/lower-case alphabets and empty space characters `' '`, return the length of last word (last word means the last appearing word if we loop from left to right) in the string.\n>\n> If the last word does not exist, return 0.\n>\n> **Note:** A word is defined as a **maximal substring** consisting of non-space characters only.\n>\n> **Example:**\n>\n> ```\n> Input: \"Hello World\"\n> Output: 5\n> ```\n\nSolution \n\n- Start = 第一个非' '字符\n- End = 下一个‘ ’\n- 注意while条件顺序，首先判断是否越界\n\n```java\nclass Solution {\n    public int lengthOfLastWord(String s) {\n        if (s == null || s.length() == 0) return 0;\n        \n        int count = 0;\n        int first = s.length() - 1;\n        //the first not-' ' character --- start\n        while (first >= 0 && s.charAt(first) == ' ')\n            first--;\n        //next ' ' position --- end\n        while (first >= 0 && s.charAt(first) != ' ') {\n            first--;\n            count++;\n        }\n        return count;\n    }\n}\n```\n\n\n\n### 87.  Scramble String (Hard) [@](https://leetcode.com/problems/scramble-string/)\n\n> Given a string *s1*, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.\n>\n> Below is one possible representation of *s1* = `\"great\"`:\n>\n> ```\n>  great\n> /    \\\n> gr    eat\n> / \\    /  \\\n> g   r  e   at\n>         / \\\n>        a   t\n> ```\n>\n> To scramble the string, we may choose any non-leaf node and swap its two children.\n>\n> For example, if we choose the node `\"gr\"` and swap its two children, it produces a scrambled string `\"rgeat\"`.\n>\n> ```\n>  rgeat\n> /    \\\n> rg    eat\n> / \\    /  \\\n> r   g  e   at\n>         / \\\n>        a   t\n> ```\n>\n> We say that `\"rgeat\"` is a scrambled string of `\"great\"`.\n>\n> Similarly, if we continue to swap the children of nodes `\"eat\"` and `\"at\"`, it produces a scrambled string `\"rgtae\"`.\n>\n> ```\n>  rgtae\n> /    \\\n> rg    tae\n> / \\    /  \\\n> r   g  ta  e\n>     / \\\n>    t   a\n> ```\n>\n> We say that `\"rgtae\"` is a scrambled string of `\"great\"`.\n>\n> Given two strings *s1* and *s2* of the same length, determine if *s2* is a scrambled string of *s1*.\n>\n> **Example 1:**\n>\n> ```\n> Input: s1 = \"great\", s2 = \"rgeat\"\n> Output: true\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: s1 = \"abcde\", s2 = \"caebd\"\n> Output: false\n> ```\n\nSolution 1 Recursion\n\n```java\nclass Solution {\n    public boolean isScramble(String s1, String s2) {\n        //len of str\n        if (s1.length() != s2.length()) return false;\n        \n        if (s1.equals(s2)) return true;\n        \n        //num of letters\n        int[] letter = new int[26];\n        for (int i = 0; i < s1.length(); i++) {\n            letter[s1.charAt(i) - 'a']++;\n            letter[s2.charAt(i) - 'a']--;\n        }\n        //diff num of letters -> false\n        for (int i = 0; i < 26; i++) {\n            if (letter[i] != 0)\n                return false;\n        }\n        \n        //loop through all cut points\n        for (int i = 1; i < s1.length(); i++) {\n            if (isScramble(s1.substring(0, i), s2.substring(0, i)) && isScramble(s1.substring(i), s2.substring(i)))\n                return true;\n            //switch\n            if (isScramble(s1.substring(i), s2.substring(0, s2.length() - i)) && isScramble(s1.substring(0, i), s2.substring(s2.length() - i)))\n                return true;\n        }\n        return false;\n   }\n}\n```\n\nSolution 2 Recursion + Memorization\n\n```java\nclass Solution {\n    public boolean isScramble(String s1, String s2) {\n        HashMap<String, Integer> memo = new HashMap<>();\n        return isSrambleHelper(s1, s2, memo);\n    }\n    \n    private boolean isSrambleHelper(String s1, String s2, HashMap<String, Integer> memo) {\n        //previous res\n        int res = memo.getOrDefault(s1 + \"#\" + s2, -1);\n        if (res == 1)\n            return true;\n        else if (res == 0)\n            return false;\n        \n        //len of str\n        if (s1.length() != s2.length()) {\n            memo.put(s1 + \"#\" + s2, 0);\n            return false;\n        } \n        \n        if (s1.equals(s2)) {\n            memo.put(s1 + \"#\" + s2, 1);\n            return true;\n        } \n        \n        //num of letters\n        int[] letter = new int[26];\n        for (int i = 0; i < s1.length(); i++) {\n            letter[s1.charAt(i) - 'a']++;\n            letter[s2.charAt(i) - 'a']--;\n        }\n        //diff num of letters -> false\n        for (int i = 0; i < 26; i++) {\n            if (letter[i] != 0) {\n                memo.put(s1 + \"#\" + s2, 0);\n                return false;\n            }\n        }\n        \n        //loop through all cut points\n        for (int i = 1; i < s1.length(); i++) {\n            if (isScramble(s1.substring(0, i), s2.substring(0, i)) && isScramble(s1.substring(i), s2.substring(i))) {\n                memo.put(s1 + \"#\" + s2, 1);\n                return true;\n            }\n                \n            //switch\n            if (isScramble(s1.substring(i), s2.substring(0, s2.length() - i)) && isScramble(s1.substring(0, i), s2.substring(s2.length() - i))) {\n                memo.put(s1 + \"#\" + s2, 1);\n                return true;\n            }\n        }\n        memo.put(s1 + \"#\" + s2, 0);\n        return false;\n    }\n}\n```\n\nSolution 3 DP\n\n- [solution detail](https://leetcode-cn.com/problems/scramble-string/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-1-2/)\n\n```java\nclass Solution {\n    public boolean isScramble(String s1, String s2) {\n        //len of str\n        if (s1.length() != s2.length()) return false;\n        \n        if (s1.equals(s2)) return true;\n        \n        //num of letters\n        int[] letter = new int[26];\n        for (int i = 0; i < s1.length(); i++) {\n            letter[s1.charAt(i) - 'a']++;\n            letter[s2.charAt(i) - 'a']--;\n        }\n        //diff num of letters -> false\n        for (int i = 0; i < 26; i++) {\n            if (letter[i] != 0)\n                return false;\n        }\n        \n        int length = s1.length();\n        boolean[][][] dp = new boolean[length + 1][length][length];\n        //loop through all the len of str\n        for (int len = 1; len < length + 1; len++) {\n            //start of s1\n            for (int i = 0; i + len < length + 1; i++) {\n                //start of s2\n                for (int j = 0; j + len < length + 1; j++) {\n                    if (len == 1) {\n                        dp[len][i][j] = s1.charAt(i) == s2.charAt(j);\n                    } else {\n                        //loop through all the cut point\n                        for (int q = 1; q < len; q++) {\n                            dp[len][i][j] = (dp[q][i][j] && dp[len-q][i+q][j+q]) || (dp[q][i][j+len-q] && dp[len-q][i+q][j]);\n                            if (dp[len][i][j])\n                                break;\n                        }\n                    }\n                }\n            }\n        }\n        return dp[length][0][0];\n    }\n}\n```\n\n\n\n### 125. Valid Palindrome (Easy) [@](https://leetcode.com/problems/valid-palindrome/submissions/)\n\n> Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.\n>\n> **Note:** For the purpose of this problem, we define empty string as valid palindrome.\n>\n> **Example 1:**\n>\n> ```\n> Input: \"A man, a plan, a canal: Panama\"\n> Output: true\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: \"race a car\"\n> Output: false\n> ```\n\nSolution \n```java\nclass Solution {\n    public boolean isPalindrome(String s) {\n        if (s.length() == 0 || s == null) return true;\n        s = s.toLowerCase();\n        int left = 0, right = s.length() - 1;\n        while (left < right) {\n            if (!Character.isLetterOrDigit(s.charAt(left))) {\n                left ++;\n                continue;\n            }\n            if (!Character.isLetterOrDigit(s.charAt(right))) {\n                right --;\n                continue;\n            }\n            if (s.charAt(left) == s.charAt(right)) {\n                left ++;\n                right --;\n            }else {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n\n\n### 151. Reverse Words in a String (Medium)  [@](https://leetcode.com/problems/reverse-words-in-a-string/)\n\n> Given an input string, reverse the string word by word.\n>\n> **Example 1:**\n>\n> ```\n> Input: \"the sky is blue\"\n> Output: \"blue is sky the\"\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: \"  hello world!  \"\n> Output: \"world! hello\"\n> Explanation: Your reversed string should not contain leading or trailing spaces.\n> ```\n>\n> **Example 3:**\n>\n> ```\n> Input: \"a good   example\"\n> Output: \"example good a\"\n> Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string.\n> ```\n\nSolution 1 Library function\n\n```java\nclass Solution {\n    public String reverseWords(String s) {\n        StringBuilder ans = new StringBuilder();\n        //去掉s的首尾空格 然后将字符串拆分\n        String[] str = s.trim().split(\" \");\n        for(int i = str.length - 1; i >= 0; i--){\n            //空格后面的空格会变成空字符串\n            if(!str[i].equals(\"\")) ans.append(str[i] + \" \");\n        }\n        //去掉最后添加上的空格\n        ans = new StringBuilder(ans.toString().trim());\n        return ans.toString();\n    }\n}\n```\n\nSolution 2 从后向前\n\n- 将源字符串转换为数组，然后从后向前读取，遇到空格，判断是否单词结束\n\n```JAVA\nclass Solution {\n    public String reverseWords(String s) {\n        if (s == null || s.length() == 0) return \"\";\n        \n        char[] chars = s.toCharArray();\n        StringBuffer ans = new StringBuffer();\n        int count = 0, ptr = s.length()-1;\n        //从后向前扫描\n        while(ptr >= 0) {\n            //空格两种情况：单词结束 和 未开始\n            if (chars[ptr] == ' ') {\n                if (count != 0) {\n                    ans.append(chars, ptr + 1, count).append(' ');\n                    count = 0;//重置count\n                }\n            //遇到字母\n            }else {\n                count++;\n            }\n            ptr--;\n        }\n        //处理最后一个单词\n        if (count != 0) {\n            ans.append(chars, 0, count).append(' ');\n        }\n        //去除最后一个空格\n        return ans.length() == 0 ? \"\" : ans.toString().substring(0, ans.length()-1);\n    }\n}\n```\n\nSolution 3\n\n- 整句全部逆置，再逐个单词逆置\n\n### 166. Fraction to Recurring Decimal (Medium) [@](https://leetcode.com/problems/fraction-to-recurring-decimal/)\n\n> Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.\n>\n> If the fractional part is repeating, enclose the repeating part in parentheses.\n>\n> **Example 1:**\n>\n> ```\n> Input: numerator = 1, denominator = 2\n> Output: \"0.5\"\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: numerator = 2, denominator = 1\n> Output: \"2\"\n> ```\n>\n> **Example 3:**\n>\n> ```\n> Input: numerator = 2, denominator = 3\n> Output: \"0.(6)\"\n> ```\n\nSolution HashMap\n\n- 利用哈希表存储余数位置，以判断是否存在重复的对应小数位\n- 当出现重复则加入“（）”\n\n```java\nclass Solution {\n    public String fractionToDecimal(int numerator, int denominator) {\n        if (numerator == 0) return \"0\";\n        \n        StringBuilder fraction = new StringBuilder();\n        //positive or negative\n        if (numerator < 0 ^ denominator < 0) {\n            fraction.append(\"-\");\n        }\n        \n        Long dividend = Math.abs(Long.valueOf(numerator));\n        Long divisor = Math.abs(Long.valueOf(denominator));\n        //Integer Part\n        fraction.append(String.valueOf(dividend/divisor));\n        Long remainder = dividend % divisor;\n        if (remainder == 0) {\n            return fraction.toString();\n        }\n        //Decimal Part\n        fraction.append(\".\");\n        Map<Long, Integer> pos = new HashMap<>();\n        while (remainder != 0) {\n            //repeat\n            if (pos.containsKey(remainder)) {\n                fraction.insert(pos.get(remainder), \"(\");\n                fraction.append(\")\");\n                break;\n            }\n            //add new decimal num\n            pos.put(remainder, fraction.length()); //add remainder's position\n            remainder *= 10;\n            fraction.append(String.valueOf(remainder / divisor));//add corresponding decimal\n            remainder %= divisor;\n        }\n        return fraction.toString();\n    }\n}\n```\n\n\n\n### 168. Excel Sheet Column Title (Easy) [@](https://leetcode.com/problems/excel-sheet-column-title/)\n\n> Given a positive integer, return its corresponding column title as appear in an Excel sheet.\n>\n> For example:\n>\n> ```\n>  1 -> A\n>  2 -> B\n>  3 -> C\n>  ...\n>  26 -> Z\n>  27 -> AA\n>  28 -> AB \n>  ...\n> ```\n>\n> **Example 1:**\n>\n> ```\n> Input: 1\n> Output: \"A\"\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: 28\n> Output: \"AB\"\n> ```\n>\n> **Example 3:**\n>\n> ```\n> Input: 701\n> Output: \"ZY\"\n> ```\n\nSolution 进制转换\n\n- 注意是1 - 26 所以使用 n-1\n\n```java\nclass Solution {\n    public String convertToTitle(int n) {\n        StringBuilder str = new StringBuilder();\n        while (n > 0) {\n            str.insert(0, (char)((n-1)%26 + 'A'));\n            n = (n-1)/26;\n        }\n        return str.toString();\n    }\n}\n```\n\n\n\n### 171. Excel Sheet Column Number (Easy) [@](https://leetcode.com/problems/excel-sheet-column-number/)\n\n> Given a column title as appear in an Excel sheet, return its corresponding column number.\n>\n> For example:\n>\n> ```\n>  A -> 1\n>  B -> 2\n>  C -> 3\n>  ...\n>  Z -> 26\n>  AA -> 27\n>  AB -> 28 \n>  ...\n> ```\n>\n> **Example 1:**\n>\n> ```\n> Input: \"A\"\n> Output: 1\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: \"AB\"\n> Output: 28\n> ```\n>\n> **Example 3:**\n>\n> ```\n> Input: \"ZY\"\n> Output: 701\n> ```\n\nSolution\n\n```java\nclass Solution {\n    public int titleToNumber(String s) {\n        int ans = 0;\n        for (char c : s.toCharArray()) {\n            ans = ans * 26 + (int)(c - 'A' + 1);\n        }\n        return ans;\n    }\n}\n```\n\n\n\n### 179. Largest Number (Medium) [@](https://leetcode.com/problems/largest-number/)\n\n> Given a list of non negative integers, arrange them such that they form the largest number.\n>\n> **Example 1:**\n>\n> ```\n> Input: [10,2]\n> Output: \"210\"\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: [3,30,34,5,9]\n> Output: \"9534330\"\n> ```\n>\n> **Note:** The result may be very large, so you need to return a string instead of an integer.\n\nSolution \n\n```java\nclass Solution {\n    public class LargerNumberComparator implements Comparator<String> {\n        @Override\n        public int compare(String a, String b) {\n            String order1 = a + b;\n            String order2 = b + a;\n            return order2.compareTo(order1);\n        }\n    }\n    \n    public String largestNumber(int[] nums) {\n        //convert to strings\n        String[] asStrs = new String[nums.length];\n        for (int i = 0; i < nums.length; i++) {\n            asStrs[i] = String.valueOf(nums[i]);\n        }\n        \n        Arrays.sort(asStrs, new LargerNumberComparator());\n        \n        if (asStrs[0].equals(\"0\")) return \"0\";\n        \n        StringBuilder ans = new StringBuilder();\n        for (String str : asStrs) {\n            ans.append(str);\n        }\n        return ans.toString();\n    }\n}\n```\n\n\n\n\n\n### 205. Isomorphic Strings (Easy) [@](https://leetcode.com/problems/isomorphic-strings/)\n\n> Given two strings ***s\\*** and ***t\\***, determine if they are isomorphic.\n>\n> Two strings are isomorphic if the characters in ***s\\*** can be replaced to get ***t\\***.\n>\n> All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.\n>\n> **Example 1:**\n>\n> ```\n> Input: s = \"egg\", t = \"add\"\n> Output: true\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: s = \"foo\", t = \"bar\"\n> Output: false\n> ```\n>\n> **Example 3:**\n>\n> ```\n> Input: s = \"paper\", t = \"title\"\n> Output: true\n> ```\n>\n> **Note:**\n> You may assume both ***s\\*** and ***t\\*** have the same length.\n\nSolution 1 HashMap\n\n```java\nclass Solution {\n    public boolean isIsomorphic(String s, String t) {\n        if (s.length() != t.length()) return false;\n        //map -- match char in s and t\n        HashMap<Character, Character> map = new HashMap<>();\n        //set -- judge char in t whether has mapped\n        Set<Character> set = new HashSet<>();\n        char sChart, tChart;\n        for (int i = 0; i < s.length(); i++) {\n            sChart = s.charAt(i);\n            tChart = t.charAt(i);\n            \n            if(!map.containsKey(sChart)) {//no mapped\n                if (set.contains(tChart)) {//t has been mapped\n                    return false;\n                }else {\n                    map.put(sChart, tChart);\n                    set.add(tChart);\n                }\n            }else {//mapped\n                if (map.get(sChart) != tChart) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\n```\n\nSolution 2 Array\n\n```java\nclass Solution {\n    public boolean isIsomorphic(String s, String t) {\n        char[] sChars = s.toCharArray();\n        char[] tChars = t.toCharArray();\n\n        int length = sChars.length;\n        if(length != tChars.length) return false;\n\n        char[] sm = new char[256];\n        char[] tm = new char[256];\n\n        for(int i=0; i<length; i++){\n            char sc = sChars[i];\n            char tc = tChars[i];\n            if(sm[sc] == 0 && tm[tc] == 0){\n                sm[sc] = tc;\n                tm[tc] = sc;\n            }else{\n                if(sm[sc] != tc || tm[tc] != sc){\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\n```\n\n\n\n### 242. Valid Anagram (Easy) [@](https://leetcode.com/problems/valid-anagram/)\n\n> Given two strings *s* and *t* , write a function to determine if *t* is an anagram of *s*.\n>\n> **Example 1:**\n>\n> ```\n> Input: s = \"anagram\", t = \"nagaram\"\n> Output: true\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: s = \"rat\", t = \"car\"\n> Output: false\n> ```\n>\n> **Note:**\n> You may assume the string contains only lowercase alphabets.\n>\n> **Follow up:**\n> What if the inputs contain unicode characters? How would you adapt your solution to such case?\n\nSolution 1 Sort\n\n- 排序，比较\n\n```java\nclass Solution {\n    public boolean isAnagram(String s, String t) {\n\t\tchar[] sArr = s.toCharArray();\n\t\tchar[] tArr = t.toCharArray();\n \n\t\tArrays.sort(sArr);\n\t\tArrays.sort(tArr);\n \n\t\treturn String.valueOf(sArr).equals(String.valueOf(tArr));\n    }\n}\n```\n\nSolution 2 Array\n\n```java\nclass Solution {\n    public boolean isAnagram(String s, String t) {\n        if (s.length() != t.length()) return false;\n        \n        int[] count = new int[26];\n        for (int i = 0; i < s.length(); i++) {\n            char sChar = s.charAt(i);\n            char tChar = t.charAt(i);\n            \n            count[sChar-'a'] ++;\n            count[tChar-'a'] --;\n        }\n       \t//遍历整个count数组\n        for (int i = 0; i < count.length; i++) {\n            if (count[i] != 0)\n                return false;\n        }\n        return true;\n    }\n}\n```\n\n\n\n### 290. Word Pattern (Easy) [@](https://leetcode.com/problems/word-pattern/submissions/)\n\n> Given a `pattern` and a string `str`, find if `str` follows the same pattern.\n>\n> Here **follow** means a full match, such that there is a bijection between a letter in `pattern` and a **non-empty** word in `str`.\n>\n> **Example 1:**\n>\n> ```\n> Input: pattern = \"abba\", str = \"dog cat cat dog\"\n> Output: true\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input:pattern = \"abba\", str = \"dog cat cat fish\"\n> Output: false\n> ```\n>\n> **Example 3:**\n>\n> ```\n> Input: pattern = \"aaaa\", str = \"dog cat cat dog\"\n> Output: false\n> ```\n>\n> **Example 4:**\n>\n> ```\n> Input: pattern = \"abba\", str = \"dog dog dog dog\"\n> Output: false\n> ```\n>\n> **Notes:**\n> You may assume `pattern` contains only lowercase letters, and `str` contains lowercase letters that may be separated by a single space.\n\nSolution--Improvement of P205 Solution 1\n\n- 由于字符串比较需要转换，所以用字符串做键，模式字符作为值\n\n```java\nclass Solution {\n    public boolean wordPattern(String pattern, String str) {\n        String[] Strs = str.split(\" \");\n        char[] p = pattern.toCharArray();\n        if (Strs.length != p.length) return false;\n        \n        HashMap<String, Character> map = new HashMap<>();\n        Set<Character> set = new HashSet<>();\n        for (int i = 0; i < p.length; i++) {\n            \n            if(!map.containsKey(Strs[i])) {//no mapped\n                if (set.contains(p[i])) {\n                    return false;\n                }else {\n                    map.put(Strs[i], p[i]);\n                    set.add(p[i]);\n                }\n            }else {//mapped\n                if (map.get(Strs[i]) != p[i]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\n```\n\n\n\n### 316. Remove Duplicate Letters (Hard) [@](https://leetcode.com/problems/remove-duplicate-letters/submissions/)\n\n> Given a string which contains only lowercase letters, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.\n>\n> **Example 1:**\n>\n> ```\n> Input: \"bcabc\"\n> Output: \"abc\"\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: \"cbacdcbc\"\n> Output: \"acdb\"\n> ```\n\nSolution 1 Stack\n\n思路：每个字符必须出现一次，当这个字符只有一次机会的时候必须添加到字符串结尾，反之，如果后面还有则可以把优先级高的先放进来。\n步骤：\n\n1. 统计s中字符最后位置\n\n2. 如果当前字符已经出现在stack中则跳过\n\n3. 如果当前字符不在栈里：\n\n   a. 若当前字符char小与栈顶元素，且栈顶元素有剩余 =》栈顶出栈 并 标记栈顶元素不在栈中（重复该操作直到不满足条件或栈为空）\n\n   b. 当前字符char入栈，并标记char在栈中\n\n```java\nclass Solution {\n    public String removeDuplicateLetters(String s) {\n        int len = s.length();\n        if (len < 2) return s;\n        \n        boolean[] visited = new boolean[26];\n        int[] lastPos = new int[26]; // 1\n        \n        for (int i = 0; i < len; i++) {\n            lastPos[s.charAt(i) - 'a'] = i;\n        }\n        \n        Stack<Character> stack = new Stack<>();\n        for (int i = 0; i < len; i++) {\n            char cur = s.charAt(i);\n            // 2\n            if (visited[cur - 'a']) continue;\n            // 3.a\n            while (!stack.isEmpty() && stack.peek() > cur && lastPos[stack.peek() - 'a'] > i) {\n                visited[stack.pop() - 'a'] = false;\n            }\n            // 3.b\n            stack.add(cur);\n            visited[cur - 'a'] = true;\n        }\n        \n        StringBuilder str = new StringBuilder();\n        while(!stack.isEmpty()) {\n            str.insert(0, stack.pop());\n        }\n        return str.toString();\n    }\n}\n```\n\nSolution 2 Array\n\n- 思路和stack一样但是不需要用到stack\n\n```java\nclass Solution {\n    public String removeDuplicateLetters(String s) {\n        int[] count = new int[26];\n        boolean[] visited = new boolean[26];\n        char[] charArr = s.toCharArray();\n        \n        for(char c : charArr) {\n            count[c - 'a']++;\n        }\n        \n        int i =0;\n        for(char c : charArr) {\n            count[c - 'a']--;\n            if(visited[c- 'a']) continue;\n            while(i >0 && charArr[i-1] >= c && count[charArr[i-1]-'a']>0){\n                visited[charArr[i-1]-'a'] = false;\n                i--;\n            }\n            charArr[i] = c;\n            visited[c -'a'] = true;\n            i++;\n        }\n        return new String(charArr).substring(0,i);\n    }\n}\n```\n\n\n\n### 344. Reverse String (Easy) [@](https://leetcode.com/problems/reverse-string/)\n\n> Write a function that reverses a string. The input string is given as an array of characters `char[]`.\n>\n> Do not allocate extra space for another array, you must do this by **modifying the input array [in-place](https://en.wikipedia.org/wiki/In-place_algorithm)** with O(1) extra memory.\n>\n> You may assume all the characters consist of [printable ascii characters](https://en.wikipedia.org/wiki/ASCII#Printable_characters).\n>\n> \n>\n> **Example 1:**\n>\n> ```\n> Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\n> Output: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\n> Output: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]\n> ```\n\nSolution Swap\n\n```java\nclass Solution {\n    public void reverseString(char[] s) {\n        if (s.length == 0 || s == null) return;\n        for (int i = 0; i < s.length/2; i++) {\n            swap(s, i, s.length-i-1);\n        }\n    }\n    private void swap(char[] s, int i, int j) {\n        char temp = s[i];\n        s[i] = s[j];\n        s[j] = temp;\n    }\n```\n\n\n\n### 345. Reverse Vowels of a String (Easy) [@](https://leetcode.com/problems/reverse-vowels-of-a-string/)\n\n> Write a function that takes a string as input and reverse only the vowels of a string.\n>\n> **Example 1:**\n>\n> ```\n> Input: \"hello\"\n> Output: \"holle\"\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: \"leetcode\"\n> Output: \"leotcede\"\n> ```\n>\n> **Note:**\n> The vowels does not include the letter \"y\".\n\nSolution \n\n```java\nclass Solution {\n    public String reverseVowels(String s) {\n        char[] arr = s.toCharArray();\n        int left =0;\n        int right =arr.length-1;\n         \n        while(left<right)\n        {\n            while(!isVowel(s.charAt(left))&&left<right)\n                left++;\n            while(!isVowel(s.charAt(right))&&left<right)\n                right--;\n            swap(left,right,arr);\n            left++;\n            right--;\n        }\n        return new String(arr);\n         \n    }\n     \n    public boolean isVowel(char c)\n    {\n        if(c=='a'||c=='e'||c=='i'||c=='o'||c=='u')\n            return true;\n        if(c=='A'||c=='E'||c=='I'||c=='O'||c=='U')\n            return true;\n        return false;\n    }\n     \n    public void swap(int i,int j,char[] arr)\n    {\n        char tmp = arr[i];\n        arr[i] =arr[j];\n        arr[j]=tmp;\n    }\n}\n```\n\n\n\n### 383. Ransom Note (Easy) [@](https://leetcode.com/problems/ransom-note/)\n\n> Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false.\n>\n> Each letter in the magazine string can only be used once in your ransom note.\n>\n> **Note:**\n> You may assume that both strings contain only lowercase letters.\n>\n> ```\n> canConstruct(\"a\", \"b\") -> false\n> canConstruct(\"aa\", \"ab\") -> false\n> canConstruct(\"aa\", \"aab\") -> true\n> ```\n\nSolution 1 Hash Map\n\n```java\nclass Solution {\n    public boolean canConstruct(String ransomNote, String magazine) {\n        //generate hash map of magazine\n        HashMap<Character, Integer> map = new HashMap<>();\n        for (int i = 0; i < magazine.length(); i++) {\n            char c = magazine.charAt(i);\n            map.put(c, map.getOrDefault(c, 0) + 1);\n        }\n        //update the num of characters in map\n        for (int i = 0; i < ransomNote.length(); i++) {\n            char c = ransomNote.charAt(i);\n            if (!map.containsKey(c))\n                return false;\n            map.put(c, map.get(c)-1);\n            if (map.get(c) < 0)\n                return false;\n        }\n        return true;\n    }\n}\n```\n\nSolution 2 String to Array\n\n- 字符转化为数字对应\n\n```java\nclass Solution {\n    public boolean canConstruct(String ransomNote, String magazine) {\n        int count[] = new int[26];\n        \n        for(char ch: magazine.toCharArray()) {\n            count[ch - 'a']++;\n        }\n        \n        for(char ch: ransomNote.toCharArray()) {\n            if(count[ch - 'a'] == 0) {\n                return false;\n            }\n            count[ch - 'a']--;\n        }\n        return true;\n    }\n}\n```\n\nSolution 3\n\n```java\nclass Solution {\n    public boolean canConstruct(String ransomNote, String magazine) {\n        //若magazine比ransomNote短则一定不可能\n        if (magazine.length() < ransomNote.length()) return false;\n        char[] r = ransomNote.toCharArray();\n\n        int[] list = new int[26];\n        int idx = 0;\n        for (char c : r) {\n            //判断mag中是否还有c\n            //public int indexOf(int char, int fromIndex)\n            idx = magazine.indexOf(c, list[c - 'a']);\n            if (idx < 0) {\n                return false;\n            }\n            //使用过之后向后移动idx\n            list[c - 'a'] = idx + 1;\n        }\n        return true;\n    }\n}\n```\n\n\n\n### 387. First Unique Character in a String (Easy)  [@](https://leetcode.com/problems/first-unique-character-in-a-string/)\n\n> Given a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1.\n>\n> **Examples:**\n>\n> ```\n> s = \"leetcode\"\n> return 0.\n> \n> s = \"loveleetcode\",\n> return 2.\n> ```\n>\n> \n>\n> **Note:** You may assume the string contain only lowercase letters.\n\nSolution Hash Map\n\n```java\nclass Solution {\n    public int firstUniqChar(String s) {\n        HashMap<Character, Integer> map = new HashMap<>();\n        //generate and update hashmap\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            map.put(c, map.getOrDefault(c, 0) + 1);\n        }\n        //traverse the map\n        for (int i = 0; i < s.length(); i++) {\n            if (map.get(s.charAt(i)) == 1)\n                return i;\n        }\n        return -1;\n    }\n}\n```\n\n\n\n## Array\n\n### 54. Spiral Matrix (Medium) [@](https://leetcode.com/problems/spiral-matrix/)\n\n> Given a matrix of *m* x *n* elements (*m* rows, *n* columns), return all elements of the matrix in spiral order.\n>\n> **Example 1:**\n>\n> ```\n> Input:\n> [\n> [ 1, 2, 3 ],\n> [ 4, 5, 6 ],\n> [ 7, 8, 9 ]\n> ]\n> Output: [1,2,3,6,9,8,7,4,5]\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input:\n> [\n> [1, 2, 3, 4],\n> [5, 6, 7, 8],\n> [9,10,11,12]\n> ]\n> Output: [1,2,3,4,8,12,11,10,9,5,6,7]\n> ```\n\nSolution 1 Simulation\n```java\nclass Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        List<Integer> res = new ArrayList();\n        if (matrix == null || matrix.length == 0) return res;\n        int R = matrix.length, C = matrix[0].length;\n        boolean[][] visited = new boolean[R][C];\n        int[] dr = {0, 1, 0, -1};\n        int[] dc = {1, 0, -1, 0};\n        int r = 0, c = 0, di = 0;\n        for (int i = 0; i < R*C; i++) {\n            res.add(matrix[r][c]);\n            visited[r][c] = true;\n            int cur_c = c + dc[di];\n            int cur_r = r + dr[di];\n            if (cur_c >= 0 && cur_c < C && cur_r >= 0 && cur_r < R && !visited[cur_r][cur_c]) {\n                c = cur_c;\n                r = cur_r;\n            }else {\n                di = (di + 1) % 4;\n                c += dc[di];\n                r += dr[di];\n            }\n        }\n        return res;\n    }\n}\n```\n\nSolution 2 Layer by Layer\n- For each outer layer, we want to iterate through its elements in clockwise order starting from the top left corner. Suppose the current outer layer has top-left coordinates (r1, c1) and bottom-right coordinates (r2, c2).\n- top : c from c1 ...... c2\n- right : r from r1+1 ...... r2\n- bottom : c from c2-1 ...... c1+1\n- left : r from r2 ...... r1-1\n```java\nclass Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        List<Integer> res = new ArrayList();\n        if (matrix == null || matrix.length == 0) return res;\n        int r1 = 0, r2 = matrix.length - 1;\n        int c1 = 0, c2 = matrix[0].length - 1;\n        while (r1 <= r2 && c1 <= c2) {\n            for (int c = c1; c <= c2; c++) res.add(matrix[r1][c]);\n            for (int r = r1+1; r <= r2; r++) res.add(matrix[r][c2]);\n            if (r1 < r2 && c1 < c2) {\n                for (int c = c2 - 1; c > c1; c--) res.add(matrix[r2][c]);\n                for (int r = r2; r > r1; r--) res.add(matrix[r][c1]);\n            }\n            //move top-left and bottom-right point\n            r1++;\n            c1++;\n            r2--;\n            c2--;\n        }\n        return res;\n    }\n}\n```\n\n### 56. Merge Intervals (Medium) [@](https://leetcode.com/problems/merge-intervals/)\n\n> Given a collection of intervals, merge all overlapping intervals.\n>\n> **Example 1:**\n>\n> ```\n> Input: [[1,3],[2,6],[8,10],[15,18]]\n> Output: [[1,6],[8,10],[15,18]]\n> Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: [[1,4],[4,5]]\n> Output: [[1,5]]\n> Explanation: Intervals [1,4] and [4,5] are considered overlapping.\n> ```\n>\n> **NOTE:** input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.\n\nSolution Sort + Compare\n\n- 按照start排序，然后相邻之间比较\n- [Lambda表达式](https://blog.csdn.net/wqh8522/article/details/79745350)\n```java\nclass Solution {\n    public int[][] merge(int[][] intervals) {\n        if (intervals.length <= 1) return intervals;\n        //sorted by start\n        Arrays.sort(intervals,(i1, i2) -> Integer.compare(i1[0], i2[0]));\n        \n        List<int[]> res = new ArrayList<>();\n        int[] newInterval = intervals[0];\n        res.add(newInterval);\n        for (int[] interval : intervals) {\n            //前一个右界大于等于后一个左界\n            if (newInterval[1] >= interval[0]) {\n                newInterval[1] = Math.max(newInterval[1], interval[1]);\n            }else {\n                newInterval = interval;\n                res.add(newInterval);\n            }\n        }\n        return res.toArray(new int[res.size()][]);\n    }\n}\n```\n\n### 66. Plus One (Easy) [@](https://leetcode.com/problems/plus-one/)\n\n> Given a **non-empty** array of digits representing a non-negative integer, plus one to the integer.\n>\n> The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.\n>\n> You may assume the integer does not contain any leading zero, except the number 0 itself.\n>\n> **Example 1:**\n>\n> ```\n> Input: [1,2,3]\n> Output: [1,2,4]\n> Explanation: The array represents the integer 123.\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: [4,3,2,1]\n> Output: [4,3,2,2]\n> Explanation: The array represents the integer 4321.\n> ```\n\nSolution\n\n```java\nclass Solution {\n    public int[] plusOne(int[] digits) {\n        for (int i = digits.length - 1; i >= 0; i--) {\n            digits[i]++;\n            digits[i] %= 10;\n            //若进位则继续遍历，若不进位则直接返回\n            if (digits[i] != 0) return digits;\n        }\n        //only 99,999...need one more digit\n        digits = new int[digits.length+1];\n        digits[0] = 1;\n        return digits;\n    }\n}\n```\n\n### 73. Set Matrix Zeros (Medium) [@](https://leetcode.com/problems/set-matrix-zeroes/)\n\n> Given a *m* x *n* matrix, if an element is 0, set its entire row and column to 0. Do it [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm).\n>\n> **Example 1:**\n>\n> ```\n> Input: \n> [\n> [1,1,1],\n> [1,0,1],\n> [1,1,1]\n> ]\n> Output: \n> [\n> [1,0,1],\n> [0,0,0],\n> [1,0,1]\n> ]\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: \n> [\n> [0,1,2,0],\n> [3,4,5,2],\n> [1,3,1,5]\n> ]\n> Output: \n> [\n> [0,0,0,0],\n> [0,4,5,0],\n> [0,3,1,0]\n> ]\n> ```\n>\n> **Follow up:**\n>\n> - A straight forward solution using O(*m**n*) space is probably a bad idea.\n> - A simple improvement uses O(*m* + *n*) space, but still not the best solution.\n> - Could you devise a constant space solution?\n\nSolution \n- Use first row and first column to mark if the row/col needs to be set to 0. (Postpone the change)\n```java\nclass Solution {\n  public void setZeroes(int[][] matrix) {\n    Boolean isCol = false;\n    int R = matrix.length;\n    int C = matrix[0].length;\n\n    for (int i = 0; i < R; i++) {\n\n      // Since first cell for both first row and first column is the same i.e. matrix[0][0]\n      // We can use an additional variable for either the first row/column.\n      // For this solution we are using an additional variable for the first column\n      // and using matrix[0][0] for the first row.\n      if (matrix[i][0] == 0) {\n        isCol = true;\n      }\n\n      for (int j = 1; j < C; j++) {\n        // If an element is zero, we set the first element of the corresponding row and column to 0\n        if (matrix[i][j] == 0) {\n          matrix[0][j] = 0;\n          matrix[i][0] = 0;\n        }\n      }\n    }\n\n    // Iterate over the array once again and using the first row and first column, update the elements.\n    for (int i = 1; i < R; i++) {\n      for (int j = 1; j < C; j++) {\n        if (matrix[i][0] == 0 || matrix[0][j] == 0) {\n          matrix[i][j] = 0;\n        }\n      }\n    }\n\n    // See if the first row needs to be set to zero as well\n    if (matrix[0][0] == 0) {\n      for (int j = 0; j < C; j++) {\n        matrix[0][j] = 0;\n      }\n    }\n\n    // See if the first column needs to be set to zero as well\n    if (isCol) {\n      for (int i = 0; i < R; i++) {\n        matrix[i][0] = 0;\n      }\n    }\n  }\n}\n```\n### 75. Sort Colors (Medium) [@](https://leetcode.com/problems/sort-colors/)\n\n> Given an array with *n* objects colored red, white or blue, sort them **[in-place](https://en.wikipedia.org/wiki/In-place_algorithm)** so that objects of the same color are adjacent, with the colors in the order red, white and blue.\n>\n> Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.\n>\n> **Note:** You are not suppose to use the library's sort function for this problem.\n>\n> **Example:**\n>\n> ```\n> Input: [2,0,2,1,1,0]\n> Output: [0,0,1,1,2,2]\n> ```\n>\n> **Follow up:**\n>\n> - A rather straight forward solution is a two-pass algorithm using counting sort.\n>   First, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's.\n> - Could you come up with a one-pass algorithm using only constant space?\n\nSolution\n\n- red replace forward, blue replace backward \n```java\nclass Solution {\n    public void sortColors(int[] nums) {\n        int red = 0, blue = nums.length - 1;\n        int i = 0;\n        while (red <= blue && i <= blue) {\n            if (nums[i] == 0) {\n                swap(nums, red, i);\n                red++;\n            }else if (nums[i] == 2) {\n                swap(nums, i, blue);\n                blue--;\n                i--; //re-evaluate current element\n            }\n            i++;\n        }\n        return;\n    }\n    private void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}\n```\n\n### 88. Merge Sorted Array (Easy) [@](https://leetcode.com/problems/merge-sorted-array/)\n> Given two sorted integer arrays *nums1* and *nums2*, merge *nums2* into *nums1* as one sorted array.\n>\n> **Note:**\n>\n> - The number of elements initialized in *nums1* and *nums2* are *m* and *n* respectively.\n> - You may assume that *nums1* has enough space (size that is greater or equal to *m* + *n*) to hold additional elements from *nums2*.\n>\n> **Example:**\n>\n> ```\n> Input:\n> nums1 = [1,2,3,0,0,0], m = 3\n> nums2 = [2,5,6],       n = 3\n> \n> Output: [1,2,2,3,5,6]\n> ```\n\nSolution\n\n- 从后向前扫描，添加大的元素\n```java\nclass Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        //two pointer for nums1 and nums2\n        int ptr1 = m - 1;\n        int ptr2 = n - 1;\n        //pointer for insert position\n        int p = m + n - 1;\n        //compare back forward\n        while (ptr1 >= 0 && ptr2 >= 0) {\n            if (nums1[ptr1] > nums2[ptr2]) {\n                nums1[p--] = nums1[ptr1--];\n            }else {\n                nums1[p--] = nums2[ptr2--];\n            }\n        }\n        //add remaining nums in nums2\n        //public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)\n        System.arraycopy(nums2, 0, nums1, 0, ptr2 + 1);\n    }\n}\n```\n\n### 118. Pascal‘s Triangle (Easy) [@](https://leetcode.com/problems/pascals-triangle/)\n\n> Given a non-negative integer *numRows*, generate the first *numRows* of Pascal's triangle.\n>\n> In Pascal's triangle, each number is the sum of the two numbers directly above it.\n>\n> **Example:**\n>\n> ```\n> Input: 5\n> Output:\n> [\n>   [1],\n>  [1,1],\n> [1,2,1],\n> [1,3,3,1],\n> [1,4,6,4,1]\n> ]\n> ```\n\nSolution DP\n\n```java\nclass Solution {\n    public List<List<Integer>> generate(int numRows) {\n        List<List<Integer>> triangle = new ArrayList<List<Integer>>();\n\n        // First base case; if user requests zero rows, they get zero rows.\n        if (numRows == 0) {\n            return triangle;\n        }\n\n        // Second base case; first row is always [1].\n        triangle.add(new ArrayList<>());\n        triangle.get(0).add(1);\n\n        for (int rowNum = 1; rowNum < numRows; rowNum++) {\n            List<Integer> row = new ArrayList<>(Integer);\n            List<Integer> prevRow = triangle.get(rowNum-1);\n\n            // The first row element is always 1.\n            row.add(1);\n\n            // Each triangle element (other than the first and last of each row)\n            // is equal to the sum of the elements above-and-to-the-left and\n            // above-and-to-the-right.\n            for (int j = 1; j < rowNum; j++) {\n                row.add(prevRow.get(j-1) + prevRow.get(j));\n            }\n\n            // The last row element is always 1.\n            row.add(1);\n\n            triangle.add(row);\n        }\n\n        return triangle;\n    }\n}\n```\n\n### 136. Single Number (Easy) [@](https://leetcode.com/problems/single-number/)\n\n> Given a **non-empty** array of integers, every element appears *twice* except for one. Find that single one.\n>\n> **Note:**\n>\n> Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\n>\n> **Example 1:**\n>\n> ```\n> Input: [2,2,1]\n> Output: 1\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: [4,1,2,1,2]\n> Output: 4\n> ```\n\nSolution 1 Hash Map\n\n```java\nclass Solution {\n    public int singleNumber(int[] nums) {\n        HashMap<Integer, Integer> map = new HashMap<>();\n        for (int num : nums) {\n            if (map.containsKey(num)) {\n                map.remove(num);\n            }else {\n                map.put(num, 1);\n            }\n        }\n        return map.entrySet().iterator().next().getKey();\n    }\n}\n```\n\nSolution 2 Math\n- 所有不重复数字的两倍乘总和 - 原数组总和 = 出现一次的数字\n```java\nclass Solution {\n    public int singleNumber(int[] nums) {\n        Set<Integer> set = new HashSet<>();\n        \n        int arrSum = 0;\n        for (int num : nums) {\n            set.add(num);\n            arrSum += num;\n        }\n        \n        int doubleSum = 0;\n        for (int num : set) {\n            doubleSum += 2*num;\n        }\n        return doubleSum - arrSum;\n    }\n}\n```\n\nSolution 3 Bit Manipulation\n- 异或XOR\n- 对所有数字进行异或，最后得出单个的数\n- 异或性质\n\t- 交换律: A XOR B = B XOR A\n\t- 结合律: A XOR B XOR C = A XOR (B XOR C) = (A XOR B) XOR C\n\t- 自反性: A XOR B XOR B = A XOR 0 = A\n```java\nclass Solution {\n    public int singleNumber(int[] nums) {\n        int res = 0;\n        for (int num : nums) {\n            res ^= num;\n        }\n        return res;\n    }\n}\n```\n\n### 169. Majority Element (Easy) [@](https://leetcode.com/problems/majority-element/)\n\n> Given an array of size *n*, find the majority element. The majority element is the element that appears **more than** `⌊ n/2 ⌋` times.\n>\n> You may assume that the array is non-empty and the majority element always exist in the array.\n>\n> **Example 1:**\n>\n> ```\n> Input: [3,2,3]\n> Output: 3\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: [2,2,1,1,1,2,2]\n> Output: 2\n> ```\n\nSolution 1 HashMap\n\n```java\nclass Solution {\n    public int majorityElement(int[] nums) {\n        HashMap<Integer, Integer> map = new HashMap<>();\n        int N = nums.length;\n        for (int i = 0; i < N; i++) {\n            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\n        }\n        int res = 0;\n        for (Map.Entry<Integer,Integer> s : map.entrySet()) {\n            if (s.getValue() > N/2) {\n                res = s.getKey();\n                break;\n            }\n        }\n        return res;\n    }\n}\n```\n\nSolution 2 Sort\n\n```java\nclass Solution {\n    public int majorityElement(int[] nums) {\n        Arrays.sort(nums);\n        return nums[nums.length/2];\n    }\n}\n```\nSolution 3 摩尔投票法\n\n- 首先假定数组头元素即为众数，设定计数器为1，从第二个数开始遍历，如果和头元素相同则计数器加1，如果不相同则减1，之后判断计数器是否为0，如果不为0则继续下一步循环，如果为0则将众数指针指向当前元素，以此类推，最后众数指针指向的元素即为众数，时间复杂度～O(n)，空间复杂度～O(1)\n\n```java\nclass Solution {\n    public int majorityElement(int[] nums) {\n        int res = nums[0];\n        int count = 1;\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i] == res) count++;\n            else {\n                count--;\n                if (count == 0) {\n                    res = nums[i];\n                    count = 1;\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n### 189. Rotate Array (Easy) [@](https://leetcode.com/problems/rotate-array/)\n\n> Given an array, rotate the array to the right by *k* steps, where *k* is non-negative.\n>\n> **Example 1:**\n>\n> ```\n> Input: [1,2,3,4,5,6,7] and k = 3\n> Output: [5,6,7,1,2,3,4]\n> Explanation:\n> rotate 1 steps to the right: [7,1,2,3,4,5,6]\n> rotate 2 steps to the right: [6,7,1,2,3,4,5]\n> rotate 3 steps to the right: [5,6,7,1,2,3,4]\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: [-1,-100,3,99] and k = 2\n> Output: [3,99,-1,-100]\n> Explanation: \n> rotate 1 steps to the right: [99,-1,-100,3]\n> rotate 2 steps to the right: [3,99,-1,-100]\n> ```\n>\n> **Note:**\n>\n> - Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.\n> - Could you do it in-place with O(1) extra space?\n\nSolution 1 Extra Array\n\n```java\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        int N = nums.length;\n        int[] temp = new int[N];\n        for (int i = 0; i < N; i++) {\n            temp[(i+k) % N] = nums[i];\n        }\n        for (int i = 0; i < N; i++) {\n            nums[i] = temp[i];\n        }\n    }\n}\n```\n\nSolution 2 Cyclic Replacements\n\n- [Leetcode CN](https://leetcode-cn.com/problems/rotate-array/solution/xuan-zhuan-shu-zu-by-leetcode/)\n\n```java\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        int count = 0;\n        for (int start = 0; count < nums.length; start++) {\n            int cur = start;\n            int prev = nums[cur];\n            do {\n                int next = (cur + k) % nums.length;\n                int temp = nums[next];\n                nums[next] = prev;\n                prev = temp;\n                cur = next;\n                count++;\n            }while (start != cur);\n        }\n    }\n}\n```\nSolution 3 Reverse\n- 先反转所有，再分别反转前k个位置和后面所有\n```java\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        k %= nums.length;\n        reverse(nums, 0, nums.length - 1);\n        reverse(nums, 0, k - 1);\n        reverse(nums, k, nums.length - 1);\n    }\n    private void reverse(int[] nums, int start, int end) {\n        while (start < end) {\n            int temp = nums[start];\n            nums[start] = nums[end];\n            nums[end] = temp;\n            start++;\n            end--;\n        }\n    }\n}\n```\n\n\n## Linked List\n\n### 138. Copy List with Random Pointer (Medium) [@](https://leetcode.com/problems/copy-list-with-random-pointer/)\n\n> A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.\n>\n> Return a [**deep copy**](https://en.wikipedia.org/wiki/Object_copying#Deep_copy) of the list.\n>\n> The Linked List is represented in the input/output as a list of `n` nodes. Each node is represented as a pair of `[val, random_index]` where:\n>\n> - `val`: an integer representing `Node.val`\n> - `random_index`: the index of the node (range from `0` to `n-1`) where random pointer points to, or `null` if it does not point to any node.\n>\n> **Example 1:**\n>\n> ![img](https://assets.leetcode.com/uploads/2019/12/18/e1.png)\n>\n> ```\n> Input: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\n> Output: [[7,null],[13,0],[11,4],[10,2],[1,0]]\n> ```\n>\n> **Example 2:**\n>\n> ![img](https://assets.leetcode.com/uploads/2019/12/18/e2.png)\n>\n> ```\n> Input: head = [[1,1],[2,1]]\n> Output: [[1,1],[2,1]]\n> ```\n>\n> **Example 3:**\n>\n> **![img](https://assets.leetcode.com/uploads/2019/12/18/e3.png)**\n>\n> ```\n> Input: head = [[3,null],[3,0],[3,null]]\n> Output: [[3,null],[3,0],[3,null]]\n> ```\n>\n> **Example 4:**\n>\n> ```\n> Input: head = []\n> Output: []\n> Explanation: Given linked list is empty (null pointer), so return null.\n> ```\n\nSolution 1 HashMap + 2 iterations \n\n第一种方法，就是使用HashMap来坐，HashMap的key存原始pointer，value存新的pointer。\n\n- 第一遍，先不copy random的值，只copy数值建立好新的链表。并把新旧pointer存在HashMap中。\n- 第二遍，遍历旧表，复制random的值，因为第一遍已经把链表复制好了并且也存在HashMap里了，所以只需从HashMap中，把当前旧的node.random作为key值，得到新的value的值，并把其赋给新node.random就好。\n\n```java\n/*\n// Definition for a Node.\nclass Node {\n    int val;\n    Node next;\n    Node random;\n\n    public Node(int val) {\n        this.val = val;\n        this.next = null;\n        this.random = null;\n    }\n}\n*/\nclass Solution {\n    public Node copyRandomList(Node head) {\n        if (head == null) return null;\n        HashMap<Node, Node> map = new HashMap<>();\n        Node newHead = new Node(head.val);\n        map.put(head, newHead);\n        Node oldPtr = head.next;\n        Node newPtr = newHead;\n        //first iterate the linked list\n        while (oldPtr != null) {\n            //link next node\n            Node newNode = new Node(oldPtr.val);\n            newPtr.next = newNode;\n            //update hashmap\n            map.put(oldPtr, newNode);\n            \n            oldPtr = oldPtr.next;\n            newPtr = newPtr.next;\n        }\n        \n        oldPtr = head;\n        newPtr = newHead;\n        //second iterate the linked list -> update random ptr\n        while(oldPtr != null) {\n            //update random ptr of new list\n            newPtr.random = map.get(oldPtr.random);\n            \n            oldPtr = oldPtr.next;\n            newPtr = newPtr.next;\n        }\n        \n        return newHead;\n    }\n}\n```\nSolution 2 3-iteration\n\n第二种方法不使用HashMap来做，使空间复杂度降为O(1)，不过需要3次遍历list，时间复杂度为O(3n)=O(n)。\n\n- 第一遍，对每个node进行复制，并插入其原始node的后面，新旧交替，变成重复链表。如：原始：1->2->3->null，复制后：1->1->2->2->3->3->null\n- 第二遍，遍历每个旧node，把旧node的random的复制给新node的random，因为链表已经是新旧交替的。所以复制方法为：**node.next.random = node.random.next** 前面是说旧node的next的random，就是新node的random，后面是旧node的random的next，正好是新node，是从旧random复制来的。\n- 第三遍，则是把新旧两个表拆开，返回新的表即可。\n\n```java\n/*\n// Definition for a Node.\nclass Node {\n    int val;\n    Node next;\n    Node random;\n\n    public Node(int val) {\n        this.val = val;\n        this.next = null;\n        this.random = null;\n    }\n}\n*/\nclass Solution {\n    public Node copyRandomList(Node head) {\n        if (head == null) return null;\n        Node cur = head;\n        //1st iteration: copy current node and link it to next\n        while (cur != null) {\n            Node newNode = new Node(cur.val);\n            newNode.next = cur.next;\n            cur.next = newNode;\n            \n            cur = newNode.next;\n        }\n        //2ed iteration: update random node\n        cur = head;\n        while (cur != null) {\n            if (cur.random != null) {\n                cur.next.random = cur.random.next;\n            }\n            cur = cur.next.next;\n        }\n        //3rd iteration: \n        cur = head; //point to old node\n        Node newHead = head.next;//initialize new head\n        Node copy = newHead;//point to new node\n        \n        // method 1\n//         while (copy.next != null) {\n//             //old\n//             cur.next = cur.next.next;\n//             cur = cur.next;\n            \n//             //new\n//             copy.next = copy.next.next;\n//             copy = copy.next;\n//         }\n//         cur.next = cur.next.next;\n        \n        //method 2\n        while (cur != null) {\n            copy = cur.next;\n            cur.next = copy.next;\n            if (copy.next != null) {\n                copy.next = copy.next.next;\n            }\n            cur = cur.next;\n        }\n        return newHead;\n    }\n}\n```\n\n### 141. Linked List Cycle (Easy) [@](https://leetcode.com/problems/linked-list-cycle/)\n\n> Given a linked list, determine if it has a cycle in it.\n>\n> To represent a cycle in the given linked list, we use an integer `pos` which represents the position (0-indexed) in the linked list where tail connects to. If `pos` is `-1`, then there is no cycle in the linked list.\n>\n> \n>\n> **Example 1:**\n>\n> ```\n> Input: head = [3,2,0,-4], pos = 1\n> Output: true\n> Explanation: There is a cycle in the linked list, where tail connects to the second node.\n> ```\n>\n> ![img](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png)\n>\n> **Example 2:**\n>\n> ```\n> Input: head = [1,2], pos = 0\n> Output: true\n> Explanation: There is a cycle in the linked list, where tail connects to the first node.\n> ```\n>\n> ![img](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png)\n>\n> **Example 3:**\n>\n> ```\n> Input: head = [1], pos = -1\n> Output: false\n> Explanation: There is no cycle in the linked list.\n> ```\n>\n> ![img](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png)\n>\n> \n>\n> **Follow up:**\n>\n> Can you solve it using *O(1)* (i.e. constant) memory?\n\nSolution 1 HashSet\n\n```java\npublic boolean hasCycle(ListNode head) {\n    Set<ListNode> nodesSeen = new HashSet<>();\n    while (head != null) {\n        if (nodesSeen.contains(head)) {\n            return true;\n        } else {\n            nodesSeen.add(head);\n        }\n        head = head.next;\n    }\n    return false;\n}\n```\n\nSolution 2 Two ptrs\n- if slow and fast ptr meet then it much contains a cycle.\n```java\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n        if (head == null || head.next == null) return false;\n        \n        ListNode slow = head;\n        ListNode fast = head.next;\n        while (slow != fast) {\n            if (fast == null || fast.next == null)\n                return false;\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        return true;\n    }\n}\n```\n### 146. LRU Cache (Medium) [@](https://leetcode.com/problems/lru-cache/)\n\n> Design and implement a data structure for [Least Recently Used (LRU) cache](https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU). It should support the following operations: `get` and `put`.\n>\n> `get(key)` - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.\n> `put(key, value)` - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.\n>\n> The cache is initialized with a **positive** capacity.\n>\n> **Follow up:**\n> Could you do both operations in **O(1)** time complexity?\n>\n> **Example:**\n>\n> ```\n> LRUCache cache = new LRUCache( 2 /* capacity */ );\n> \n> cache.put(1, 1);\n> cache.put(2, 2);\n> cache.get(1);       // returns 1\n> cache.put(3, 3);    // evicts key 2\n> cache.get(2);       // returns -1 (not found)\n> cache.put(4, 4);    // evicts key 1\n> cache.get(1);       // returns -1 (not found)\n> cache.get(3);       // returns 3\n> cache.get(4);       // returns 4\n> ```\n\nSolution 1 LinkedHashMap\n\n- [LinkedHashMap](https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html)\n- LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder)\n- 作为一般规则，默认负载因子（0.75）在时间和空间成本上提供了很好的折衷。较高的值会降低空间开销，但提高查找成本（体现在大多数的HashMap类的操作，包括get和put）。设置初始大小时，应该考虑预计的entry数在map及其负载系数，并且尽量减少rehash操作的次数。如果初始容量大于最大条目数除以负载因子，rehash操作将不会发生。\n\n\n```java\nclass LRUCache extends LinkedHashMap<Integer, Integer>{\n    private int capacity;\n    \n    public LRUCache(int capacity) {\n        super(capacity, 0.75F, true);\n        this.capacity = capacity;\n    }\n    \n    public int get(int key) {\n        return super.getOrDefault(key, -1);\n    }\n    \n    public void put(int key, int value) {\n        super.put(key, value);\n    }\n    \n    @Override\n    protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {\n        return size() > capacity;\n    }\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n```\nSolution 2 Linked List + HashMap (implementation of sol 1)\n\n```java\n\nclass LRUCache {\n    \n    class DLinkedNode {\n        int key;\n        int val;\n        DLinkedNode prev;\n        DLinkedNode next;\n    }\n    \n    private void addNode(DLinkedNode node) {\n        //always add node right after head\n        node.next = head.next;\n        node.prev = head;\n        \n        head.next.prev = node;\n        head.next = node;\n    }\n    \n    private void removeNode(DLinkedNode node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n    \n    private void moveToHead(DLinkedNode node) {\n        removeNode(node);\n        addNode(node);\n    }\n    \n    private DLinkedNode popTail() {\n        DLinkedNode res = tail.prev;\n        removeNode(res);\n        return res;\n    }\n    \n    private HashMap<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();\n    private int size;\n    private int capacity;\n    private DLinkedNode head, tail;\n    \n    public LRUCache(int capacity) {\n        this.size = 0;\n        this.capacity = capacity;\n        \n        head = new DLinkedNode();\n        tail = new DLinkedNode();\n        \n        head.next = tail;\n        tail.prev = head;\n    }\n    \n    public int get(int key) {\n        DLinkedNode node = cache.get(key);\n        \n        if (node == null) \n            return -1;\n        else {\n            //used => move to head\n            moveToHead(node);\n            return node.val;\n        }\n    }\n    \n    public void put(int key, int value) {\n        DLinkedNode node = cache.get(key);\n        \n        if (node == null) {\n            DLinkedNode newNode = new DLinkedNode();\n            newNode.key = key;\n            newNode.val = value;\n            \n            cache.put(key, newNode);//update cache(HashMap)\n            addNode(newNode); //update Linked List\n            \n            size++;\n            \n            if (size > capacity) {\n                //pop tail\n                DLinkedNode tail = popTail();\n                cache.remove(tail.key);\n                size--;\n            }\n        }else {\n            //update val\n            node.val = value;\n            moveToHead(node);\n        }\n    }\n    \n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n```\n\n### 148. Sort List (Medium) [@](https://leetcode.com/problems/sort-list/)\n\n> Sort a linked list in *O*(*n* log *n*) time using constant space complexity.\n>\n> **Example 1:**\n>\n> ```\n> Input: 4->2->1->3\n> Output: 1->2->3->4\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: -1->5->3->4->0\n> Output: -1->0->3->4->5\n> ```\n\nSolution 1 Merge sort\n- 空间复杂度O(logn)， 不符合要求\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode sortList(ListNode head) {\n        if (head == null || head.next == null) return head;\n        \n        //find the mid point\n        ListNode slow = head, fast = head.next;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        //mid = slow\n        ListNode tmp = slow.next;\n        slow.next = null; //cut\n        //divide\n        ListNode left = sortList(head);\n        ListNode right = sortList(tmp);\n        //merge\n        ListNode cur = new ListNode(0);\n        ListNode res = cur;\n        while (left != null && right != null) {\n            if (left.val < right.val) {\n                cur.next = left;\n                left = left.next;\n            }else {\n                cur.next = right;\n                right = right.next;\n            }\n            cur = cur.next;\n        }\n        //add the rest of left or right part\n        cur.next = left != null ? left : right;\n        return res.next;\n    }\n}\n```\nSolution 2 Iteration\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode sortList(ListNode head) {\n        if (head == null || head.next == null) return head;\n        \n        ListNode dummy = new ListNode(-1);\n        dummy.next = head;\n        //len of list\n        int length = 0;\n        while (head != null) {\n            length++;\n            head = head.next;\n        }\n        head = dummy.next;\n        \n        //loop logn times\n        for (int i = 1; i < length; i+= i) {\n            //list was divided into 4 parts:\n            //1. already sorted; 2. left part of list to be sorted;\n            //3. right part of list to be sorted; 4. unsorted part of list\n            ListNode success = dummy;\n            ListNode left = null;\n            ListNode right = null;\n            while (head != null) {\n                left = head;\n                head = cutFromHead(head, i);\n                right = head;\n                head = cutFromHead(head, i);\n                //merge sort left and right, put them after success, and update success\n                success.next = mergeLists(left, right);\n                while (success.next != null) success = success.next;\n            }\n            head = dummy.next;\n        }\n        return dummy.next;\n    }\n    //cut the list from head with n-len and return (n+1)th node\n    private ListNode cutFromHead(ListNode head, int n) {\n        while (head != null && --n > 0) {\n            head = head.next;\n        }\n        \n        if (head == null) return null;\n        \n        ListNode next = head.next;\n        head.next = null; //cut\n        return next;\n    }\n    //merge sort 2 lists\n    private ListNode mergeLists(ListNode left, ListNode right) {\n        if (left == null) return right;\n        if (right == null) return left;\n        \n        ListNode dummy = new ListNode(-1);\n        ListNode cur = dummy;\n        \n        while (left != null && right != null) {\n            if (left.val < right.val) {\n                cur.next = left;\n                left = left.next;\n            }else {\n                cur.next = right;\n                right = right.next;\n            }\n            cur = cur.next;\n        }\n        cur.next = left != null ? left : right;\n        return dummy.next;\n    }\n}\n```\n### 160. Intersection of Two Linked Lists (Easy) [@](https://leetcode.com/problems/intersection-of-two-linked-lists/)\n\n> Write a program to find the node at which the intersection of two singly linked lists begins.\n>\n> For example, the following two linked lists:\n>\n> [![img](https://assets.leetcode.com/uploads/2018/12/13/160_statement.png)](https://assets.leetcode.com/uploads/2018/12/13/160_statement.png)\n>\n> begin to intersect at node c1.\n>\n> \n>\n> **Example 1:**\n>\n> [![img](https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png)\n>\n> ```\n> Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\n> Output: Reference of the node with value = 8\n> Input Explanation: The intersected node's value is 8 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,0,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.\n> ```\n>\n> \n>\n> **Example 2:**\n>\n> [![img](https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png)\n>\n> ```\n> Input: intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n> Output: Reference of the node with value = 2\n> Input Explanation: The intersected node's value is 2 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [0,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.\n> ```\n>\n> \n>\n> **Example 3:**\n>\n> [![img](https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png)\n>\n> ```\n> Input: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n> Output: null\n> Input Explanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.\n> Explanation: The two lists do not intersect, so return null.\n> ```\n>\n> \n>\n> **Notes:**\n>\n> - If the two linked lists have no intersection at all, return `null`.\n> - The linked lists must retain their original structure after the function returns.\n> - You may assume there are no cycles anywhere in the entire linked structure.\n> - Your code should preferably run in O(n) time and use only O(1) memory.\n\nSolution 1 Two round iteration\n- 尾部对齐，找出长度差，长的先走\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        int lenA=0, lenB=0;\n        ListNode A=headA, B=headB;\n        while(A != null){\n            lenA ++;\n            A = A.next;\n        }\n\n        while(B != null) {\n            lenB++;\n            B = B.next;\n        }\n        A = headA;\n        B = headB;\n\n        while(lenA > lenB){\n            A = A.next;\n            lenA --;\n        }\n        while(lenA < lenB){\n            B = B.next;\n            lenB --;\n        }\n\n        while(A != B){\n            A = A.next;\n            B = B.next;\n        }\n\n        return A;\n    }\n}\n```\n\nSolution 2 Two pointer + 环\n- 转化成判断环的问题\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null) return null;\n        \n        ListNode curA = headA;\n        ListNode curB = headB;\n        //将自身最后连接到另一个链表头，若存在intersection则形成环\n        //如果形成环，则curA和curB一定在环的入口相交\n        //若没有形成环，则都到达null\n        while (curA != curB) {\n            curA = curA == null ? headB : curA.next;\n            curB = curB == null ? headA : curB.next;\n        }\n        return curA;\n    }\n}\n```\n\n## Stack\n\n### 150. Evaluate Reverse Polish Notation (Medium) [@](https://leetcode.com/problems/evaluate-reverse-polish-notation/)\n\n> Evaluate the value of an arithmetic expression in [Reverse Polish Notation](http://en.wikipedia.org/wiki/Reverse_Polish_notation).\n>\n> Valid operators are `+`, `-`, `*`, `/`. Each operand may be an integer or another expression.\n>\n> **Note:**\n>\n> - Division between two integers should truncate toward zero.\n> - The given RPN expression is always valid. That means the expression would always evaluate to a result and there won't be any divide by zero operation.\n>\n> **Example 1:**\n>\n> ```\n> Input: [\"2\", \"1\", \"+\", \"3\", \"*\"]\n> Output: 9\n> Explanation: ((2 + 1) * 3) = 9\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: [\"4\", \"13\", \"5\", \"/\", \"+\"]\n> Output: 6\n> Explanation: (4 + (13 / 5)) = 6\n> ```\n>\n> **Example 3:**\n>\n> ```\n> Input: [\"10\", \"6\", \"9\", \"3\", \"+\", \"-11\", \"*\", \"/\", \"*\", \"17\", \"+\", \"5\", \"+\"]\n> Output: 22\n> Explanation: \n>   ((10 * (6 / ((9 + 3) * -11))) + 17) + 5\n> = ((10 * (6 / (12 * -11))) + 17) + 5\n> = ((10 * (6 / -132)) + 17) + 5\n> = ((10 * 0) + 17) + 5\n> = (0 + 17) + 5\n> = 17 + 5\n> = 22\n> ```\n\nSolution 1 Stack\n```java\nclass Solution {\n    public int evalRPN(String[] tokens) {\n        Stack<Integer> stack = new Stack<>();\n        for (String s : tokens) {\n            if (s.equals(\"+\")) {\n                stack.push(stack.pop() + stack.pop());\n            } else if (s.equals(\"-\")) {\n                stack.push(- stack.pop() + stack.pop());\n            } else if (s.equals(\"*\")) {\n                stack.push(stack.pop() * stack.pop());\n            } else if (s.equals(\"/\")) {\n                int dividend = stack.pop();\n                stack.push(stack.pop() / dividend);\n            } else { //normal numbers\n                stack.push(Integer.parseInt(s));\n            }\n        }\n        return stack.pop();\n    }\n}\n```\n\n### 155. Min Stack (Medium) [@](https://leetcode.com/problems/min-stack/submissions/)\n\n> Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n>\n> - push(x) -- Push element x onto stack.\n> - pop() -- Removes the element on top of the stack.\n> - top() -- Get the top element.\n> - getMin() -- Retrieve the minimum element in the stack.\n>\n>  \n>\n> **Example:**\n>\n> ```\n> MinStack minStack = new MinStack();\n> minStack.push(-2);\n> minStack.push(0);\n> minStack.push(-3);\n> minStack.getMin();   --> Returns -3.\n> minStack.pop();\n> minStack.top();      --> Returns 0.\n> minStack.getMin();   --> Returns -2.\n> ```\n\nSolution 1 synchronous data stack and helper stack\n```java\nclass MinStack {\n    \n    private Stack<Integer> data;\n    private Stack<Integer> minElement;\n\n    /** initialize your data structure here. */\n    public MinStack() {\n        data = new Stack<>();\n        minElement = new Stack<>();\n    }\n    \n    public void push(int x) {\n        data.add(x);\n        if (minElement.isEmpty() || minElement.peek() >= x) {\n            minElement.add(x);\n        } else {\n            minElement.add(minElement.peek());\n        }\n    }\n    \n    public void pop() {\n        if (!data.isEmpty()) {\n            data.pop();\n            minElement.pop();\n        }\n    }\n    \n    public int top() {\n        if (!data.isEmpty()) {\n            return data.peek();\n        }\n        throw new RuntimeException(\"stack is empty\");\n    }\n    \n    public int getMin() {\n        if (!minElement.isEmpty()) {\n            return minElement.peek();\n        }\n        throw new RuntimeException(\"stack is empty\");\n    }\n}\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack obj = new MinStack();\n * obj.push(x);\n * obj.pop();\n * int param_3 = obj.top();\n * int param_4 = obj.getMin();\n */\n```\n\nSolution 2 asynchronous \n\n```java\nclass MinStack {\n    \n    private Stack<Integer> data;\n    private Stack<Integer> minElement;\n\n    /** initialize your data structure here. */\n    public MinStack() {\n        data = new Stack<>();\n        minElement = new Stack<>();\n    }\n    \n    // 思路 2：辅助栈和数据栈不同步\n    // 关键 1：辅助栈的元素空的时候，必须放入新进来的数\n    // 关键 2：新来的数小于或者等于辅助栈栈顶元素的时候，才放入（特别注意这里等于要考虑进去）\n    // 关键 3：出栈的时候，辅助栈的栈顶元素等于数据栈的栈顶元素，才出栈，即\"出栈保持同步\"就可以了\n    \n    public void push(int x) {\n        data.add(x);\n        // 辅助栈在必要的时候才增加\n        if (minElement.isEmpty() || minElement.peek() >= x) {\n            minElement.add(x);\n        }\n    }\n    \n    public void pop() {\n        //关键3: 数据栈一定pop\n        if (!data.isEmpty()) {\n            // 注意：声明成 int 类型，这里完成了自动拆箱，从 Integer 转成了 int，因此下面的比较可以使用 \"==\" 运算符\n            // 参考资料：https://www.cnblogs.com/GuoYaxiang/p/6931264.html\n            // 如果把 top 变量声明成 Integer 类型，下面的比较就得使用 equals 方法\n            int top = data.pop();\n            if (top == minElement.peek()) {\n                minElement.pop();\n            }\n        }\n    }\n    \n    public int top() {\n        if (!data.isEmpty()) {\n            return data.peek();\n        }\n        throw new RuntimeException(\"stack is empty\");\n    }\n    \n    public int getMin() {\n        if (!minElement.isEmpty()) {\n            return minElement.peek();\n        }\n        throw new RuntimeException(\"stack is empty\");\n    }\n}\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack obj = new MinStack();\n * obj.push(x);\n * obj.pop();\n * int param_3 = obj.top();\n * int param_4 = obj.getMin();\n */\n```\nSolution 3 Linked List\n\n```java\nclass MinStack {\n    \n    private Node head;\n    \n    private class Node {\n        int val;\n        int min;\n        Node next;\n        \n        Node(int val, int min, Node next) {\n            this.val = val;\n            this.min = min;\n            this.next = next;\n        }\n    }\n    \n    public void push(int x) {\n        if (head == null) {\n            head = new Node(x, x, null);\n        } else {\n            head = new Node(x, Math.min(head.min, x), head);\n        }\n    }\n    \n    public void pop() {\n        head = head.next;\n    }\n    \n    public int top() {\n        return head.val;\n    }\n    \n    public int getMin() {\n        return head.min;\n    }\n}\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack obj = new MinStack();\n * obj.push(x);\n * obj.pop();\n * int param_3 = obj.top();\n * int param_4 = obj.getMin();\n */\n```\n\n## Math\n\n### 172. Factorial Trailing Zeroes (Easy) [@](https://leetcode.com/problems/factorial-trailing-zeroes/)\n\n> Given an integer *n*, return the number of trailing zeroes in *n*!.\n>\n> **Example 1:**\n>\n> ```\n> Input: 3\n> Output: 0\n> Explanation: 3! = 6, no trailing zero.\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: 5\n> Output: 1\n> Explanation: 5! = 120, one trailing zero.\n> ```\n>\n> **Note:** Your solution should be in logarithmic time complexity.\n\nSolution \n\n- 判断n!中有多少个5\n- [Detail](https://leetcode-cn.com/problems/factorial-trailing-zeroes/solution/xiang-xi-tong-su-de-si-lu-fen-xi-by-windliang-3/)\n\n```java\npublic int trailingZeroes(int n) {\n    int count = 0;\n    while (n > 0) {\n        count += n / 5;\n        n = n / 5;\n    }\n    return count;\n}\n```\n### 190. Reverse Bits (Easy) [@](https://leetcode.com/problems/reverse-bits/)\n\n> Reverse bits of a given 32 bits unsigned integer.\n>\n> \n>\n> **Example 1:**\n>\n> ```\n> Input: 00000010100101000001111010011100\n> Output: 00111001011110000010100101000000\n> Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: 11111111111111111111111111111101\n> Output: 10111111111111111111111111111111\n> Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111.\n> ```\n>\n> \n>\n> **Note:**\n>\n> - Note that in some languages such as Java, there is no unsigned integer type. In this case, both input and output will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned.\n> - In Java, the compiler represents the signed integers using [2's complement notation](https://en.wikipedia.org/wiki/Two's_complement). Therefore, in **Example 2** above the input represents the signed integer `-3` and the output represents the signed integer `-1073741825`.\n>\n>  \n>\n> **Follow up**:\n>\n> If this function is called many times, how would you optimize it?\n\nSolution 1 shift\n\n```java\npublic class Solution {\n    // you need treat n as an unsigned value\n    public int reverseBits(int n) {\n        int res = 0;\n        int count = 0;\n        while (count < 32) {\n            res <<= 1; //res is shifted by 1 position to left\n            res |= (n & 1); //just pick the last pos of n to OR res\n            n >>= 1; //n is shifted by 1 pos to right => get rid of the last pos\n            count++;\n        }\n        return res;\n    }\n}\n```\n### 191. Number of 1 Bits (Easy) [@](https://leetcode.com/problems/number-of-1-bits/)\n\n> Write a function that takes an unsigned integer and return the number of '1' bits it has (also known as the [Hamming weight](http://en.wikipedia.org/wiki/Hamming_weight)).\n>\n> \n>\n> **Example 1:**\n>\n> ```\n> Input: 00000000000000000000000000001011\n> Output: 3\n> Explanation: The input binary string 00000000000000000000000000001011 has a total of three '1' bits.\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: 00000000000000000000000010000000\n> Output: 1\n> Explanation: The input binary string 00000000000000000000000010000000 has a total of one '1' bit.\n> ```\n>\n> **Example 3:**\n>\n> ```\n> Input: 11111111111111111111111111111101\n> Output: 31\n> Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one '1' bits.\n> ```\n>\n> \n>\n> **Note:**\n>\n> - Note that in some languages such as Java, there is no unsigned integer type. In this case, the input will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned.\n> - In Java, the compiler represents the signed integers using [2's complement notation](https://en.wikipedia.org/wiki/Two's_complement). Therefore, in **Example 3** above the input represents the signed integer `-3`.\n>\n>  \n>\n> **Follow up**:\n>\n> If this function is called many times, how would you optimize it?\n\nSolution 1\n\n```java\npublic class Solution {\n    // you need to treat n as an unsigned value\n    public int hammingWeight(int n) {\n        int res = 0;\n        for (int i = 0; i < 32; i++) {\n            if ((n & 1) != 0) {\n                res++;\n            }\n            n >>= 1;\n        }\n        return res;\n    }\n}\n```\nSolution 2 Flip\n```java\npublic class Solution {\n    // you need to treat n as an unsigned value\n    public int hammingWeight(int n) {\n        int res = 0;\n        while (n != 0) {\n            res++;\n            //always flip the least-significant 1-bit to 0\n            n &= (n - 1);\n        }\n        return res;\n    }\n}\n```\n\n## Graph\n\n## Sliding Window\n\n## Partition","source":"_posts/Leetcode-Summary.md","raw":"---\ntitle: Leetcode_Summary\ndate: 2020-01-20 13:02:27\ntags: Programming\n---\n\nSources:\n1. summer\n2. 1-50\n3. Top Interview Questions (before 200)\n\n## DFS + memo\n\n### 98. Validate Binary Search Tree (Medium) [@](https://leetcode.com/problems/validate-binary-search-tree/)\n\n> Given a binary tree, determine if it is a valid binary search tree (BST).\n>\n> Assume a BST is defined as follows:\n>\n> - The left subtree of a node contains only nodes with keys **less than** the node's key.\n> - The right subtree of a node contains only nodes with keys **greater than** the node's key.\n> - Both the left and right subtrees must also be binary search trees.\n>\n\n**Solution 1 Recursion**\n\n```java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    private boolean helper(TreeNode node, Integer lower, Integer upper) {\n        if (node == null) return true;\n        \n        int val = node.val;\n        if (lower != null && val <= lower) return false;\n        if (upper != null && val >= upper) return false;\n        \n        if (!helper(node.left, lower, val)) return false;\n        if (!helper(node.right, val, upper)) return false;\n        return true;\n    }\n    public boolean isValidBST(TreeNode root) {\n        return helper(root, null, null);\n    }\n}\n```\n**Solution 2 Iteration**\n\n```java\n    LinkedList<TreeNode> stack = new LinkedList();\n    LinkedList<Integer> uppers = new LinkedList(), lowers = new LinkedList();\n    \n    private void update(TreeNode root, Integer lower, Integer upper) {\n        stack.add(root);\n        uppers.add(upper);\n        lowers.add(lower);\n    }\n    public boolean isValidBST(TreeNode root) {\n        Integer lower = null, upper = null, val;\n        update(root, lower, upper);\n        \n        while (!stack.isEmpty()) {\n            root = stack.poll();\n            lower = lowers.poll();\n            upper = uppers.poll();\n            \n            if (root == null) continue;\n            val = root.val;\n            if (lower != null && val <= lower) return false;\n            if (upper != null && val >= upper) return false;\n            update(root.left, lower, val);\n            update(root.right, val, upper);\n        }\n        return true;\n    }\n```\n**Solution 3 Inorder Traversal**\n\n```java\n    public boolean isValidBST(TreeNode root) {\n        Stack<TreeNode> stack = new Stack();\n        double inorder = - Double.MAX_VALUE;\n        \n        while (!stack.isEmpty() || root != null) {\n            while (root != null) {\n                stack.push(root);\n                root = root.left;\n            }\n            root = stack.pop();\n            if (root.val <= inorder) return false;\n            inorder = root.val;\n            root = root.right;\n        }\n        return true;\n    }\n```\n\n### 101. Symmetric Tree (Easy) [@](https://leetcode.com/problems/symmetric-tree/)\n\n> Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).\n>\n> For example, this binary tree `[1,2,2,3,4,4,3]` is symmetric:\n>\n> ```\n>  1\n> / \\\n> 2   2\n> / \\ / \\\n> 3  4 4  3\n> ```\n>\n> \n>\n> But the following `[1,2,2,null,3,null,3]` is not:\n>\n> ```\n>  1\n> / \\\n> 2   2\n> \\   \\\n> 3    3\n> ```\n\n**Solution 1 Recursion**\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    private boolean isMirror(TreeNode t1, TreeNode t2) {\n        if (t1 == null && t2 == null) return true;\n        if (t1 == null || t2 == null) return false;\n        return (t1.val == t2.val) && isMirror(t1.right, t2.left) && isMirror(t1.left, t2.right);\n    }\n    public boolean isSymmetric(TreeNode root) {\n        if (root == null) \n            return true;\n        else\n            return isMirror(root.left, root.right);\n    }\n}\n```\n**Solution 2 Iteration**\n\n```java\npublic boolean isSymmetric(TreeNode root) {\n    if (root == null) return true;\n\n    Queue<TreeNode> q = new LinkedList();\n    q.add(root.left);\n    q.add(root.right);\n    while (!q.isEmpty()) {\n        TreeNode t1 = q.poll();\n        TreeNode t2 = q.poll();\n        if (t1 == null && t2 == null) continue;\n        if (t1 == null || t2 == null) return false;\n        if (t1.val != t2.val) return false;\n        q.add(t1.left);\n        q.add(t2.right);\n        q.add(t1.right);\n        q.add(t2.left);\n    }\n    return true;\n}\n```\n\n### 104. Maximum Depth of Binary Tree (Easy) [@](https://leetcode.com/problems/maximum-depth-of-binary-tree/)\n\n> Given a binary tree, find its maximum depth.\n>\n> The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\n>\n> **Note:** A leaf is a node with no children.\n>\n> **Example:**\n>\n> Given binary tree `[3,9,20,null,null,15,7]`,\n>\n> ```\n>  3\n> / \\\n> 9  20\n>  /  \\\n> 15   7\n> ```\n>\n> return its depth = 3.\n\n**Solution 1 Recursion**\n\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) return 0;\n        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n    }\n}\n```\n**Solution 2 Iteration (BFS)**\n\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) return 0;\n        \n        LinkedList<TreeNode> queue = new LinkedList<TreeNode>();\n        int level = 0;\n        queue.add(root);\n        int curNum = 1, nextNum = 0;\n        \n        while (!queue.isEmpty()) {\n            TreeNode node = queue.poll();\n            curNum--;\n            if (node.left != null) {\n                nextNum++;\n                queue.add(node.left);\n            }\n            if (node.right != null) {\n                nextNum++;\n                queue.add(node.right);\n            }\n            if (curNum == 0) {\n                curNum = nextNum;\n                nextNum = 0;\n                level++;\n            }\n        }\n        return level;\n    }\n}\n```\n### 105.  Construct Binary Tree from Preorder and Inorder Traversal (Medium) [@](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)\n\n> Given preorder and inorder traversal of a tree, construct the binary tree.\n>\n> **Note:**\n> You may assume that duplicates do not exist in the tree.\n>\n> For example, given\n>\n> ```\n> preorder = [3,9,20,15,7]\n> inorder = [9,3,15,20,7]\n> ```\n>\n> Return the following binary tree:\n>\n> ```\n>  3\n> / \\\n> 9  20\n>  /  \\\n> 15   7\n> ```\n\n**Solution Divide and Conquer + Recursion** \n\n```java\nclass Solution {\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        TreeNode root = createTree(preorder, 0, preorder.length-1, inorder, 0, inorder.length-1);\n        return root;\n    }\n    private TreeNode createTree(int[] preorder, int startPre, int endPre, int[] inorder, int startIn, int endIn) {\n        if (startPre > endPre || startIn > endIn) return null;\n        TreeNode root = new TreeNode(preorder[startPre]);\n        \n        for (int i = startIn; i <= endIn; i++) {\n            if (inorder[i] == preorder[startPre]) {\n                //i-startIn是左子树长度\n                root.left = createTree(preorder, startPre + 1, startPre + i - startIn, inorder, startIn, i-1);\n                //右子树开始节点是从左子树开始节点加上左子树的长度\n                root.right = createTree(preorder, startPre + 1 + i - startIn, endPre, inorder, i + 1, endIn);\n            }\n        }\n        return root;\n    }\n}\n```\n### 108. Convert Sorted Array to Binary Search Tree (Easy) [@](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/)\n\n> Given an array where elements are sorted in ascending order, convert it to a height balanced BST.\n>\n> For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of *every* node never differ by more than 1.\n>\n> **Example:**\n>\n> ```\n> Given the sorted array: [-10,-3,0,5,9],\n> \n> One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:\n> \n>    0\n>   / \\\n> -3   9\n> /   /\n> -10  5\n> ```\n\n**Solution 1 Recursion**\n\n```java\nclass Solution {\n    public TreeNode sortedArrayToBST(int[] nums) {\n        return dfs(nums, 0, nums.length-1);\n    }\n    private TreeNode dfs(int[] nums, int start, int end) {\n        if (start > end) return null;\n        int mid = (start + end) / 2;\n        TreeNode root = new TreeNode(nums[mid]);\n        root.left = dfs(nums, start, mid - 1);\n        root.right = dfs(nums, mid + 1, end);\n        return root;\n    }\n}\n```\n### 116. Populating Next Right Pointers in Each Node (Medium) [@](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/)\n\n> You are given a **perfect binary tree** where all leaves are on the same level, and every parent has two children.\n>\n> Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to `NULL`.\n>\n> Initially, all next pointers are set to `NULL`.\n>\n> **Follow up:**\n>\n> - You may only use constant extra space.\n> - Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem.\n\n**Solution 1 Recursion**\n\n这道题解法还是挺直白的，如果当前节点有左孩子，那么左孩子的next就指向右孩子。如果当前节点有右孩子，那么判断，如果当前节点的next是null，说明当前节点已经到了最右边，那么右孩子也是最右边的，所以右孩子指向null。如果当前节点的next不是null，那么当前节点的右孩子的next就需要指向当前节点next的左孩子。递归求解就好。\n\n```java\n/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public Node left;\n    public Node right;\n    public Node next;\n\n    public Node() {}\n    \n    public Node(int _val) {\n        val = _val;\n    }\n\n    public Node(int _val, Node _left, Node _right, Node _next) {\n        val = _val;\n        left = _left;\n        right = _right;\n        next = _next;\n    }\n};\n*/\nclass Solution {\n    public Node connect(Node root) {\n        if (root == null) return null;\n        if (root.left != null) {\n            root.left.next = root.right;\n        }\n        if (root.right != null) {\n            if (root.next != null) {\n                root.right.next = root.next.left;\n            }else {\n                root.right.next = null;\n            }\n        }\n        connect(root.left);\n        connect(root.right);\n        return root;\n    }\n}\n```\n\n### 124. Binary Tree Maximum Path Sum (Hard) [@](https://leetcode.com/problems/binary-tree-maximum-path-sum/)\n\n> Given a **non-empty** binary tree, find the maximum path sum.\n>\n> For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain **at least one node** and does not need to go through the root.\n>\n> **Example 1:**\n>\n> ```\n> Input: [1,2,3]\n> \n>     1\n>    / \\\n>   2   3\n> \n> Output: 6\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: [-10,9,20,null,null,15,7]\n> \n> -10\n> / \\\n> 9  20\n>  /  \\\n> 15   7\n> \n> Output: 42\n> ```\n\n- 递归的思想，DFS，从下到上\n- 每个节点可以与其左右节点结合，但每个节点作为子节点返回时，只能选去该节点的值和其较大子节点的值的和返回\nSolution\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    int res = Integer.MIN_VALUE;\n    public int maxPathSum(TreeNode root) {\n        helper(root);\n        return res;\n    }\n    private int helper(TreeNode root) {\n        if (root == null) return 0;\n        int left = Math.max(helper(root.left), 0);\n        int right = Math.max(helper(root.right), 0);\n        res = Math.max(res, left + right + root.val);\n        return Math.max(left, right) + root.val;\n    }\n}\n```\n\n### 130. Surrounded Regions (Medium) [@](https://leetcode.com/problems/surrounded-regions/)\n\n> Given a 2D board containing `'X'` and `'O'` (**the letter O**), capture all regions surrounded by `'X'`.\n>\n> A region is captured by flipping all `'O'`s into `'X'`s in that surrounded region.\n>\n> **Example:**\n>\n> ```\n> X X X X\n> X O O X\n> X X O X\n> X O X X\n> ```\n>\n> After running your function, the board should be:\n>\n> ```\n> X X X X\n> X X X X\n> X X X X\n> X O X X\n> ```\n>\n> **Explanation:**\n>\n> Surrounded regions shouldn’t be on the border, which means that any `'O'` on the border of the board are not flipped to `'X'`. Any `'O'` that is not on the border and it is not connected to an `'O'` on the border will be flipped to `'X'`. Two cells are connected if they are adjacent cells connected horizontally or vertically.\n\n**Solution Recursion**\n\n```java\nclass Solution {\n    public void solve(char[][] board) {\n        if (board == null) return;\n        int rows = board.length;\n        if (rows <= 0) return;\n        int cols = board[0].length;\n        if (cols <= 0) return;\n        // 找到边缘‘O’\n        for (int i = 0; i < rows; i++) {\n            if (board[i][0] == 'O')\n                dfs(board, i, 0);\n            if (board[i][cols-1] == 'O')\n                dfs(board, i, cols-1);\n        }\n        for (int i = 0; i < cols; i++) {\n            if (board[0][i] == 'O')\n                dfs(board, 0, i);\n            if (board[rows-1][i] == 'O')\n                dfs(board, rows-1, i);\n        }\n        \n        for (int i = 0; i < rows; i++){\n            for (int j = 0; j < cols; j++) {\n                if (board[i][j] == '#')\n                    board[i][j] = 'O';\n                else if (board[i][j] == 'O')\n                    board[i][j] = 'X';\n            }\n        }\n    }\n    //每遇到‘O’后，向四个方向递归搜索，所有相邻‘O’变为‘#’\n    private void dfs(char[][] board, int i, int j) {\n        if (board[i][j] == 'O') {\n            board[i][j] = '#';\n\t\t// 跳过四周边缘\n            if (i < board.length - 2)\n                dfs(board, i + 1, j);\n            if (i > 1)\n                dfs(board, i - 1, j);\n            if (j < board[0].length - 2)\n                dfs(board, i, j + 1);\n            if (j > 1) \n                dfs(board, i, j - 1);\n        }\n    }\n}\n```\n\n### 200. Number of Islands (Medium) [@](https://leetcode.com/problems/number-of-islands/)\n\n> Given a 2d grid map of `'1'`s (land) and `'0'`s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n>\n> **Example 1:**\n>\n> ```\n> Input:\n> 11110\n> 11010\n> 11000\n> 00000\n> \n> Output: 1\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input:\n> 11000\n> 11000\n> 00100\n> 00011\n> \n> Output: 3\n> ```\n\n**Solution DFS + Recursion**\n\n- 采用DFS，访问过的‘1’转为‘0’，继续遍历\n```java\nclass Solution {\n    public int numIslands(char[][] grid) {\n        if (grid == null || grid.length == 0 || grid[0].length == 0)\n            return 0;\n        int rows = grid.length;\n        int cols = grid[0].length;\n        int count = 0;\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (grid[i][j] == '1'){\n                    count++;\n                    dfs(grid, i, j);    \n                }\n            }\n        }\n        return count;\n    }\n    private void dfs(char[][] grid, int i, int j) {\n        if (i < 0 || i > grid.length-1 || j < 0 || j > grid[0].length-1)\n            return;\n        if (grid[i][j] == '0') {\n            return;\n        }else if (grid[i][j] == '1') {\n            grid[i][j] = '0';\n            dfs(grid, i-1, j);\n            dfs(grid, i+1, j);\n            dfs(grid, i, j-1);\n            dfs(grid, i, j+1);\n        }\n    }\n}\n```\n\n### 207. Course Schedule (Medium) [@](https://leetcode.com/problems/course-schedule/)\n\n> There are a total of *n* courses you have to take, labeled from `0` to `n-1`.\n>\n> Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: `[0,1]`\n>\n> Given the total number of courses and a list of prerequisite **pairs**, is it possible for you to finish all courses?\n>\n> **Example 1:**\n>\n> ```\n> Input: 2, [[1,0]] \n> Output: true\n> Explanation: There are a total of 2 courses to take. \n>           To take course 1 you should have finished course 0. So it is possible.\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: 2, [[1,0],[0,1]]\n> Output: false\n> Explanation: There are a total of 2 courses to take. \n>           To take course 1 you should have finished course 0, and to take course 0 you should\n>           also have finished course 1. So it is impossible.\n> ```\n>\n> **Note:**\n>\n> 1. The input prerequisites is a graph represented by **a list of edges**, not adjacency matrices. Read more about [how a graph is represented](https://www.khanacademy.org/computing/computer-science/algorithms/graph-representation/a/representing-graphs).\n> 2. You may assume that there are no duplicate edges in the input prerequisites.\n\n**Solution Topology**\n\n- 此问题等价于图中是否有无环的存在（拓扑排序解决问题）\n```java\nclass Solution {\n    public boolean canFinish(int numCourses, int[][] prerequisites) {\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        int[] indegree = new int[numCourses]; \n        //初始化图，利用hashmap\n        for (int i = 0; i < prerequisites.length; i++) {\n            int s_node = prerequisites[i][0];\n            int e_node = prerequisites[i][1];\n            if (!map.containsKey(s_node))\n                map.put(s_node, new ArrayList<>());\n            map.get(s_node).add(e_node);\n            indegree[e_node]++;//更新每个点的入度\n        }\n        //储存所有入度为0的节点->拓扑排序起始点\n        Queue<Integer> q = new LinkedList<>();\n        for (int i = 0; i < numCourses; i++) {\n            if (indegree[i] == 0)\n                q.offer(i);\n        }\n        //计算可拓扑排序的节点个数\n        int count = 0;\n        while (!q.isEmpty()) {\n            int val = q.poll();\n            count++;\n            \n            if (map.containsKey(val)) {\n                List<Integer> tmp = map.get(val);\n                for (int i = 0; i < tmp.size(); i++) {\n                    int idx = tmp.get(i);\n                    indegree[idx]--;\n                    if (indegree[idx] == 0)\n                        q.offer(idx);\n                }\n            }\n        }\n        return count == numCourses;\n    }\n}\n```\n\n### 210. Course Schedule II (Medium) [@](https://leetcode.com/problems/course-schedule-ii/)\n\n> There are a total of *n* courses you have to take, labeled from `0` to `n-1`.\n>\n> Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: `[0,1]`\n>\n> Given the total number of courses and a list of prerequisite **pairs**, return the ordering of courses you should take to finish all courses.\n>\n> There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.\n>\n> **Example 1:**\n>\n> ```\n> Input: 2, [[1,0]] \n> Output: [0,1]\n> Explanation: There are a total of 2 courses to take. To take course 1 you should have finished   \n>           course 0. So the correct course order is [0,1] .\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: 4, [[1,0],[2,0],[3,1],[3,2]]\n> Output: [0,1,2,3] or [0,2,1,3]\n> Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both     \n>           courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. \n>           So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3] .\n> ```\n>\n> **Note:**\n>\n> 1. The input prerequisites is a graph represented by **a list of edges**, not adjacency matrices. Read more about [how a graph is represented](https://www.khanacademy.org/computing/computer-science/algorithms/graph-representation/a/representing-graphs).\n> 2. You may assume that there are no duplicate edges in the input prerequisites.\n\n**Solution Topology**\n\n```java\nclass Solution {\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        int[] indegree = new int[numCourses]; \n        int[] res = new int[numCourses];\n        //初始化图，利用hashmap\n        for (int i = 0; i < prerequisites.length; i++) {\n            int s_node = prerequisites[i][0];\n            int e_node = prerequisites[i][1];\n            if (!map.containsKey(s_node))\n                map.put(s_node, new ArrayList<>());\n            map.get(s_node).add(e_node);\n            indegree[e_node]++;//更新每个点的入度\n        }\n        //储存所有入度为0的节点->拓扑排序起始点\n        int index = numCourses - 1;\n        Queue<Integer> q = new LinkedList<>();\n        for (int i = 0; i < numCourses; i++) {\n            if (indegree[i] == 0) {\n                q.offer(i);\n                res[index--] = i;\n            }\n        }\n        //拓扑排序\n        while (!q.isEmpty()) {\n            int val = q.poll();\n            //获取val指向的节点\n            if (map.containsKey(val)) {\n                List<Integer> tmp = map.get(val);\n                for (int i = 0; i < tmp.size(); i++) {\n                    int idx = tmp.get(i);\n                    indegree[idx]--;\n                    if (indegree[idx] == 0) {\n                        q.offer(idx);\n                        res[index--] = idx;\n                    }\n                }\n            }\n        }\n        if (index != -1)\n            return new int[0];\n        else\n            return res;\n    }\n}\n```\n## BFS\n\n### 102. Binary Tree Level Order Traversal (Medium) [@](https://leetcode.com/problems/binary-tree-level-order-traversal/)\n\n> Given a binary tree, return the *level order* traversal of its nodes' values. (ie, from left to right, level by level).\n>\n> For example:\n> Given binary tree `[3,9,20,null,null,15,7]`,\n>\n> ```\n>  3\n> / \\\n> 9  20\n>  /  \\\n> 15   7\n> ```\n>\n> \n>\n> return its level order traversal as:\n>\n> ```\n> [\n> [3],\n> [9,20],\n> [15,7]\n> ]\n> ```\n\n**Solution 1 Recursion**\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\n        helper(root, res, 0);\n        return res;\n    }\n    private void helper(TreeNode root, List<List<Integer>> res, int level) {\n        if (root == null) return;\n        if (res.size() < level+1) {\n            res.add(new ArrayList<Integer> ());\n        }\n        res.get(level).add(root.val);\n        \n        helper(root.left, res, level+1);\n        helper(root.right, res, level+1);\n    }\n}\n```\n**Solution 2 Iteration (Queue)**\n\n```java\nclass Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\n        if (root == null) return res;\n        \n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\n        queue.offer(root);\n        int level = 0;\n        while (!queue.isEmpty()) {\n            //start current level\n            res.add(new ArrayList<Integer>());\n            //num of elements in current level\n            int len = queue.size();\n            \n            for (int i = 0; i < len; i++) {\n                TreeNode node = queue.poll();\n                //get the val in each level\n                res.get(level).add(node.val);\n                //add child nodes to queue\n                if (node.left != null) queue.offer(node.left);\n                if (node.right != null) queue.offer(node.right);\n            }\n            //go to next level\n            level++;\n        }\n        return res;\n    }\n}\n```\n\n### 103. Binary Tree Zigzag Level Order Traversal (Medium) [@](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/)\n\n> Given a binary tree, return the *zigzag level order* traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).\n>\n> For example:\n> Given binary tree `[3,9,20,null,null,15,7]`,\n>\n> ```\n>  3\n> / \\\n> 9  20\n>  /  \\\n> 15   7\n> ```\n>\n> \n>\n> return its zigzag level order traversal as:\n>\n> ```\n> [\n> [3],\n> [20,9],\n> [15,7]\n> ]\n> ```\n\n**Solution Recursion**\n\n- based on 102, add a flag to identify reverse\n```java\nclass Solution {\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\n        helper(root, res, 0, false);\n        return res;\n    }\n    private void helper(TreeNode root, List<List<Integer>> res, int level, boolean flag) {\n        if (root == null) return;\n        if (res.size() < level+1) {\n            res.add(new LinkedList<Integer> ());\n        }\n        if (flag) {\n            //convert to LinkedList\n            ((LinkedList<Integer>)res.get(level)).addFirst(root.val);\n        }else {\n            res.get(level).add(root.val);\n        }\n        \n        helper(root.left, res, level+1, !flag);\n        helper(root.right, res, level+1, !flag);\n    }\n}\n```\n\n### 127. Word Ladder (Medium) [@](https://leetcode.com/problems/word-ladder/)\n\n> Given two words (*beginWord* and *endWord*), and a dictionary's word list, find the length of shortest transformation sequence from *beginWord* to *endWord*, such that:\n>\n> 1. Only one letter can be changed at a time.\n> 2. Each transformed word must exist in the word list. Note that *beginWord* is *not* a transformed word.\n>\n> **Note:**\n>\n> - Return 0 if there is no such transformation sequence.\n> - All words have the same length.\n> - All words contain only lowercase alphabetic characters.\n> - You may assume no duplicates in the word list.\n> - You may assume *beginWord* and *endWord* are non-empty and are not the same.\n>\n> **Example 1:**\n>\n> ```\n> Input:\n> beginWord = \"hit\",\n> endWord = \"cog\",\n> wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n> \n> Output: 5\n> \n> Explanation: As one shortest transformation is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\",\n> return its length 5.\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input:\n> beginWord = \"hit\"\n> endWord = \"cog\"\n> wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\n> \n> Output: 0\n> \n> Explanation: The endWord \"cog\" is not in wordList, therefore no \n> ```\n\n**Solution 1 BFS (Time Limit Exceeded)**\n\n```java\nclass Solution {\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) return 0;\n        Queue<String> queue = new LinkedList<String>();\n        queue.offer(beginWord);\n        HashMap<String, Integer> maps = new HashMap<String, Integer>(); //store the level of each string\n        maps.put(beginWord, 1);\n        if (wordList.contains(beginWord)) wordList.remove(beginWord);\n        \n        while (!queue.isEmpty()) {\n            String top = queue.poll();\n            int len = top.length();\n            StringBuilder builder;\n            \n            int level = maps.get(top);\n            for (int i = 0; i < len; i++) {\n                //find the strings which is one char diff with top\n                builder = new StringBuilder(top);\n                for (char c = 'a'; c <= 'z'; c++) {\n                    builder.setCharAt(i, c);\n                    String tmpStr = builder.toString();\n                    if (tmpStr.equals(top))//match top\n                        continue;\n                    //add to next level\n                    if (wordList.contains(tmpStr)) {\n                        if (tmpStr.equals(endWord))//match endWord->return \n                            return level+1;\n                        queue.offer(tmpStr);\n                        wordList.remove(tmpStr);\n                        maps.put(tmpStr, level+1);\n                    }\n                }\n            }\n        }\n        return 0;\n    }\n}\n```\n\nSolution 2 Bidirectional Breadth First Search\n```java\nclass Solution {\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if(!wordList.contains(endWord)) return 0;\n        //top->down\n        Queue<String> queue1 = new LinkedList<>();\n        queue1.add(beginWord);\n        //down->top\n        Queue<String> queue2 = new LinkedList<>();\n        queue2.add(endWord);\n        \n        Set<String> visited = new HashSet<>();\n        visited.add(endWord);\n        \n        int step = 1;\n        while(queue1.size() > 0 && queue2.size() > 0) {\n            // always start from smaller number of queue \n            if(queue1.size() > queue2.size()) {\n                Queue<String> temp = queue1;\n                queue1 = queue2;\n                queue2 = temp;\n            }\n            \n            Queue<String> nextQueue = new LinkedList<>();\n            while(!queue1.isEmpty()) {\n                String cur = queue1.poll();\n                for(String word: wordList) {\n                    if(valid(cur, word)) {\n                        if(queue2.contains(word)) {\n                            return step+1;\n                        }\n                        \n                        if(!visited.contains(word)) {\n                            nextQueue.add(word);\n                            visited.add(word);                            \n                        }\n                    }\n                }\n            }\n            queue1 = nextQueue;\n            step++;\n        }\n        return 0;\n    }\n    //whether step==1\n    boolean valid(String a, String b) {\n        int diff = 0;\n        for(int i = 0; i < a.length(); ++i) {\n            if(a.charAt(i) != b.charAt(i)) {\n                diff++;\n                if(diff >= 2) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\n```\n\n## DP (DP<-->DFS + memo)\n\n### 53.Maximum Subarray (Easy) [@](https://leetcode.com/problems/maximum-subarray/)\n\n> Given an integer array `nums`, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n>\n> **Example:**\n>\n> ```\n> Input: [-2,1,-3,4,-1,2,1,-5,4],\n> Output: 6\n> Explanation: [4,-1,2,1] has the largest sum = 6.\n> ```\n>\n> **Follow up:**\n>\n> If you have figured out the O(*n*) solution, try coding another solution using the divide and conquer approach, which is more subtle.\n\n**Solution 1**\n\n- 遍历所有子序列O(n^3) -> 住需要遍历从起始位置开始的子序列 O(n^2) ->\n- 起始位置为负时，显然不是最大子序列和起始点。所以从负数部位最大子序列和的起点出发 O(n)\n```java\nclass Solution {\n    public int maxSubArray(int[] nums) {\n        int nSize = nums.length;\n        if (nSize == 0) return 0;\n        int maxSum = Integer.MIN_VALUE;\n        int nSum = 0;\n        for (int i = 0; i < nSize; i++) {\n            nSum += nums[i];\n            if (nSum > maxSum)\n                maxSum = nSum;\n            if (nSum < 0)\n                nSum = 0;\n        }\n        return maxSum;\n    }\n}\n```\n\n### 62. Unique Paths (Medium) [@](https://leetcode.com/problems/unique-paths/)\n\n> A robot is located at the top-left corner of a *m* x *n* grid (marked 'Start' in the diagram below).\n>\n> The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).\n>\n> How many possible unique paths are there?\n>\n> **Note:** *m* and *n* will be at most 100.\n>\n> **Example 1:**\n>\n> ```\n> Input: m = 3, n = 2\n> Output: 3\n> Explanation:\n> From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\n> 1. Right -> Right -> Down\n> 2. Right -> Down -> Right\n> 3. Down -> Right -> Right\n> ```\n\n**Solution 1** \n\n- dp[i] [j] = dp[i-1] [j] + dp[i] [j-1]\n- O(m*n)\n```java\nclass Solution {\n    public int uniquePaths(int m, int n) {\n        //dp[i][j] = dp[i-1][j] + dp[i][j-1];\n        int[][] dp = new int[m][n];\n        dp[0][0] = 1;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i > 0)\n                    dp[i][j] += dp[i-1][j];\n                if (j > 0)\n                    dp[i][j] += dp[i][j-1];\n            }\n        }\n        return dp[m-1][n-1];\n    }\n}\n```\n\n**Solution 2**\n\n- 空间复杂度 O(m*n) -> O(n)\n- dp[j]: (0,0) -> (i,j)\n- dp[j-1]表示dp[j]上方的值\n- dp[j] = dp[j] + dp[j-1]\n- 一列一列更新，只保存一列的数据\n```java\nclass Solution {\n    public int uniquePaths(int m, int n) {\n        //dp[j]: num of paths from (0,0) to (i-1,j)\n        int[] dp = new int[n];\n        dp[0] = 1;\n        for (int i = 0; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                dp[j] += dp[j-1];\n            }\n        }\n        return dp[n-1];\n    }\n}\n```\n\n### 70. Climbing Stairs (Easy) [@](https://leetcode.com/problems/climbing-stairs/)\n\n> You are climbing a stair case. It takes *n* steps to reach to the top.\n>\n> Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n>\n> **Note:** Given *n* will be a positive integer.\n>\n> **Example 1:**\n>\n> ```\n> Input: 2\n> Output: 2\n> Explanation: There are two ways to climb to the top.\n> 1. 1 step + 1 step\n> 2. 2 steps\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: 3\n> Output: 3\n> Explanation: There are three ways to climb to the top.\n> 1. 1 step + 1 step + 1 step\n> 2. 1 step + 2 steps\n> 3. 2 steps + 1 step\n> ```\n\nSolution 1 DP\n- 假设梯子有n层，那么如何爬到第n层呢，因为每次只能怕1或2步，那么爬到第n层的方法要么是从第n-1层一步上来的，要不就是从n-2层2步上来的，所以递推公式非常容易的就得出了\n```java\nclass Solution {\n    public int climbStairs(int n) {\n        //dp[i] = dp[i-1] + dp[i-2];\n        if (n == 1) return 1;\n        int[] dp = new int[n+1];\n        dp[1] = 1;\n        dp[2] = 2;\n        for (int i = 3; i <= n; i++) {\n            dp[i] = dp[i - 1] + dp[i - 2];\n        }\n        return dp[n];\n    }\n}\n```\nSolution 2 Fibonacci Number\n```java\nclass Solution {\n    public int climbStairs(int n) {\n        if (n == 1) return 1;\n        int first = 1;\n        int second = 2;\n        for (int i = 3; i <= n; i++) {\n            int third = first + second;\n            first = second;\n            second = third;\n        }\n        return second;\n    }\n}\n```\n\n### 91. Decode Ways (Medium) [@](https://leetcode.com/problems/decode-ways/)\n\n> A message containing letters from `A-Z` is being encoded to numbers using the following mapping:\n>\n> ```\n> 'A' -> 1\n> 'B' -> 2\n> ...\n> 'Z' -> 26\n> ```\n>\n> Given a **non-empty** string containing only digits, determine the total number of ways to decode it.\n>\n> **Example 1:**\n>\n> ```\n> Input: \"12\"\n> Output: 2\n> Explanation: It could be decoded as \"AB\" (1 2) or \"L\" (12).\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: \"226\"\n> Output: 3\n> Explanation: It could be decoded as \"BZ\" (2 26), \"VF\" (22 6), or \"BBF\" (2 2 6).\n> ```\n\n**Solution**\n\n- 设定状态为：`dp[i]`表示`s`从`0`开始，长度为`i`的子串的解码方式数量，于是我们最终要求的答案便是`dp[n]`。\n\n  那么如何求解`dp[i]`呢？这个很简单，枚举最后一个字母对应1位还是2位，将f转化为规模更小的子问题。\n\n  - 设`dp[i] = 0`\n  - 枚举最后一个字母对应1位（要求`s[i - 1] != '0'`)，那么有`dp[i] += dp[i-1]`；\n  - 枚举最后一个字母对应2位（要求`i > 1`且`s[i - 2]`和`s[i - 1]`组成的字符串在`\"10\"~\"26\"`的范围内），那么有`dp[i] += dp[i - 2]`；\n\n- 也就是说，我们可以通过dp[i - 1]和dp[i - 2]计算出dp[i]来，这就是我们的状态和转移方程。\n\n- 在具体实现中，我们可以按照i从1到n的顺序，依次计算出所有的dp[i]。\n```java\nclass Solution {\n    public int numDecodings(String s) {\n        if (s.length() == 0) return 0;\n        int[] dp = new int[s.length()+1];\n        dp[0] = 1;\n        //dp[i] 表示s从0开始，长度为i的字串的解码方式数量\n        for (int i = 1; i < s.length()+1; i++) {\n            if (s.charAt(i-1) != '0') \n                dp[i] += dp[i-1];\n            if (i >= 2 && (s.substring(i-2, i).compareTo(\"10\") >= 0 && s.substring(i-2, i).compareTo(\"26\") <= 0))\n                dp[i] += dp[i - 2];\n        }\n        return dp[s.length()];\n    }\n}\n```\n\n### 121. Best Time to Buy and Sell Stock (Easy) [@](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)\n\n>  \n\n**Solution**\n\n如果是动态规划的思路， 基本上我们要定义状态dp[i]， 然后看dp[i]和dp[i-1]或者dp[i-k]之间的关系。\n假设我们定义dp[i]是在i天的最大利润， 那么和前面的重叠子问题的关系是什么呢？\n\n- 一种情况当然是前面子问题里面的最大利润已经是整体的最大利润， 那么dp[i]=dp[i-1]\n  还有一种情况是， 前面虽然取得了利润， 但是第i天卖出（对应到前面某一天买入)会产生更大的利润\n  这时候，dp[i] = prices[i] - prices[j]\n  也就是说, 整个递推公式是: dp[i] = Math.max(dp[i-1], prices[i]-prices[j]), 其中, j<i\n  这样， 对于每个dp[i], 都只和之前的状态和数据有关， 和后面的选择已经无关了。\n  然后这时候要考虑， prices[j]是哪个值会产生最大利润？ 当然是目前为止的最小值。\n  也就是说， dp[j] = min prices so far， 而且这个值的好处是， 在一次遍历的过程中，可以直接随着遍历更新这个值。那么， 可以保存一个min值， 这样整体一次遍历就可以了。\n- 有一个错误的思路， 就是一次遍历求出最小价格和最大价格， 然后得出利润。\n  这个解法的错误的地方在于， 最大价格可能是最小价格的前面， 不能直接使用。\n  反例比如[3,1,2]\n- 前面的错误在于把顺序不符合要求的情况包括进去了，\n  当然， 这个过程可以更简化。 甚至可以不需要用这么复杂的动态规划的思路, 直接对问题进行分析。\n  对于最大利润的买入和卖出位置， 虽然买入和卖出可能出现在任意位置， 但是我们考虑如果固定其中一个价格会怎么样？\n  实际上， 如果买入的位置已经选中， 那么卖出的位置也确定了。 反过来也成立， 如果卖出的位置已经选择， 那么买入的位置也确定了。\n\n这里假设卖出的位置是i, 那么， 买入的位置就是在i前面的价格里面的最小价格。\n那么，如果我们从左向右遍历， 每次保存目前已经遇到过的最小价格， 那么，prices[i]-min就是在i这个位置卖出的最大利润，这样就可以在一次遍历的过程中求解整体的最大利润。\n\n```\nclass Solution {\n    public int maxProfit(int[] prices) {\n        if (prices.length == 0) return 0;\n        int[] dp = new int[prices.length];\n        int min = prices[0];\n        \n        for (int i = 1; i < prices.length; i++) {\n            min = Math.min(prices[i], min);\n            dp[i] = Math.max(dp[i-1], prices[i] - min);\n        }\n        return dp[prices.length - 1];\n    }\n}\n```\n- 可将dp[]换为max，降低空间复杂度\n\n### 139. Word Break (Medium) [@](https://leetcode.com/problems/word-break/)\n\nSolution 1\n\n1. 一个直观的思路是暴力解，首先从头开始，看看每个单词能不能成为成为字符串的开头， 如果匹配上了， 可以对后面的继续这个过程\n2. 但是这个过程有一点重复， 其实每次计算都是计算的时候，问题是判断某一个子字符串是不是满足要求， 而某一个子字符串，在这个问题里面其实就是原始字符串的index， 那么， 这个子问题可能是重叠的。\n   比如， 针对\"abcdef\"和[“ab”, “cd”, “abcd”]\n   那么， 针对index=4 （从1开始计数， 可以有ab+cd 或者abcd两种方式， 那么，一个计算过了，后面的就不需要再计算了。\n3. 这样，就可以应用动态规划的思想， 设置dp[i]表示在i位已经满足要求的， 然后从前向后遍历，看看每一位是否可以走到更多的位；\n4. 动态规划的常用套路，就是看prefix， 因为计算prefix的时候，问题已经求解过了，固定了； 当然要从postfix去理解也可以， 但是那样通常会是解问题的自然思路，但是从动态规划bottom up的方式，往往不是那么好理解。\n   而当然，如果用记忆化递归的方式去理解，也是可以的。 但是同样要抽象出需要记忆的状态。 对于每个substring， 其实也是要用index来定义状态。 当然，完全用string做key也可能可以， 但是那样会浪费很多空间。\n\n```java\nclass Solution {\n    public boolean wordBreak(String s, List<String> wordDict) {\n        Set<String> wordSet = new HashSet<>(wordDict);\n        boolean[] dp = new boolean[s.length() + 1];\n        dp[0] = true;\n        //i--开始位置\n        for (int i = 0; i < s.length(); i++) {\n            if (!dp[i]) continue;\n            //j--结束位置\n            for (int j = i+1; j <= s.length(); j++) {\n                String subStr = s.substring(i, j);\n                if (wordSet.contains(subStr)) {\n                    dp[j] = true;\n                }\n            }\n        }\n        return dp[s.length()];\n    }\n}\n```\n\n### 140. Word Break II (Hard) [@](https://leetcode.com/problems/word-break-ii/)\n> Given a **non-empty** string *s* and a dictionary *wordDict* containing a list of **non-empty** words, add spaces in *s* to construct a sentence where each word is a valid dictionary word. Return all such possible sentences.\n>\n> **Note:**\n>\n> - The same word in the dictionary may be reused multiple times in the segmentation.\n> - You may assume the dictionary does not contain duplicate words.\n>\n> **Example 1:**\n>\n> ```\n> Input:\n> s = \"catsanddog\"\n> wordDict = [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"]\n> Output:\n> [\n>   \"cats and dog\",\n>   \"cat sand dog\"\n> ]\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input:\n> s = \"pineapplepenapple\"\n> wordDict = [\"apple\", \"pen\", \"applepen\", \"pine\", \"pineapple\"]\n> Output:\n> [\n>   \"pine apple pen apple\",\n>   \"pineapple pen apple\",\n>   \"pine applepen apple\"\n> ]\n> Explanation: Note that you are allowed to reuse a dictionary word.\n> ```\n>\n> **Example 3:**\n>\n> ```\n> Input:\n> s = \"catsandog\"\n> wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]\n> Output:\n> []\n> ```\n\nSolution Recursion\n\n- Python\n- 递归调用wordBerak()\n- [Youtube 题解](https://www.youtube.com/watch?v=JqOIRBC0_9c)\n- ![leetcode_140.png](:/ce516b8d2d2e441d9d46426147b9d38c)\n\n```python\nclass Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\n        words = set(wordDict)\n        memo = {}\n        def wordBreak(s):\n            # already in memory, return directly\n            if s in memo: \n                return memo[s]\n            # answer for s\n            ans = []\n            if s in words:\n                ans.append(s)\n            for i in range(1, len(s)):\n                # check whether right part is a word\n                right = s[i:]\n                if right not in words:\n                    continue\n                # append to the answer for left part\n                ans += [w + \" \" + right for w in wordBreak(s[0:i])]\n            memo[s] = ans\n            return memo[s]\n        return wordBreak(s)\n```\n\n### 152. Maximum Product Subarray (Medium) [@](https://leetcode.com/problems/maximum-product-subarray/)\n\n> Given an integer array `nums`, find the contiguous subarray within an array (containing at least one number) which has the largest product.\n>\n> **Example 1:**\n>\n> ```\n> Input: [2,3,-2,4]\n> Output: 6\n> Explanation: [2,3] has the largest product 6.\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: [-2,0,-1]\n> Output: 0\n> Explanation: The result cannot be 2, because [-2,-1] is not a subarray.\n> ```\n\nSolution DP\n\n- 同时记录最大积和最小积，dp[i][0]表示以nums[i]结尾的子序列的最小积，dp[i][1]表示以nums[i]结尾的子序列的最大积。初始状态：\n  dp[0] [0] = nums[0];\n  dp[0] [1] = nums[0];\n- 由于可能存在负数，所以有三个数参与判断，状态转移方程：\n  dp[i] [0] = min( min(dp[i - 1] [0] * nums[i], dp[i - 1] [1] * nums[i]), nums[i])\n  dp[i] [1] = max( max(dp[i - 1] [0] * nums[i], dp[i - 1] [1] * nums[i]), nums[i])\n- 可以在用一个变量result记录结果，每次计算出最大积时就更新一下result，最后返回result就行，见下面我的代码1，时间复杂度是O(n)O(n)，空间复杂度是O(n)O(n)\n- 通过状态转移方程可以看出计算dp[i] []时只需要用到dp[i - 1] []，与dp[i - 2] []及前面的结果没有关系，因此空间复杂度可以进一步优化，只用两个变量localMin和localMax存储前一个位置的最大积和最小积\n\n```java\nclass Solution {\n    public int maxProduct(int[] nums) {\n        if (nums == null || nums.length == 0) return 0;\n        int localMin = nums[0];\n        int localMax = nums[0];\n        int globalMax = nums[0];\n        for (int i = 1; i < nums.length; i++) {\n            int tmp = localMin;\n            localMin = Math.min(Math.min(tmp * nums[i], localMax * nums[i]), nums[i]);\n            localMax = Math.max(Math.max(localMax * nums[i], tmp * nums[i]), nums[i]);\n            globalMax = Math.max(localMax, globalMax);\n        }\n        return globalMax;\n    }\n}\n```\n\n### 198.House Robber (Easy) [@](https://leetcode.com/problems/house-robber/)\n\n> You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\n>\n> Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight **without alerting the police**.\n>\n> **Example 1:**\n>\n> ```\n> Input: [1,2,3,1]\n> Output: 4\n> Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\n>           Total amount you can rob = 1 + 3 = 4.\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: [2,7,9,3,1]\n> Output: 12\n> Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\n>           Total amount you can rob = 2 + 9 + 1 = 12.\n> ```\n\nSolution 1 DP\n\n- 递推公式\n\n~~~\ndp[0] = num[0] （当i=0时）\ndp[1] = max(num[0], num[1]) （当i=1时）\ndp[i] = max(num[i] + dp[i - 2], dp[i - 1])   （当i !=0 and i != 1时）\n~~~\n\n```java\nclass Solution {\n    public int rob(int[] nums) {\n        if (nums == null || nums.length == 0) \n            return 0;\n        int[] dp = new int[nums.length+1];\n        for (int i = 0; i < nums.length; i++) {\n            if (i == 0)\n                dp[i] = nums[i];\n            else if (i == 1)\n                dp[i] = Math.max(nums[i], nums[i-1]);\n            else\n                dp[i] = Math.max(dp[i-2]+nums[i], dp[i-1]);\n        }\n        return dp[nums.length-1];\n    }\n}\n```\nSolution 2\n\n- 优化空间复杂度 O(1)\n\n```java\n    public int rob(int[] nums) {\n        int rob = 0, notrob = 0;\n        for (int i = 0; i < nums.length; i++) {\n            int temp = rob;\n            rob = notrob + nums[i];\n            notrob = Math.max(temp, notrob);\n        }\n        return Math.max(rob, notrob);\n    }\n```\n\n## Binary Search\n\n### 69. Sqrt(x) (Easy) [@](https://leetcode.com/problems/sqrtx/)\n\n> Implement `int sqrt(int x)`.\n>\n> Compute and return the square root of *x*, where *x* is guaranteed to be a non-negative integer.\n>\n> Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.\n>\n> **Example 1:**\n>\n> ```\n> Input: 4\n> Output: 2\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: 8\n> Output: 2\n> Explanation: The square root of 8 is 2.82842..., and since \n>           the decimal part is truncated, 2 is returned.\n> ```\n\n```\nclass Solution {\n    public int mySqrt(int x) {\n        if (x < 2) return x;\n        int left = 0;\n        int right = x/2+1;\n        long mid = 0;\n        while (left <= right) {\n            mid = (left + right) / 2;\n            if (mid * mid == x) {\n                return (int)mid;\n            }else if (mid * mid > x) {\n                right = (int)mid -1;\n            }else {\n                left = (int)mid + 1;\n            }\n        }\n        return right;\n    }\n}\n```\n### 162. Find Peak Element (Medium) [@](https://leetcode.com/problems/find-peak-element/)\n\n> A peak element is an element that is greater than its neighbors.\n>\n> Given an input array `nums`, where `nums[i] ≠ nums[i+1]`, find a peak element and return its index.\n>\n> The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.\n>\n> You may imagine that `nums[-1] = nums[n] = -∞`.\n>\n> **Example 1:**\n>\n> ```\n> Input: nums = [1,2,3,1]\n> Output: 2\n> Explanation: 3 is a peak element and your function should return the index number 2.\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: nums = [1,2,1,3,5,6,4]\n> Output: 1 or 5 \n> Explanation: Your function can return either index number 1 where the peak element is 2, \n>           or index number 5 where the peak element is 6.\n> ```\n\nSolution\n- 因为nums[-1] = nums[n] = -∞, 所以当nums[mid] < nums[mid+1] 时，mid右侧必定有peak，同理点那个nums[mid] >= nums[mid+1]时，mid及其左侧必有peak\n```\nclass Solution {\n    public int findPeakElement(int[] nums) {\n        int n = nums.length;\n        int left = 0, right = n-1;\n        while (left < right) {\n            int mid = (left + right) / 2;\n            if (nums[mid] < nums[mid+1]) {\n                //mid右侧必定有peak\n                left = mid + 1;\n            }else {\n                //包括mid在内左侧必有peak\n                right = mid;\n            }\n        }\n        return left;\n    }\n}\n```\n\n## Greedy\n\n### 55. Jump Game (Medium) [@](https://leetcode.com/problems/jump-game/)\n\n> Given an array of non-negative integers, you are initially positioned at the first index of the array.\n>\n> Each element in the array represents your maximum jump length at that position.\n>\n> Determine if you are able to reach the last index.\n>\n> **Example 1:**\n>\n> ```\n> Input: [2,3,1,1,4]\n> Output: true\n> Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: [3,2,1,0,4]\n> Output: false\n> Explanation: You will always arrive at index 3 no matter what. Its maximum\n>           jump length is 0, which makes it impossible to reach the last index.\n> ```\n\nSolution 1 Greedy\n- 维护一个reach（最远可达距离），每次前进一步，如果i一直在reach范围内，则可达\n```\nclass Solution {\n    public boolean canJump(int[] nums) {\n        int reach = 0;\n        for (int i = 0; i < nums.length; i++) {\n            if (i > reach)\n                return false;\n            reach = Math.max(reach, i + nums[i]);\n        }\n        return true;\n    }\n}\n```\n\nSolution 2 Zero Point\n- 若无0点则一定可达任一点\n- 故只需考虑0点，判断可否跳过此0点即此0点向前数第k个位置的元素大于k即可跳过\n```\nclass Solution {\n    public boolean canJump(int[] nums) {\n        int i = nums.length - 2; //0点\n        while(i >= 0) {\n            if (nums[i] == 0) {\n                int j = i - 1;//向前找可以跳过0点的位置\n                while (j >= 0) {\n                    if (j + nums[j] > i) {\n                        break;\n                    }\n                    j--;\n                }\n                if (j == -1)\n                    return false;\n            }\n            i--;\n        }\n        return true;\n    }\n}\n```\n\n### 122. Best Time to Buy and Sell Stock II (Easy) [@](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/)\n> Say you have an array for which the *i*th element is the price of a given stock on day *i*.\n>\n> Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).\n>\n> **Note:** You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).\n>\n> **Example 1:**\n>\n> ```\n> Input: [7,1,5,3,6,4]\n> Output: 7\n> Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\n>           Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: [1,2,3,4,5]\n> Output: 4\n> Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\n>           Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are\n>           engaging multiple transactions at the same time. You must sell before buying again.\n> ```\n>\n> **Example 3:**\n>\n> ```\n> Input: [7,6,4,3,1]\n> Output: 0\n> Explanation: In this case, no transaction is done, i.e. max profit = 0.\n> ```\n\nSolution Greedy\n\n- 累计所有前低后高的差值\n```\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int profit = 0;\n        for (int i = 1; i < prices.length; i++) {\n            if (prices[i] - prices[i-1] > 0)\n                profit += prices[i] - prices[i-1];\n        }\n        return profit;\n    }\n}\n```\n\n### 134. Gas Station (Medium) [@](https://leetcode.com/problems/gas-station/)\n\n> There are *N* gas stations along a circular route, where the amount of gas at station *i* is `gas[i]`.\n>\n> You have a car with an unlimited gas tank and it costs `cost[i]` of gas to travel from station *i* to its next station (*i*+1). You begin the journey with an empty tank at one of the gas stations.\n>\n> Return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1.\n>\n> **Note:**\n>\n> - If there exists a solution, it is guaranteed to be unique.\n> - Both input arrays are non-empty and have the same length.\n> - Each element in the input arrays is a non-negative integer.\n>\n> **Example 1:**\n>\n> ```\n> Input: \n> gas  = [1,2,3,4,5]\n> cost = [3,4,5,1,2]\n> \n> Output: 3\n> \n> Explanation:\n> Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\n> Travel to station 4. Your tank = 4 - 1 + 5 = 8\n> Travel to station 0. Your tank = 8 - 2 + 1 = 7\n> Travel to station 1. Your tank = 7 - 3 + 2 = 6\n> Travel to station 2. Your tank = 6 - 4 + 3 = 5\n> Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.\n> Therefore, return 3 as the starting index.\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: \n> gas  = [2,3,4]\n> cost = [3,4,3]\n> \n> Output: -1\n> \n> Explanation:\n> You can't start at station 0 or 1, as there is not enough gas to travel to the next station.\n> Let's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\n> Travel to station 0. Your tank = 4 - 3 + 2 = 3\n> Travel to station 1. Your tank = 3 - 3 + 3 = 3\n> You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.\n> Therefore, you can't travel around the circuit once no matter where you start.\n> ```\n\nSolution Greedy\n- sum(gas) >= sum(cost) => 有解\n- 只要找到一个起点i，从这个点出发的所有gas的和总比cost和打即可\n```\nclass Solution {\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n        int sum = 0, subsum = 0, begin = 0;\n        for (int i = 0; i < gas.length; i++) {\n            sum += gas[i] - cost[i];\n            subsum += gas[i] - cost[i];\n            if (subsum < 0) {\n                subsum = 0;\n                begin = i + 1;\n            }\n        }\n        if (sum < 0) return -1;\n        return begin;\n    }\n}\n```\n## Tree\n\n### 94. Binary Tree Inorder Traversal (Medium)  [@](https://leetcode.com/problems/binary-tree-inorder-traversal/)\n\n> Given a binary tree, return the *inorder* traversal of its nodes' values.\n>\n> **Example:**\n>\n> ```\n> Input: [1,null,2,3]\n> 1\n>  \\\n>   2\n>  /\n> 3\n> \n> Output: [1,3,2]\n> ```\n>\n> **Follow up:** Recursive solution is trivial, could you do it iteratively?\n\nSolution 1 Recursion\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> res = new ArrayList<>();\n        helper(root, res);\n        return res;\n    }\n    private void helper(TreeNode root, List<Integer> res) {\n        if (root != null) {\n            if (root.left != null) {\n                helper(root.left, res);\n            }\n            res.add(root.val);\n            if (root.right != null) {\n                helper(root.right, res);\n            }\n        }\n    }\n}\n```\n\nSolution 2 Stack\n\n```java\nclass Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> res = new ArrayList<>();\n        Stack<TreeNode> stack = new Stack<>();\n        TreeNode cur = root;\n        while (cur != null || !stack.isEmpty()) {\n            while (cur != null) {\n                stack.push(cur);\n                cur = cur.left;\n            }\n            cur = stack.pop();\n            res.add(cur.val);\n            cur = cur.right;\n        }\n        return res;\n    }\n}\n```\n\n## Backtracking\n\n### 78. Subsets (Medium) [@](https://leetcode.com/problems/subsets/)\n\n> Given a set of **distinct** integers, *nums*, return all possible subsets (the power set).\n>\n> **Note:** The solution set must not contain duplicate subsets.\n>\n> **Example:**\n>\n> ```\n> Input: nums = [1,2,3]\n> Output:\n> [\n> [3],\n> [1],\n> [2],\n> [1,2,3],\n> [1,3],\n> [2,3],\n> [1,2],\n> []\n> ]\n> ```\n\nSolution 1 Recursion\n```java\nclass Solution {\n    public List<List<Integer>> subsets(int[] nums) {\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\n        List<Integer> cur = new ArrayList<Integer>();\n        backtrack(res, cur, nums, 0);\n        return res;\n    }\n    private void backtrack(List<List<Integer>> res, List<Integer> cur, int[] nums, int j) {\n        res.add(new ArrayList<Integer>(cur));\n        for (int i = j; i < nums.length; i++) {\n            cur.add(nums[i]);//add nums[i]\n            backtrack(res, cur, nums, i+1);// Recursion\n            cur.remove(cur.size()-1);//remove nums[i]\n        }\n    }\n}\n```\nSolution 2 Iteration\n```java\nclass Solution {\n    public List<List<Integer>> subsets(int[] nums) {\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\n        res.add(new ArrayList<Integer>());\n        for (int num : nums) { //pick up each element from nums\n            int size = res.size();\n            for (int i = 0; i < size; i++) {\n                //pick up each element in current res\n                List<Integer> temp = new ArrayList<Integer>(res.get(i));\n                temp.add(num);//put num into temp\n                res.add(temp);//add temp into res\n            }\n        }\n        return res;\n    }\n}\n```\n\n### 79. Word Search (Medium) [@](https://leetcode.com/problems/word-search/)\n\n> Given a 2D board and a word, find if the word exists in the grid.\n>\n> The word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\n>\n> **Example:**\n>\n> ```\n> board =\n> [\n> ['A','B','C','E'],\n> ['S','F','C','S'],\n> ['A','D','E','E']\n> ]\n> \n> Given word = \"ABCCED\", return true.\n> Given word = \"SEE\", return true.\n> Given word = \"ABCB\", return false.\n> ```\n\nSolution dfs + backtrack\n```java\nclass Solution {\n    //direction: right, down, left, up\n    int[] drow = {0, 1, 0, -1};\n    int[] dcol = {1, 0, -1, 0};\n    public boolean exist(char[][] board, String word) {\n        boolean[][] isVisited = new boolean[board.length][board[0].length];\n        for (int i = 0; i < board.length; i++) {\n            for (int j = 0; j < board[0].length; j++) {\n                if (isThisWay(board, word, i, j, 0, isVisited))\n                    return true;\n            }\n        }\n        return false;\n    }\n    \n    private boolean isThisWay(char[][] board, String word, int row, int col, int index, boolean[][] isVisited) {\n        if (row < 0 || row >= board.length || col < 0 || col >= board[0].length || isVisited[row][col] || board[row][col] != word.charAt(index))\n            return false;\n        if (++index == word.length())\n            return true; // complete matching\n        isVisited[row][col] = true;\n        for (int i = 0; i < 4; i++) {\n            if (isThisWay(board, word, row + drow[i], col + dcol[i], index, isVisited))\n                return true;\n        }\n        isVisited[row][col] = false;//backtrack if false\n        return false;\n    }\n}\n```\n\n### 131. Palindrome Partitioning (Medium) [@](https://leetcode.com/problems/palindrome-partitioning/)\n\nSolution DFS + backtracking\n- 递归寻找子问题，如果子串回文，则加入res\n```java\nclass Solution {\n    public List<List<String>> partition(String s) {\n        List<List<String>> res = new ArrayList<List<String>>();\n        List<String> cur = new ArrayList<String>();\n        if (s.length() == 0 || s == null) return res;\n        \n        backtrack(s, 0, cur, res);\n        return res;\n    }\n    \n    private void backtrack(String s, int start, List<String> cur, List<List<String>> res) {\n        //recursion complete condition\n        if (start == s.length()) {\n            res.add(new ArrayList<String>(cur));\n            return;\n        }\n        for (int i = start; i < s.length(); i++) {\n            String str = s.substring(start, i + 1);\n            if (isPalindrome(str)) {\n                cur.add(str);\n                backtrack(s, i+1, cur, res);\n                cur.remove(cur.size()-1);\n            }\n        }\n    }\n    \n    private boolean isPalindrome(String str) {\n        int left = 0, right = str.length() - 1;\n        while (left < right) {\n            if (str.charAt(left) != str.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        return true;\n    }\n}\n```\n### 212. Word Search II (Hard) [@](https://leetcode.com/problems/word-search-ii/)\n\n> Given a 2D board and a list of words from the dictionary, find all words in the board.\n>\n> Each word must be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\n>\n> \n>\n> **Example:**\n>\n> ```\n> Input: \n> board = [\n> ['o','a','a','n'],\n> ['e','t','a','e'],\n> ['i','h','k','r'],\n> ['i','f','l','v']\n> ]\n> words = [\"oath\",\"pea\",\"eat\",\"rain\"]\n> \n> Output: [\"eat\",\"oath\"]\n> ```\n>\n> \n>\n> **Note:**\n>\n> 1. All inputs are consist of lowercase letters `a-z`.\n> 2. The values of `words` are distinct.\n\n[Solution](https://www.cnblogs.com/Dylan-Java-NYC/p/4944555.html) Tire + DFS\n\n> [Word Search](http://www.cnblogs.com/Dylan-Java-NYC/p/4944270.html)的进阶版题目，同时可以利用[Implement Trie (Prefix Tree)](http://www.cnblogs.com/Dylan-Java-NYC/p/4888830.html).\n>\n> 生成Trie树，把所有的词都insert进去。\n>\n> 然后从board上的每一个char开始dfs查找。\n>\n> 终止条件有两个， 一个 i 和 j 出界，或者board[i][j]已经用过了. 另一个是把board[i][j]加到当前item后，若没有以更新过item为prefix的时候就可以返回了.\n>\n> search 更新过的item, 若是有就加到res中, **并且继续，这里不能return,** 因为有可能有 \"aabc\" \"aabcb\"两个词同时存在的情况，只检查了\"aabc\"就return会漏掉\"aabcb\".\n>\n> 标记当前used为true, 然后board四个方向都做recursion. used再改回来.\n>\n> Note: 如果board 是[a a], words 只有一个[a], 此时小心重复加了，所以要用HashSet生成res, 最后再用res生成的List返回。\n>\n> m = board.length, n = board[0].length, k = words.length, l 是 word的平均长度.\n>\n> Time Complexity: O(k*l + m*n*l*4^l). k*l是简历Trie用时间. m*n是外部循环, l是search Trie时间, 4^l是recursion + backtracking的时间.\n>\n> Space: O(k*l + l). k*l是Trie数的大小. 用了l层stack.\n\n```java\npublic class Solution {\n    public List<String> findWords(char[][] board, String[] words) {\n        HashSet<String> res = new HashSet<String>();\n        if(words == null || words.length == 0 || board == null || board.length == 0 || board[0].length == 0){\n            return new ArrayList(res);\n        }\n        Trie trie = new Trie();\n        for(int i = 0; i<words.length; i++){\n            trie.insert(words[i]);\n        }\n        \n        boolean [][] used = new boolean[board.length][board[0].length];\n        for(int i = 0; i<board.length; i++){\n            for(int j = 0; j<board[0].length; j++){\n                findHelper(board,trie,used,\"\",i,j,res);\n            }\n        }\n        return new ArrayList(res);\n    }\n    private void findHelper(char[][] board, Trie trie, boolean [][] used, String item, int i, int j, HashSet<String> res){\n        \n        if(i<0 || j<0 || i>= board.length || j>=board[0].length || used[i][j]){\n            return;\n        }\n        \n        item = item+board[i][j];\n        if(!trie.startsWith(item)){\n            return;\n        }\n        if(trie.search(item)){\n            res.add(item);\n        }\n        used[i][j] = true;\n        findHelper(board,trie,used,item,i+1,j,res);\n        findHelper(board,trie,used,item,i-1,j,res);\n        findHelper(board,trie,used,item,i,j+1,res);\n        findHelper(board,trie,used,item,i,j-1,res);\n        used[i][j] = false;\n    }\n}\n\n\nclass TrieNode{\n    String val = \"\";\n    TrieNode [] nexts;\n    public TrieNode(){\n        nexts = new TrieNode[26];\n    }\n}\nclass Trie{\n    private TrieNode root;\n    public Trie(){\n        root = new TrieNode();\n    }\n    \n    public void insert(String word){\n        TrieNode p = root;\n        for(char c : word.toCharArray()){\n            if(p.nexts[c-'a'] == null){\n                p.nexts[c-'a'] = new TrieNode();\n            }\n            p = p.nexts[c-'a'];\n        }\n        p.val = word;\n    }\n    \n    public boolean search(String word){\n        TrieNode p = root;\n        for(char c : word.toCharArray()){\n            if(p.nexts[c-'a'] == null){\n                return false;\n            }\n            p = p.nexts[c-'a'];\n        }\n        return p.val.equals(word);\n    }\n    \n    public boolean startsWith(String prefix){\n        TrieNode p = root;\n        for(char c : prefix.toCharArray()){\n            if(p.nexts[c-'a'] == null){\n                return false;\n            }\n            p = p.nexts[c-'a'];\n        }\n        return true;\n    }\n}\n```\n## String\n\n### 12. Integer to Roman (Easy) [@](https://leetcode.com/problems/integer-to-roman/)\n\n> Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D` and `M`.\n>\n> ```\n> Symbol       Value\n> I             1\n> V             5\n> X             10\n> L             50\n> C             100\n> D             500\n> M             1000\n> ```\n>\n> For example, two is written as `II` in Roman numeral, just two one's added together. Twelve is written as, `XII`, which is simply `X` + `II`. The number twenty seven is written as `XXVII`, which is `XX` + `V` + `II`.\n>\n> Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not `IIII`. Instead, the number four is written as `IV`. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as `IX`. There are six instances where subtraction is used:\n>\n> - `I` can be placed before `V` (5) and `X` (10) to make 4 and 9. \n> - `X` can be placed before `L` (50) and `C` (100) to make 40 and 90. \n> - `C` can be placed before `D` (500) and `M` (1000) to make 400 and 900.\n>\n> Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.\n>\n> **Example 1:**\n>\n> ```\n> Input: 3\n> Output: \"III\"\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: 4\n> Output: \"IV\"\n> ```\n>\n> **Example 3:**\n>\n> ```\n> Input: 9\n> Output: \"IX\"\n> ```\n>\n> **Example 4:**\n>\n> ```\n> Input: 58\n> Output: \"LVIII\"\n> Explanation: L = 50, V = 5, III = 3.\n> ```\n\nSolution\n\n- 计算每个位的值，并用对应字符串表示\n\n```java\nclass Solution {\n    public String intToRoman(int num) {\n        String[] M = {\"\", \"M\", \"MM\", \"MMM\"};\n        String[] C = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\n        String[] X = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\n        String[] I = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\n        \n        return M[(num/1000)]+C[(num%1000)/100]+X[(num%100)/10]+I[(num%10)];\n    }\n}\n```\n\n\n\n### 13. Roman to Integer (Easy) [@](https://leetcode.com/problems/roman-to-integer/)\n\n> Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D` and `M`.\n>\n> ```\n> Symbol       Value\n> I             1\n> V             5\n> X             10\n> L             50\n> C             100\n> D             500\n> M             1000\n> ```\n>\n> For example, two is written as `II` in Roman numeral, just two one's added together. Twelve is written as, `XII`, which is simply `X` + `II`. The number twenty seven is written as `XXVII`, which is `XX` + `V` + `II`.\n>\n> Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not `IIII`. Instead, the number four is written as `IV`. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as `IX`. There are six instances where subtraction is used:\n>\n> - `I` can be placed before `V` (5) and `X` (10) to make 4 and 9. \n> - `X` can be placed before `L` (50) and `C` (100) to make 40 and 90. \n> - `C` can be placed before `D` (500) and `M` (1000) to make 400 and 900.\n>\n> Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.\n>\n> **Example 1:**\n>\n> ```\n> Input: \"III\"\n> Output: 3\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: \"IV\"\n> Output: 4\n> ```\n>\n> **Example 3:**\n>\n> ```\n> Input: \"IX\"\n> Output: 9\n> ```\n>\n> **Example 4:**\n>\n> ```\n> Input: \"LVIII\"\n> Output: 58\n> Explanation: L = 50, V= 5, III = 3.\n> ```\n>\n> **Example 5:**\n>\n> ```\n> Input: \"MCMXCIV\"\n> Output: 1994\n> Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n> ```\n\nSolution 1\n\n```java\nclass Solution {\n    public int romanToInt(String s) {\n        HashMap<Character, Integer> hm = new HashMap<Character, Integer>();\n        hm.put('I', 1);\n        hm.put('V', 5);\n        hm.put('X', 10);\n        hm.put('L', 50);\n        hm.put('C', 100);\n        hm.put('D', 500);\n        hm.put('M', 1000);\n        \n        int maxDigit = 0, val = 0;\n        for (int i = s.length() - 1; i >= 0; i--) {\n            int cur = hm.get(s.charAt(i));\n            if (cur >= maxDigit) {\n                val += cur;\n                maxDigit = cur;\n            }else {\n                val -= cur;\n            }\n        }\n        return val;\n    }\n}\n```\n\nSolution 2\n\n- 仅有 I X C 可能成为前缀，所以遇到需要考虑是否更新前缀\n\n```java\nclass Solution {\n    public static int romanToInt(String s) {\n        int x = 0;\n        char prev = ' ';\n        for (int i = 0; i < s.length(); i++) {\n            // if (prev == ' ') prev = s.charAt(i);\n            \n            switch (s.charAt(i)) {\n                case 'M':\n                    x += prev == 'C' ? 900 : 1000;\n                    break;\n                case 'D':\n                    x += prev == 'C' ? 400 : 500;\n                    break;\n                case 'C':\n                    if (i < s.length() - 1 && (s.charAt(i + 1) == 'D' || s.charAt(i + 1) == 'M')) {\n                        prev = 'C';\n                    } else {\n                        x += prev == 'X' ? 90 : 100;\n                    }\n                    break;\n                case 'L':\n                    x += prev == 'X' ? 40 : 50;\n                    break;\n                case 'X':\n                    if (i < s.length() - 1 && (s.charAt(i + 1) == 'L' || s.charAt(i + 1) == 'C')) {\n                        prev = 'X';\n                    } else {\n                        x += prev == 'I' ? 9 : 10;\n                    }\n                    break;\n                case 'V':\n                    x += prev == 'I' ? 4 : 5;\n                    break;\n                case 'I':\n                    if (i < s.length() - 1 && (s.charAt(i + 1) == 'V' || s.charAt(i + 1) == 'X')) {\n                        prev = 'I';\n                    } else {\n                        x += 1;\n                    }\n                    break;\n            }\n        }\n        return x;\n    }\n}\n```\n\n\n\n### 14. Longest Common Prefix (Easy) [@](https://leetcode.com/problems/longest-common-prefix/)\n\n> Write a function to find the longest common prefix string amongst an array of strings.\n>\n> If there is no common prefix, return an empty string `\"\"`.\n>\n> **Example 1:**\n>\n> ```\n> Input: [\"flower\",\"flow\",\"flight\"]\n> Output: \"fl\"\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: [\"dog\",\"racecar\",\"car\"]\n> Output: \"\"\n> Explanation: There is no common prefix among the input strings.\n> ```\n>\n> **Note:**\n>\n> All given inputs are in lowercase letters `a-z`.\n\nSolution 1 Recursion + Divide and Conquer\n\n- 二分所有串，一半一半考虑找出commonPrefix\n\n```java\nclass Solution {\n    public String longestCommonPrefix(String[] strs) {\n        if (strs.length == 0 || strs == null) return \"\"; //特殊情况\n        return longestCommonPrefix(strs, 0, strs.length-1);\n    }\n    private String longestCommonPrefix(String[] strs, int l, int r) {\n        if (l == r) {\n            return strs[l];\n        }else {\n            int mid = (l+r)/2;\n            String lcpLeft = longestCommonPrefix(strs, l, mid);//左区间\n            String lcpRight = longestCommonPrefix(strs, mid+1, r);//右区间\n            return commonPrefix(lcpLeft, lcpRight);\n        }\n    }\n    private String commonPrefix(String ls, String rs) {\n        int min = Math.min(ls.length(), rs.length());\n        for (int i = 0; i<min; i++) {\n            if (ls.charAt(i) != rs.charAt(i)) {\n                return ls.substring(0,i);\n            }\n        }\n        return ls.substring(0,min);\n    }\n}\n```\n\nSolution 2 Divide and Conquer\n\n- 假设commonPrefix长度，二分最短串长度\n- 如果存在，则l和r最后汇聚在commonPrefix的尾部\n\n```java\nclass Solution {\n    public String longestCommonPrefix(String[] strs) {\n        if (strs.length == 0 || strs == null) {\n            return \"\";\n        }\n        \n        int minLen = Integer.MAX_VALUE;\n        for (int i = 0; i < strs.length; i++) {\n            minLen = Math.min(strs[i].length(), minLen);\n        }\n        int l = 0, r = minLen;\n        while (l <= r) {\n            int mid = (l + r) / 2;\n            if (isCommonPrefix(strs, mid)) {\n                l = mid + 1;\n            }else {\n                r= mid - 1;\n            }\n        }\n        return strs[0].substring(0, (l+r)/2);\n    }\n    private boolean isCommonPrefix(String[] strs, int len) {\n        String s = strs[0].substring(0, len);\n        for (int i = 1; i < strs.length; i++) {\n            if (!strs[i].startsWith(s)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n\n\n### 28. Implement strStr()  (Easy)  [@](https://leetcode.com/problems/implement-strstr/)\n\n> Implement [strStr()](http://www.cplusplus.com/reference/cstring/strstr/).\n>\n> Return the index of the first occurrence of needle in haystack, or **-1** if needle is not part of haystack.\n>\n> **Example 1:**\n>\n> ```\n> Input: haystack = \"hello\", needle = \"ll\"\n> Output: 2\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: haystack = \"aaaaa\", needle = \"bba\"\n> Output: -1\n> ```\n\nSolution 1 Iteration\n\n```java\nclass Solution {\n    public int strStr(String haystack, String needle) {\n        if (needle.length() == 0) return 0;\n        for (int i = 0; i < haystack.length() - needle.length() + 1; i++) {\n            if (haystack.charAt(i) == needle.charAt(0)) {\n                int j = 1;\n                while (j < needle.length() && haystack.charAt(i+j) == needle.charAt(j)) {\n                    j++;\n                }\n                if (j == needle.length())\n                    return i;\n            }\n        }\n        return -1;\n    }\n}\n```\n\nSolution 2 KMP (Knuth–Morris–Pratt [string-searching algorithm](https://en.wikipedia.org/wiki/String-searching_algorithm))\n\n- 核心是PMT(Partial Match Table)数组：前缀B -- A=BS (S为非空字符串)；PMT 中的值是字符串的前缀集合与后缀集合的交集中最长元素的长度\n- ![IMG_0923.JPG](:/67dad347bcda4fb7998271ac90779b10)\n\n```java\nclass Solution {\n    public int strStr(String haystack, String needle) {\n        if (needle.length() == 0) return 0;\n        int i = 0, j = -1, N = needle.length(), M = haystack.length();\n        int[] next = new int[N];\n        next[0] = -1;\n        while (i < N-1) {// generate next array\n            if (j == -1 || needle.charAt(i) == needle.charAt(j)) {\n                i++;\n                j++;\n                next[i] = j;\n            }else {\n                j = next[j];\n            }\n        }\n        \n        i = 0; j = 0;\n        while (i < M && j < N) {\n            if (j == -1 || haystack.charAt(i) == needle.charAt(j)) {\n                i++;\n                j++;\n            }else {\n                j = next[j];\n            }\n        }\n        if (j == N) \n            return i-j;\n        return -1;\n    }\n}\n```\n\nSolution 3 HashMap\n\n- 直接containsKey匹配子串\n\n```java\nclass Solution {\n    public int strStr(String haystack, String needle) {\n        if (needle.length() == 0) return 0;\n        if (needle.length() > haystack.length()) return -1;\n        \n        HashMap<String, Integer> map = new HashMap<>();\n        map.put(haystack, 0);\n        //put each needle-len substring of haystack into the hashmap\n        for (int i = 0; i <= haystack.length() - needle.length(); i++) {\n            if (map.containsKey(needle)) {\n                return map.get(needle);\n            }\n            map.put(haystack.substring(i, i+needle.length()), i);\n        }\n        return map.getOrDefault(needle, -1);\n    }\n}\n```\n\n\n\n### 38. Count and Say (Easy) [@](https://leetcode.com/problems/count-and-say/)\n\n> The count-and-say sequence is the sequence of integers with the first five terms as following:\n>\n> ```\n> 1.     1\n> 2.     11\n> 3.     21\n> 4.     1211\n> 5.     111221\n> ```\n>\n> `1` is read off as `\"one 1\"` or `11`.\n> `11` is read off as `\"two 1s\"` or `21`.\n> `21` is read off as `\"one 2`, then `one 1\"` or `1211`.\n>\n> Given an integer *n* where 1 ≤ *n* ≤ 30, generate the *n*th term of the count-and-say sequence. You can do so recursively, in other words from the previous member read off the digits, counting the number of digits in groups of the same digit.\n>\n> Note: Each term of the sequence of integers will be represented as a string.\n>\n>  \n>\n> **Example 1:**\n>\n> ```\n> Input: 1\n> Output: \"1\"\n> Explanation: This is the base case.\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: 4\n> Output: \"1211\"\n> Explanation: For n = 3 the term was \"21\" in which we have two groups \"2\" and \"1\", \"2\" can be read as \"12\" which means frequency = 1 and value = 2, the same way \"1\" is read as \"11\", so the answer is the concatenation of \"12\" and \"11\" which is \"1211\".\n> ```\n\nSolution 1 Recursion\n\n```java\nclass Solution {\n    public String countAndSay(int n) {\n        if (n == 1) {\n            return \"1\";\n        }else {\n            String preStr = countAndSay(n-1);\n            String res = \"\";\n            int len = 1; //len of same char\n            int i = 1; //idx of preStr\n            //scan preStr to determine the following string\n            while (i < preStr.length()) {\n                if (preStr.charAt(i) == preStr.charAt(i-1)) {\n                    len++;\n                }else {\n                    res += String.valueOf(len) + String.valueOf(preStr.charAt(i-1));\n                    len = 1; //reset len of same char\n                }\n                i++;\n            }\n            res += String.valueOf(len) + String.valueOf(preStr.charAt(i-1));\n            return res.toString();\n        }\n    }\n}\n```\n\nSolution 1 Improvement \n\n```java\nclass Solution {\n    public String countAndSay(int n) {\n        if (n == 1) {\n            return \"1\";\n        }else {\n            String preStr = countAndSay(n-1);\n            StringBuilder res = new StringBuilder();\n            int len = 1; //len of same char\n            int i = 1; //idx of preStr\n            //scan preStr to determine the following string\n            while (i < preStr.length()) {\n                if (preStr.charAt(i) == preStr.charAt(i-1)) {\n                    len++;\n                }else {\n                    // res += String.valueOf(len) + String.valueOf(preStr.charAt(i-1));\n                    res.append(len).append(preStr.charAt(i-1));\n                    len = 1; //reset len of same char\n                }\n                i++;\n            }\n            // res += String.valueOf(len) + String.valueOf(preStr.charAt(i-1));\n            res.append(len).append(preStr.charAt(i-1));\n            return res.toString();\n        }\n    }\n}\n```\n\n\n\nSolution 2 Recursion\n\n```java\nclass Solution {\n    public String countAndSay(int n) {\n        if (n == 1) {\n            return \"1\";\n        }\n        return read(countAndSay(n-1));\n    }\n    private String read(String preStr) {\n        StringBuilder res = new StringBuilder();\n        for (int i = 0; i < preStr.length(); i++) {\n            char c = preStr.charAt(i); //current char\n            int len = 1; //len of same char\n            //find and append next \"len+c\"\n            while ((i+1) < preStr.length()) {\n                if (preStr.charAt(i+1) != c) {\n                    break;\n                } else {\n                    i++;\n                    len++;\n                }\n            }\n            res.append(len).append(c);\n        }\n        return res.toString();\n    }\n}\n```\n\n\n\n### 49. Group Anagrams (Medium) [@](https://leetcode.com/problems/group-anagrams/)\n\n> Given an array of strings, group anagrams together.\n>\n> **Example:**\n>\n> ```\n> Input: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"],\n> Output:\n> [\n> [\"ate\",\"eat\",\"tea\"],\n> [\"nat\",\"tan\"],\n> [\"bat\"]\n> ]\n> ```\n>\n> **Note:**\n>\n> - All inputs will be in lowercase.\n> - The order of your output does not matter.\n\nSolution 1 Hash Map\n\n- sort(str) 找到同字母的串\n\n```java\nclass Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        if(strs == null || strs.length == 0) {\n            List<List<String>> ans = new ArrayList<List<String>>();\n            return ans;\n        }\n        \n        HashMap<String, List<String>> hash = new HashMap<String, List<String>>();\n        for (String str:strs) {\n            char[] c = str.toCharArray();\n            Arrays.sort(c);\n            String temp = String.valueOf(c);\n            if (!hash.containsKey(temp)) {\n                List<String> vals = new ArrayList<String>();\n                vals.add(str);\n                hash.put(temp, vals);\n            }else {\n                hash.get(temp).add(str);\n            }\n        }\n        List<List<String>> ans = new ArrayList<List<String>>();\n        ans.addAll(hash.values());\n        return ans;\n    }\n}\n```\n\nSolution 2 Hash Map + Prime Number\n\n- 每个字母对应一个质数，计算所有字符串的积\n\n```java\nclass Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        //26个质数对应26个字母\n        int[] primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103};\n        List<List<String>> ans = new ArrayList<List<String>>();\n        HashMap<Integer, List<String>> hash = new HashMap<Integer, List<String>>();\n        for (String str:strs) {\n            int key = 1;\n            for (char c : str.toCharArray()) {\n                key *= primes[c-'a'];\n            }\n            if (!hash.containsKey(key)) {\n                List<String> vals = new ArrayList<String>();\n                vals.add(str);\n                hash.put(key, vals);\n            } else {\n                hash.get(key).add(str);\n            }\n        }\n        ans.addAll(hash.values());\n        return ans;\n    }\n}\n```\n\n\n\n### 58. Length of Last Word (Easy) [@](https://leetcode.com/problems/length-of-last-word/)\n\n> Given a string *s* consists of upper/lower-case alphabets and empty space characters `' '`, return the length of last word (last word means the last appearing word if we loop from left to right) in the string.\n>\n> If the last word does not exist, return 0.\n>\n> **Note:** A word is defined as a **maximal substring** consisting of non-space characters only.\n>\n> **Example:**\n>\n> ```\n> Input: \"Hello World\"\n> Output: 5\n> ```\n\nSolution \n\n- Start = 第一个非' '字符\n- End = 下一个‘ ’\n- 注意while条件顺序，首先判断是否越界\n\n```java\nclass Solution {\n    public int lengthOfLastWord(String s) {\n        if (s == null || s.length() == 0) return 0;\n        \n        int count = 0;\n        int first = s.length() - 1;\n        //the first not-' ' character --- start\n        while (first >= 0 && s.charAt(first) == ' ')\n            first--;\n        //next ' ' position --- end\n        while (first >= 0 && s.charAt(first) != ' ') {\n            first--;\n            count++;\n        }\n        return count;\n    }\n}\n```\n\n\n\n### 87.  Scramble String (Hard) [@](https://leetcode.com/problems/scramble-string/)\n\n> Given a string *s1*, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.\n>\n> Below is one possible representation of *s1* = `\"great\"`:\n>\n> ```\n>  great\n> /    \\\n> gr    eat\n> / \\    /  \\\n> g   r  e   at\n>         / \\\n>        a   t\n> ```\n>\n> To scramble the string, we may choose any non-leaf node and swap its two children.\n>\n> For example, if we choose the node `\"gr\"` and swap its two children, it produces a scrambled string `\"rgeat\"`.\n>\n> ```\n>  rgeat\n> /    \\\n> rg    eat\n> / \\    /  \\\n> r   g  e   at\n>         / \\\n>        a   t\n> ```\n>\n> We say that `\"rgeat\"` is a scrambled string of `\"great\"`.\n>\n> Similarly, if we continue to swap the children of nodes `\"eat\"` and `\"at\"`, it produces a scrambled string `\"rgtae\"`.\n>\n> ```\n>  rgtae\n> /    \\\n> rg    tae\n> / \\    /  \\\n> r   g  ta  e\n>     / \\\n>    t   a\n> ```\n>\n> We say that `\"rgtae\"` is a scrambled string of `\"great\"`.\n>\n> Given two strings *s1* and *s2* of the same length, determine if *s2* is a scrambled string of *s1*.\n>\n> **Example 1:**\n>\n> ```\n> Input: s1 = \"great\", s2 = \"rgeat\"\n> Output: true\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: s1 = \"abcde\", s2 = \"caebd\"\n> Output: false\n> ```\n\nSolution 1 Recursion\n\n```java\nclass Solution {\n    public boolean isScramble(String s1, String s2) {\n        //len of str\n        if (s1.length() != s2.length()) return false;\n        \n        if (s1.equals(s2)) return true;\n        \n        //num of letters\n        int[] letter = new int[26];\n        for (int i = 0; i < s1.length(); i++) {\n            letter[s1.charAt(i) - 'a']++;\n            letter[s2.charAt(i) - 'a']--;\n        }\n        //diff num of letters -> false\n        for (int i = 0; i < 26; i++) {\n            if (letter[i] != 0)\n                return false;\n        }\n        \n        //loop through all cut points\n        for (int i = 1; i < s1.length(); i++) {\n            if (isScramble(s1.substring(0, i), s2.substring(0, i)) && isScramble(s1.substring(i), s2.substring(i)))\n                return true;\n            //switch\n            if (isScramble(s1.substring(i), s2.substring(0, s2.length() - i)) && isScramble(s1.substring(0, i), s2.substring(s2.length() - i)))\n                return true;\n        }\n        return false;\n   }\n}\n```\n\nSolution 2 Recursion + Memorization\n\n```java\nclass Solution {\n    public boolean isScramble(String s1, String s2) {\n        HashMap<String, Integer> memo = new HashMap<>();\n        return isSrambleHelper(s1, s2, memo);\n    }\n    \n    private boolean isSrambleHelper(String s1, String s2, HashMap<String, Integer> memo) {\n        //previous res\n        int res = memo.getOrDefault(s1 + \"#\" + s2, -1);\n        if (res == 1)\n            return true;\n        else if (res == 0)\n            return false;\n        \n        //len of str\n        if (s1.length() != s2.length()) {\n            memo.put(s1 + \"#\" + s2, 0);\n            return false;\n        } \n        \n        if (s1.equals(s2)) {\n            memo.put(s1 + \"#\" + s2, 1);\n            return true;\n        } \n        \n        //num of letters\n        int[] letter = new int[26];\n        for (int i = 0; i < s1.length(); i++) {\n            letter[s1.charAt(i) - 'a']++;\n            letter[s2.charAt(i) - 'a']--;\n        }\n        //diff num of letters -> false\n        for (int i = 0; i < 26; i++) {\n            if (letter[i] != 0) {\n                memo.put(s1 + \"#\" + s2, 0);\n                return false;\n            }\n        }\n        \n        //loop through all cut points\n        for (int i = 1; i < s1.length(); i++) {\n            if (isScramble(s1.substring(0, i), s2.substring(0, i)) && isScramble(s1.substring(i), s2.substring(i))) {\n                memo.put(s1 + \"#\" + s2, 1);\n                return true;\n            }\n                \n            //switch\n            if (isScramble(s1.substring(i), s2.substring(0, s2.length() - i)) && isScramble(s1.substring(0, i), s2.substring(s2.length() - i))) {\n                memo.put(s1 + \"#\" + s2, 1);\n                return true;\n            }\n        }\n        memo.put(s1 + \"#\" + s2, 0);\n        return false;\n    }\n}\n```\n\nSolution 3 DP\n\n- [solution detail](https://leetcode-cn.com/problems/scramble-string/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-1-2/)\n\n```java\nclass Solution {\n    public boolean isScramble(String s1, String s2) {\n        //len of str\n        if (s1.length() != s2.length()) return false;\n        \n        if (s1.equals(s2)) return true;\n        \n        //num of letters\n        int[] letter = new int[26];\n        for (int i = 0; i < s1.length(); i++) {\n            letter[s1.charAt(i) - 'a']++;\n            letter[s2.charAt(i) - 'a']--;\n        }\n        //diff num of letters -> false\n        for (int i = 0; i < 26; i++) {\n            if (letter[i] != 0)\n                return false;\n        }\n        \n        int length = s1.length();\n        boolean[][][] dp = new boolean[length + 1][length][length];\n        //loop through all the len of str\n        for (int len = 1; len < length + 1; len++) {\n            //start of s1\n            for (int i = 0; i + len < length + 1; i++) {\n                //start of s2\n                for (int j = 0; j + len < length + 1; j++) {\n                    if (len == 1) {\n                        dp[len][i][j] = s1.charAt(i) == s2.charAt(j);\n                    } else {\n                        //loop through all the cut point\n                        for (int q = 1; q < len; q++) {\n                            dp[len][i][j] = (dp[q][i][j] && dp[len-q][i+q][j+q]) || (dp[q][i][j+len-q] && dp[len-q][i+q][j]);\n                            if (dp[len][i][j])\n                                break;\n                        }\n                    }\n                }\n            }\n        }\n        return dp[length][0][0];\n    }\n}\n```\n\n\n\n### 125. Valid Palindrome (Easy) [@](https://leetcode.com/problems/valid-palindrome/submissions/)\n\n> Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.\n>\n> **Note:** For the purpose of this problem, we define empty string as valid palindrome.\n>\n> **Example 1:**\n>\n> ```\n> Input: \"A man, a plan, a canal: Panama\"\n> Output: true\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: \"race a car\"\n> Output: false\n> ```\n\nSolution \n```java\nclass Solution {\n    public boolean isPalindrome(String s) {\n        if (s.length() == 0 || s == null) return true;\n        s = s.toLowerCase();\n        int left = 0, right = s.length() - 1;\n        while (left < right) {\n            if (!Character.isLetterOrDigit(s.charAt(left))) {\n                left ++;\n                continue;\n            }\n            if (!Character.isLetterOrDigit(s.charAt(right))) {\n                right --;\n                continue;\n            }\n            if (s.charAt(left) == s.charAt(right)) {\n                left ++;\n                right --;\n            }else {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n\n\n### 151. Reverse Words in a String (Medium)  [@](https://leetcode.com/problems/reverse-words-in-a-string/)\n\n> Given an input string, reverse the string word by word.\n>\n> **Example 1:**\n>\n> ```\n> Input: \"the sky is blue\"\n> Output: \"blue is sky the\"\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: \"  hello world!  \"\n> Output: \"world! hello\"\n> Explanation: Your reversed string should not contain leading or trailing spaces.\n> ```\n>\n> **Example 3:**\n>\n> ```\n> Input: \"a good   example\"\n> Output: \"example good a\"\n> Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string.\n> ```\n\nSolution 1 Library function\n\n```java\nclass Solution {\n    public String reverseWords(String s) {\n        StringBuilder ans = new StringBuilder();\n        //去掉s的首尾空格 然后将字符串拆分\n        String[] str = s.trim().split(\" \");\n        for(int i = str.length - 1; i >= 0; i--){\n            //空格后面的空格会变成空字符串\n            if(!str[i].equals(\"\")) ans.append(str[i] + \" \");\n        }\n        //去掉最后添加上的空格\n        ans = new StringBuilder(ans.toString().trim());\n        return ans.toString();\n    }\n}\n```\n\nSolution 2 从后向前\n\n- 将源字符串转换为数组，然后从后向前读取，遇到空格，判断是否单词结束\n\n```JAVA\nclass Solution {\n    public String reverseWords(String s) {\n        if (s == null || s.length() == 0) return \"\";\n        \n        char[] chars = s.toCharArray();\n        StringBuffer ans = new StringBuffer();\n        int count = 0, ptr = s.length()-1;\n        //从后向前扫描\n        while(ptr >= 0) {\n            //空格两种情况：单词结束 和 未开始\n            if (chars[ptr] == ' ') {\n                if (count != 0) {\n                    ans.append(chars, ptr + 1, count).append(' ');\n                    count = 0;//重置count\n                }\n            //遇到字母\n            }else {\n                count++;\n            }\n            ptr--;\n        }\n        //处理最后一个单词\n        if (count != 0) {\n            ans.append(chars, 0, count).append(' ');\n        }\n        //去除最后一个空格\n        return ans.length() == 0 ? \"\" : ans.toString().substring(0, ans.length()-1);\n    }\n}\n```\n\nSolution 3\n\n- 整句全部逆置，再逐个单词逆置\n\n### 166. Fraction to Recurring Decimal (Medium) [@](https://leetcode.com/problems/fraction-to-recurring-decimal/)\n\n> Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.\n>\n> If the fractional part is repeating, enclose the repeating part in parentheses.\n>\n> **Example 1:**\n>\n> ```\n> Input: numerator = 1, denominator = 2\n> Output: \"0.5\"\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: numerator = 2, denominator = 1\n> Output: \"2\"\n> ```\n>\n> **Example 3:**\n>\n> ```\n> Input: numerator = 2, denominator = 3\n> Output: \"0.(6)\"\n> ```\n\nSolution HashMap\n\n- 利用哈希表存储余数位置，以判断是否存在重复的对应小数位\n- 当出现重复则加入“（）”\n\n```java\nclass Solution {\n    public String fractionToDecimal(int numerator, int denominator) {\n        if (numerator == 0) return \"0\";\n        \n        StringBuilder fraction = new StringBuilder();\n        //positive or negative\n        if (numerator < 0 ^ denominator < 0) {\n            fraction.append(\"-\");\n        }\n        \n        Long dividend = Math.abs(Long.valueOf(numerator));\n        Long divisor = Math.abs(Long.valueOf(denominator));\n        //Integer Part\n        fraction.append(String.valueOf(dividend/divisor));\n        Long remainder = dividend % divisor;\n        if (remainder == 0) {\n            return fraction.toString();\n        }\n        //Decimal Part\n        fraction.append(\".\");\n        Map<Long, Integer> pos = new HashMap<>();\n        while (remainder != 0) {\n            //repeat\n            if (pos.containsKey(remainder)) {\n                fraction.insert(pos.get(remainder), \"(\");\n                fraction.append(\")\");\n                break;\n            }\n            //add new decimal num\n            pos.put(remainder, fraction.length()); //add remainder's position\n            remainder *= 10;\n            fraction.append(String.valueOf(remainder / divisor));//add corresponding decimal\n            remainder %= divisor;\n        }\n        return fraction.toString();\n    }\n}\n```\n\n\n\n### 168. Excel Sheet Column Title (Easy) [@](https://leetcode.com/problems/excel-sheet-column-title/)\n\n> Given a positive integer, return its corresponding column title as appear in an Excel sheet.\n>\n> For example:\n>\n> ```\n>  1 -> A\n>  2 -> B\n>  3 -> C\n>  ...\n>  26 -> Z\n>  27 -> AA\n>  28 -> AB \n>  ...\n> ```\n>\n> **Example 1:**\n>\n> ```\n> Input: 1\n> Output: \"A\"\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: 28\n> Output: \"AB\"\n> ```\n>\n> **Example 3:**\n>\n> ```\n> Input: 701\n> Output: \"ZY\"\n> ```\n\nSolution 进制转换\n\n- 注意是1 - 26 所以使用 n-1\n\n```java\nclass Solution {\n    public String convertToTitle(int n) {\n        StringBuilder str = new StringBuilder();\n        while (n > 0) {\n            str.insert(0, (char)((n-1)%26 + 'A'));\n            n = (n-1)/26;\n        }\n        return str.toString();\n    }\n}\n```\n\n\n\n### 171. Excel Sheet Column Number (Easy) [@](https://leetcode.com/problems/excel-sheet-column-number/)\n\n> Given a column title as appear in an Excel sheet, return its corresponding column number.\n>\n> For example:\n>\n> ```\n>  A -> 1\n>  B -> 2\n>  C -> 3\n>  ...\n>  Z -> 26\n>  AA -> 27\n>  AB -> 28 \n>  ...\n> ```\n>\n> **Example 1:**\n>\n> ```\n> Input: \"A\"\n> Output: 1\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: \"AB\"\n> Output: 28\n> ```\n>\n> **Example 3:**\n>\n> ```\n> Input: \"ZY\"\n> Output: 701\n> ```\n\nSolution\n\n```java\nclass Solution {\n    public int titleToNumber(String s) {\n        int ans = 0;\n        for (char c : s.toCharArray()) {\n            ans = ans * 26 + (int)(c - 'A' + 1);\n        }\n        return ans;\n    }\n}\n```\n\n\n\n### 179. Largest Number (Medium) [@](https://leetcode.com/problems/largest-number/)\n\n> Given a list of non negative integers, arrange them such that they form the largest number.\n>\n> **Example 1:**\n>\n> ```\n> Input: [10,2]\n> Output: \"210\"\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: [3,30,34,5,9]\n> Output: \"9534330\"\n> ```\n>\n> **Note:** The result may be very large, so you need to return a string instead of an integer.\n\nSolution \n\n```java\nclass Solution {\n    public class LargerNumberComparator implements Comparator<String> {\n        @Override\n        public int compare(String a, String b) {\n            String order1 = a + b;\n            String order2 = b + a;\n            return order2.compareTo(order1);\n        }\n    }\n    \n    public String largestNumber(int[] nums) {\n        //convert to strings\n        String[] asStrs = new String[nums.length];\n        for (int i = 0; i < nums.length; i++) {\n            asStrs[i] = String.valueOf(nums[i]);\n        }\n        \n        Arrays.sort(asStrs, new LargerNumberComparator());\n        \n        if (asStrs[0].equals(\"0\")) return \"0\";\n        \n        StringBuilder ans = new StringBuilder();\n        for (String str : asStrs) {\n            ans.append(str);\n        }\n        return ans.toString();\n    }\n}\n```\n\n\n\n\n\n### 205. Isomorphic Strings (Easy) [@](https://leetcode.com/problems/isomorphic-strings/)\n\n> Given two strings ***s\\*** and ***t\\***, determine if they are isomorphic.\n>\n> Two strings are isomorphic if the characters in ***s\\*** can be replaced to get ***t\\***.\n>\n> All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.\n>\n> **Example 1:**\n>\n> ```\n> Input: s = \"egg\", t = \"add\"\n> Output: true\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: s = \"foo\", t = \"bar\"\n> Output: false\n> ```\n>\n> **Example 3:**\n>\n> ```\n> Input: s = \"paper\", t = \"title\"\n> Output: true\n> ```\n>\n> **Note:**\n> You may assume both ***s\\*** and ***t\\*** have the same length.\n\nSolution 1 HashMap\n\n```java\nclass Solution {\n    public boolean isIsomorphic(String s, String t) {\n        if (s.length() != t.length()) return false;\n        //map -- match char in s and t\n        HashMap<Character, Character> map = new HashMap<>();\n        //set -- judge char in t whether has mapped\n        Set<Character> set = new HashSet<>();\n        char sChart, tChart;\n        for (int i = 0; i < s.length(); i++) {\n            sChart = s.charAt(i);\n            tChart = t.charAt(i);\n            \n            if(!map.containsKey(sChart)) {//no mapped\n                if (set.contains(tChart)) {//t has been mapped\n                    return false;\n                }else {\n                    map.put(sChart, tChart);\n                    set.add(tChart);\n                }\n            }else {//mapped\n                if (map.get(sChart) != tChart) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\n```\n\nSolution 2 Array\n\n```java\nclass Solution {\n    public boolean isIsomorphic(String s, String t) {\n        char[] sChars = s.toCharArray();\n        char[] tChars = t.toCharArray();\n\n        int length = sChars.length;\n        if(length != tChars.length) return false;\n\n        char[] sm = new char[256];\n        char[] tm = new char[256];\n\n        for(int i=0; i<length; i++){\n            char sc = sChars[i];\n            char tc = tChars[i];\n            if(sm[sc] == 0 && tm[tc] == 0){\n                sm[sc] = tc;\n                tm[tc] = sc;\n            }else{\n                if(sm[sc] != tc || tm[tc] != sc){\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\n```\n\n\n\n### 242. Valid Anagram (Easy) [@](https://leetcode.com/problems/valid-anagram/)\n\n> Given two strings *s* and *t* , write a function to determine if *t* is an anagram of *s*.\n>\n> **Example 1:**\n>\n> ```\n> Input: s = \"anagram\", t = \"nagaram\"\n> Output: true\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: s = \"rat\", t = \"car\"\n> Output: false\n> ```\n>\n> **Note:**\n> You may assume the string contains only lowercase alphabets.\n>\n> **Follow up:**\n> What if the inputs contain unicode characters? How would you adapt your solution to such case?\n\nSolution 1 Sort\n\n- 排序，比较\n\n```java\nclass Solution {\n    public boolean isAnagram(String s, String t) {\n\t\tchar[] sArr = s.toCharArray();\n\t\tchar[] tArr = t.toCharArray();\n \n\t\tArrays.sort(sArr);\n\t\tArrays.sort(tArr);\n \n\t\treturn String.valueOf(sArr).equals(String.valueOf(tArr));\n    }\n}\n```\n\nSolution 2 Array\n\n```java\nclass Solution {\n    public boolean isAnagram(String s, String t) {\n        if (s.length() != t.length()) return false;\n        \n        int[] count = new int[26];\n        for (int i = 0; i < s.length(); i++) {\n            char sChar = s.charAt(i);\n            char tChar = t.charAt(i);\n            \n            count[sChar-'a'] ++;\n            count[tChar-'a'] --;\n        }\n       \t//遍历整个count数组\n        for (int i = 0; i < count.length; i++) {\n            if (count[i] != 0)\n                return false;\n        }\n        return true;\n    }\n}\n```\n\n\n\n### 290. Word Pattern (Easy) [@](https://leetcode.com/problems/word-pattern/submissions/)\n\n> Given a `pattern` and a string `str`, find if `str` follows the same pattern.\n>\n> Here **follow** means a full match, such that there is a bijection between a letter in `pattern` and a **non-empty** word in `str`.\n>\n> **Example 1:**\n>\n> ```\n> Input: pattern = \"abba\", str = \"dog cat cat dog\"\n> Output: true\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input:pattern = \"abba\", str = \"dog cat cat fish\"\n> Output: false\n> ```\n>\n> **Example 3:**\n>\n> ```\n> Input: pattern = \"aaaa\", str = \"dog cat cat dog\"\n> Output: false\n> ```\n>\n> **Example 4:**\n>\n> ```\n> Input: pattern = \"abba\", str = \"dog dog dog dog\"\n> Output: false\n> ```\n>\n> **Notes:**\n> You may assume `pattern` contains only lowercase letters, and `str` contains lowercase letters that may be separated by a single space.\n\nSolution--Improvement of P205 Solution 1\n\n- 由于字符串比较需要转换，所以用字符串做键，模式字符作为值\n\n```java\nclass Solution {\n    public boolean wordPattern(String pattern, String str) {\n        String[] Strs = str.split(\" \");\n        char[] p = pattern.toCharArray();\n        if (Strs.length != p.length) return false;\n        \n        HashMap<String, Character> map = new HashMap<>();\n        Set<Character> set = new HashSet<>();\n        for (int i = 0; i < p.length; i++) {\n            \n            if(!map.containsKey(Strs[i])) {//no mapped\n                if (set.contains(p[i])) {\n                    return false;\n                }else {\n                    map.put(Strs[i], p[i]);\n                    set.add(p[i]);\n                }\n            }else {//mapped\n                if (map.get(Strs[i]) != p[i]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\n```\n\n\n\n### 316. Remove Duplicate Letters (Hard) [@](https://leetcode.com/problems/remove-duplicate-letters/submissions/)\n\n> Given a string which contains only lowercase letters, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.\n>\n> **Example 1:**\n>\n> ```\n> Input: \"bcabc\"\n> Output: \"abc\"\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: \"cbacdcbc\"\n> Output: \"acdb\"\n> ```\n\nSolution 1 Stack\n\n思路：每个字符必须出现一次，当这个字符只有一次机会的时候必须添加到字符串结尾，反之，如果后面还有则可以把优先级高的先放进来。\n步骤：\n\n1. 统计s中字符最后位置\n\n2. 如果当前字符已经出现在stack中则跳过\n\n3. 如果当前字符不在栈里：\n\n   a. 若当前字符char小与栈顶元素，且栈顶元素有剩余 =》栈顶出栈 并 标记栈顶元素不在栈中（重复该操作直到不满足条件或栈为空）\n\n   b. 当前字符char入栈，并标记char在栈中\n\n```java\nclass Solution {\n    public String removeDuplicateLetters(String s) {\n        int len = s.length();\n        if (len < 2) return s;\n        \n        boolean[] visited = new boolean[26];\n        int[] lastPos = new int[26]; // 1\n        \n        for (int i = 0; i < len; i++) {\n            lastPos[s.charAt(i) - 'a'] = i;\n        }\n        \n        Stack<Character> stack = new Stack<>();\n        for (int i = 0; i < len; i++) {\n            char cur = s.charAt(i);\n            // 2\n            if (visited[cur - 'a']) continue;\n            // 3.a\n            while (!stack.isEmpty() && stack.peek() > cur && lastPos[stack.peek() - 'a'] > i) {\n                visited[stack.pop() - 'a'] = false;\n            }\n            // 3.b\n            stack.add(cur);\n            visited[cur - 'a'] = true;\n        }\n        \n        StringBuilder str = new StringBuilder();\n        while(!stack.isEmpty()) {\n            str.insert(0, stack.pop());\n        }\n        return str.toString();\n    }\n}\n```\n\nSolution 2 Array\n\n- 思路和stack一样但是不需要用到stack\n\n```java\nclass Solution {\n    public String removeDuplicateLetters(String s) {\n        int[] count = new int[26];\n        boolean[] visited = new boolean[26];\n        char[] charArr = s.toCharArray();\n        \n        for(char c : charArr) {\n            count[c - 'a']++;\n        }\n        \n        int i =0;\n        for(char c : charArr) {\n            count[c - 'a']--;\n            if(visited[c- 'a']) continue;\n            while(i >0 && charArr[i-1] >= c && count[charArr[i-1]-'a']>0){\n                visited[charArr[i-1]-'a'] = false;\n                i--;\n            }\n            charArr[i] = c;\n            visited[c -'a'] = true;\n            i++;\n        }\n        return new String(charArr).substring(0,i);\n    }\n}\n```\n\n\n\n### 344. Reverse String (Easy) [@](https://leetcode.com/problems/reverse-string/)\n\n> Write a function that reverses a string. The input string is given as an array of characters `char[]`.\n>\n> Do not allocate extra space for another array, you must do this by **modifying the input array [in-place](https://en.wikipedia.org/wiki/In-place_algorithm)** with O(1) extra memory.\n>\n> You may assume all the characters consist of [printable ascii characters](https://en.wikipedia.org/wiki/ASCII#Printable_characters).\n>\n> \n>\n> **Example 1:**\n>\n> ```\n> Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\n> Output: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\n> Output: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]\n> ```\n\nSolution Swap\n\n```java\nclass Solution {\n    public void reverseString(char[] s) {\n        if (s.length == 0 || s == null) return;\n        for (int i = 0; i < s.length/2; i++) {\n            swap(s, i, s.length-i-1);\n        }\n    }\n    private void swap(char[] s, int i, int j) {\n        char temp = s[i];\n        s[i] = s[j];\n        s[j] = temp;\n    }\n```\n\n\n\n### 345. Reverse Vowels of a String (Easy) [@](https://leetcode.com/problems/reverse-vowels-of-a-string/)\n\n> Write a function that takes a string as input and reverse only the vowels of a string.\n>\n> **Example 1:**\n>\n> ```\n> Input: \"hello\"\n> Output: \"holle\"\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: \"leetcode\"\n> Output: \"leotcede\"\n> ```\n>\n> **Note:**\n> The vowels does not include the letter \"y\".\n\nSolution \n\n```java\nclass Solution {\n    public String reverseVowels(String s) {\n        char[] arr = s.toCharArray();\n        int left =0;\n        int right =arr.length-1;\n         \n        while(left<right)\n        {\n            while(!isVowel(s.charAt(left))&&left<right)\n                left++;\n            while(!isVowel(s.charAt(right))&&left<right)\n                right--;\n            swap(left,right,arr);\n            left++;\n            right--;\n        }\n        return new String(arr);\n         \n    }\n     \n    public boolean isVowel(char c)\n    {\n        if(c=='a'||c=='e'||c=='i'||c=='o'||c=='u')\n            return true;\n        if(c=='A'||c=='E'||c=='I'||c=='O'||c=='U')\n            return true;\n        return false;\n    }\n     \n    public void swap(int i,int j,char[] arr)\n    {\n        char tmp = arr[i];\n        arr[i] =arr[j];\n        arr[j]=tmp;\n    }\n}\n```\n\n\n\n### 383. Ransom Note (Easy) [@](https://leetcode.com/problems/ransom-note/)\n\n> Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false.\n>\n> Each letter in the magazine string can only be used once in your ransom note.\n>\n> **Note:**\n> You may assume that both strings contain only lowercase letters.\n>\n> ```\n> canConstruct(\"a\", \"b\") -> false\n> canConstruct(\"aa\", \"ab\") -> false\n> canConstruct(\"aa\", \"aab\") -> true\n> ```\n\nSolution 1 Hash Map\n\n```java\nclass Solution {\n    public boolean canConstruct(String ransomNote, String magazine) {\n        //generate hash map of magazine\n        HashMap<Character, Integer> map = new HashMap<>();\n        for (int i = 0; i < magazine.length(); i++) {\n            char c = magazine.charAt(i);\n            map.put(c, map.getOrDefault(c, 0) + 1);\n        }\n        //update the num of characters in map\n        for (int i = 0; i < ransomNote.length(); i++) {\n            char c = ransomNote.charAt(i);\n            if (!map.containsKey(c))\n                return false;\n            map.put(c, map.get(c)-1);\n            if (map.get(c) < 0)\n                return false;\n        }\n        return true;\n    }\n}\n```\n\nSolution 2 String to Array\n\n- 字符转化为数字对应\n\n```java\nclass Solution {\n    public boolean canConstruct(String ransomNote, String magazine) {\n        int count[] = new int[26];\n        \n        for(char ch: magazine.toCharArray()) {\n            count[ch - 'a']++;\n        }\n        \n        for(char ch: ransomNote.toCharArray()) {\n            if(count[ch - 'a'] == 0) {\n                return false;\n            }\n            count[ch - 'a']--;\n        }\n        return true;\n    }\n}\n```\n\nSolution 3\n\n```java\nclass Solution {\n    public boolean canConstruct(String ransomNote, String magazine) {\n        //若magazine比ransomNote短则一定不可能\n        if (magazine.length() < ransomNote.length()) return false;\n        char[] r = ransomNote.toCharArray();\n\n        int[] list = new int[26];\n        int idx = 0;\n        for (char c : r) {\n            //判断mag中是否还有c\n            //public int indexOf(int char, int fromIndex)\n            idx = magazine.indexOf(c, list[c - 'a']);\n            if (idx < 0) {\n                return false;\n            }\n            //使用过之后向后移动idx\n            list[c - 'a'] = idx + 1;\n        }\n        return true;\n    }\n}\n```\n\n\n\n### 387. First Unique Character in a String (Easy)  [@](https://leetcode.com/problems/first-unique-character-in-a-string/)\n\n> Given a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1.\n>\n> **Examples:**\n>\n> ```\n> s = \"leetcode\"\n> return 0.\n> \n> s = \"loveleetcode\",\n> return 2.\n> ```\n>\n> \n>\n> **Note:** You may assume the string contain only lowercase letters.\n\nSolution Hash Map\n\n```java\nclass Solution {\n    public int firstUniqChar(String s) {\n        HashMap<Character, Integer> map = new HashMap<>();\n        //generate and update hashmap\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            map.put(c, map.getOrDefault(c, 0) + 1);\n        }\n        //traverse the map\n        for (int i = 0; i < s.length(); i++) {\n            if (map.get(s.charAt(i)) == 1)\n                return i;\n        }\n        return -1;\n    }\n}\n```\n\n\n\n## Array\n\n### 54. Spiral Matrix (Medium) [@](https://leetcode.com/problems/spiral-matrix/)\n\n> Given a matrix of *m* x *n* elements (*m* rows, *n* columns), return all elements of the matrix in spiral order.\n>\n> **Example 1:**\n>\n> ```\n> Input:\n> [\n> [ 1, 2, 3 ],\n> [ 4, 5, 6 ],\n> [ 7, 8, 9 ]\n> ]\n> Output: [1,2,3,6,9,8,7,4,5]\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input:\n> [\n> [1, 2, 3, 4],\n> [5, 6, 7, 8],\n> [9,10,11,12]\n> ]\n> Output: [1,2,3,4,8,12,11,10,9,5,6,7]\n> ```\n\nSolution 1 Simulation\n```java\nclass Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        List<Integer> res = new ArrayList();\n        if (matrix == null || matrix.length == 0) return res;\n        int R = matrix.length, C = matrix[0].length;\n        boolean[][] visited = new boolean[R][C];\n        int[] dr = {0, 1, 0, -1};\n        int[] dc = {1, 0, -1, 0};\n        int r = 0, c = 0, di = 0;\n        for (int i = 0; i < R*C; i++) {\n            res.add(matrix[r][c]);\n            visited[r][c] = true;\n            int cur_c = c + dc[di];\n            int cur_r = r + dr[di];\n            if (cur_c >= 0 && cur_c < C && cur_r >= 0 && cur_r < R && !visited[cur_r][cur_c]) {\n                c = cur_c;\n                r = cur_r;\n            }else {\n                di = (di + 1) % 4;\n                c += dc[di];\n                r += dr[di];\n            }\n        }\n        return res;\n    }\n}\n```\n\nSolution 2 Layer by Layer\n- For each outer layer, we want to iterate through its elements in clockwise order starting from the top left corner. Suppose the current outer layer has top-left coordinates (r1, c1) and bottom-right coordinates (r2, c2).\n- top : c from c1 ...... c2\n- right : r from r1+1 ...... r2\n- bottom : c from c2-1 ...... c1+1\n- left : r from r2 ...... r1-1\n```java\nclass Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        List<Integer> res = new ArrayList();\n        if (matrix == null || matrix.length == 0) return res;\n        int r1 = 0, r2 = matrix.length - 1;\n        int c1 = 0, c2 = matrix[0].length - 1;\n        while (r1 <= r2 && c1 <= c2) {\n            for (int c = c1; c <= c2; c++) res.add(matrix[r1][c]);\n            for (int r = r1+1; r <= r2; r++) res.add(matrix[r][c2]);\n            if (r1 < r2 && c1 < c2) {\n                for (int c = c2 - 1; c > c1; c--) res.add(matrix[r2][c]);\n                for (int r = r2; r > r1; r--) res.add(matrix[r][c1]);\n            }\n            //move top-left and bottom-right point\n            r1++;\n            c1++;\n            r2--;\n            c2--;\n        }\n        return res;\n    }\n}\n```\n\n### 56. Merge Intervals (Medium) [@](https://leetcode.com/problems/merge-intervals/)\n\n> Given a collection of intervals, merge all overlapping intervals.\n>\n> **Example 1:**\n>\n> ```\n> Input: [[1,3],[2,6],[8,10],[15,18]]\n> Output: [[1,6],[8,10],[15,18]]\n> Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: [[1,4],[4,5]]\n> Output: [[1,5]]\n> Explanation: Intervals [1,4] and [4,5] are considered overlapping.\n> ```\n>\n> **NOTE:** input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.\n\nSolution Sort + Compare\n\n- 按照start排序，然后相邻之间比较\n- [Lambda表达式](https://blog.csdn.net/wqh8522/article/details/79745350)\n```java\nclass Solution {\n    public int[][] merge(int[][] intervals) {\n        if (intervals.length <= 1) return intervals;\n        //sorted by start\n        Arrays.sort(intervals,(i1, i2) -> Integer.compare(i1[0], i2[0]));\n        \n        List<int[]> res = new ArrayList<>();\n        int[] newInterval = intervals[0];\n        res.add(newInterval);\n        for (int[] interval : intervals) {\n            //前一个右界大于等于后一个左界\n            if (newInterval[1] >= interval[0]) {\n                newInterval[1] = Math.max(newInterval[1], interval[1]);\n            }else {\n                newInterval = interval;\n                res.add(newInterval);\n            }\n        }\n        return res.toArray(new int[res.size()][]);\n    }\n}\n```\n\n### 66. Plus One (Easy) [@](https://leetcode.com/problems/plus-one/)\n\n> Given a **non-empty** array of digits representing a non-negative integer, plus one to the integer.\n>\n> The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.\n>\n> You may assume the integer does not contain any leading zero, except the number 0 itself.\n>\n> **Example 1:**\n>\n> ```\n> Input: [1,2,3]\n> Output: [1,2,4]\n> Explanation: The array represents the integer 123.\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: [4,3,2,1]\n> Output: [4,3,2,2]\n> Explanation: The array represents the integer 4321.\n> ```\n\nSolution\n\n```java\nclass Solution {\n    public int[] plusOne(int[] digits) {\n        for (int i = digits.length - 1; i >= 0; i--) {\n            digits[i]++;\n            digits[i] %= 10;\n            //若进位则继续遍历，若不进位则直接返回\n            if (digits[i] != 0) return digits;\n        }\n        //only 99,999...need one more digit\n        digits = new int[digits.length+1];\n        digits[0] = 1;\n        return digits;\n    }\n}\n```\n\n### 73. Set Matrix Zeros (Medium) [@](https://leetcode.com/problems/set-matrix-zeroes/)\n\n> Given a *m* x *n* matrix, if an element is 0, set its entire row and column to 0. Do it [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm).\n>\n> **Example 1:**\n>\n> ```\n> Input: \n> [\n> [1,1,1],\n> [1,0,1],\n> [1,1,1]\n> ]\n> Output: \n> [\n> [1,0,1],\n> [0,0,0],\n> [1,0,1]\n> ]\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: \n> [\n> [0,1,2,0],\n> [3,4,5,2],\n> [1,3,1,5]\n> ]\n> Output: \n> [\n> [0,0,0,0],\n> [0,4,5,0],\n> [0,3,1,0]\n> ]\n> ```\n>\n> **Follow up:**\n>\n> - A straight forward solution using O(*m**n*) space is probably a bad idea.\n> - A simple improvement uses O(*m* + *n*) space, but still not the best solution.\n> - Could you devise a constant space solution?\n\nSolution \n- Use first row and first column to mark if the row/col needs to be set to 0. (Postpone the change)\n```java\nclass Solution {\n  public void setZeroes(int[][] matrix) {\n    Boolean isCol = false;\n    int R = matrix.length;\n    int C = matrix[0].length;\n\n    for (int i = 0; i < R; i++) {\n\n      // Since first cell for both first row and first column is the same i.e. matrix[0][0]\n      // We can use an additional variable for either the first row/column.\n      // For this solution we are using an additional variable for the first column\n      // and using matrix[0][0] for the first row.\n      if (matrix[i][0] == 0) {\n        isCol = true;\n      }\n\n      for (int j = 1; j < C; j++) {\n        // If an element is zero, we set the first element of the corresponding row and column to 0\n        if (matrix[i][j] == 0) {\n          matrix[0][j] = 0;\n          matrix[i][0] = 0;\n        }\n      }\n    }\n\n    // Iterate over the array once again and using the first row and first column, update the elements.\n    for (int i = 1; i < R; i++) {\n      for (int j = 1; j < C; j++) {\n        if (matrix[i][0] == 0 || matrix[0][j] == 0) {\n          matrix[i][j] = 0;\n        }\n      }\n    }\n\n    // See if the first row needs to be set to zero as well\n    if (matrix[0][0] == 0) {\n      for (int j = 0; j < C; j++) {\n        matrix[0][j] = 0;\n      }\n    }\n\n    // See if the first column needs to be set to zero as well\n    if (isCol) {\n      for (int i = 0; i < R; i++) {\n        matrix[i][0] = 0;\n      }\n    }\n  }\n}\n```\n### 75. Sort Colors (Medium) [@](https://leetcode.com/problems/sort-colors/)\n\n> Given an array with *n* objects colored red, white or blue, sort them **[in-place](https://en.wikipedia.org/wiki/In-place_algorithm)** so that objects of the same color are adjacent, with the colors in the order red, white and blue.\n>\n> Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.\n>\n> **Note:** You are not suppose to use the library's sort function for this problem.\n>\n> **Example:**\n>\n> ```\n> Input: [2,0,2,1,1,0]\n> Output: [0,0,1,1,2,2]\n> ```\n>\n> **Follow up:**\n>\n> - A rather straight forward solution is a two-pass algorithm using counting sort.\n>   First, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's.\n> - Could you come up with a one-pass algorithm using only constant space?\n\nSolution\n\n- red replace forward, blue replace backward \n```java\nclass Solution {\n    public void sortColors(int[] nums) {\n        int red = 0, blue = nums.length - 1;\n        int i = 0;\n        while (red <= blue && i <= blue) {\n            if (nums[i] == 0) {\n                swap(nums, red, i);\n                red++;\n            }else if (nums[i] == 2) {\n                swap(nums, i, blue);\n                blue--;\n                i--; //re-evaluate current element\n            }\n            i++;\n        }\n        return;\n    }\n    private void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}\n```\n\n### 88. Merge Sorted Array (Easy) [@](https://leetcode.com/problems/merge-sorted-array/)\n> Given two sorted integer arrays *nums1* and *nums2*, merge *nums2* into *nums1* as one sorted array.\n>\n> **Note:**\n>\n> - The number of elements initialized in *nums1* and *nums2* are *m* and *n* respectively.\n> - You may assume that *nums1* has enough space (size that is greater or equal to *m* + *n*) to hold additional elements from *nums2*.\n>\n> **Example:**\n>\n> ```\n> Input:\n> nums1 = [1,2,3,0,0,0], m = 3\n> nums2 = [2,5,6],       n = 3\n> \n> Output: [1,2,2,3,5,6]\n> ```\n\nSolution\n\n- 从后向前扫描，添加大的元素\n```java\nclass Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        //two pointer for nums1 and nums2\n        int ptr1 = m - 1;\n        int ptr2 = n - 1;\n        //pointer for insert position\n        int p = m + n - 1;\n        //compare back forward\n        while (ptr1 >= 0 && ptr2 >= 0) {\n            if (nums1[ptr1] > nums2[ptr2]) {\n                nums1[p--] = nums1[ptr1--];\n            }else {\n                nums1[p--] = nums2[ptr2--];\n            }\n        }\n        //add remaining nums in nums2\n        //public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)\n        System.arraycopy(nums2, 0, nums1, 0, ptr2 + 1);\n    }\n}\n```\n\n### 118. Pascal‘s Triangle (Easy) [@](https://leetcode.com/problems/pascals-triangle/)\n\n> Given a non-negative integer *numRows*, generate the first *numRows* of Pascal's triangle.\n>\n> In Pascal's triangle, each number is the sum of the two numbers directly above it.\n>\n> **Example:**\n>\n> ```\n> Input: 5\n> Output:\n> [\n>   [1],\n>  [1,1],\n> [1,2,1],\n> [1,3,3,1],\n> [1,4,6,4,1]\n> ]\n> ```\n\nSolution DP\n\n```java\nclass Solution {\n    public List<List<Integer>> generate(int numRows) {\n        List<List<Integer>> triangle = new ArrayList<List<Integer>>();\n\n        // First base case; if user requests zero rows, they get zero rows.\n        if (numRows == 0) {\n            return triangle;\n        }\n\n        // Second base case; first row is always [1].\n        triangle.add(new ArrayList<>());\n        triangle.get(0).add(1);\n\n        for (int rowNum = 1; rowNum < numRows; rowNum++) {\n            List<Integer> row = new ArrayList<>(Integer);\n            List<Integer> prevRow = triangle.get(rowNum-1);\n\n            // The first row element is always 1.\n            row.add(1);\n\n            // Each triangle element (other than the first and last of each row)\n            // is equal to the sum of the elements above-and-to-the-left and\n            // above-and-to-the-right.\n            for (int j = 1; j < rowNum; j++) {\n                row.add(prevRow.get(j-1) + prevRow.get(j));\n            }\n\n            // The last row element is always 1.\n            row.add(1);\n\n            triangle.add(row);\n        }\n\n        return triangle;\n    }\n}\n```\n\n### 136. Single Number (Easy) [@](https://leetcode.com/problems/single-number/)\n\n> Given a **non-empty** array of integers, every element appears *twice* except for one. Find that single one.\n>\n> **Note:**\n>\n> Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\n>\n> **Example 1:**\n>\n> ```\n> Input: [2,2,1]\n> Output: 1\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: [4,1,2,1,2]\n> Output: 4\n> ```\n\nSolution 1 Hash Map\n\n```java\nclass Solution {\n    public int singleNumber(int[] nums) {\n        HashMap<Integer, Integer> map = new HashMap<>();\n        for (int num : nums) {\n            if (map.containsKey(num)) {\n                map.remove(num);\n            }else {\n                map.put(num, 1);\n            }\n        }\n        return map.entrySet().iterator().next().getKey();\n    }\n}\n```\n\nSolution 2 Math\n- 所有不重复数字的两倍乘总和 - 原数组总和 = 出现一次的数字\n```java\nclass Solution {\n    public int singleNumber(int[] nums) {\n        Set<Integer> set = new HashSet<>();\n        \n        int arrSum = 0;\n        for (int num : nums) {\n            set.add(num);\n            arrSum += num;\n        }\n        \n        int doubleSum = 0;\n        for (int num : set) {\n            doubleSum += 2*num;\n        }\n        return doubleSum - arrSum;\n    }\n}\n```\n\nSolution 3 Bit Manipulation\n- 异或XOR\n- 对所有数字进行异或，最后得出单个的数\n- 异或性质\n\t- 交换律: A XOR B = B XOR A\n\t- 结合律: A XOR B XOR C = A XOR (B XOR C) = (A XOR B) XOR C\n\t- 自反性: A XOR B XOR B = A XOR 0 = A\n```java\nclass Solution {\n    public int singleNumber(int[] nums) {\n        int res = 0;\n        for (int num : nums) {\n            res ^= num;\n        }\n        return res;\n    }\n}\n```\n\n### 169. Majority Element (Easy) [@](https://leetcode.com/problems/majority-element/)\n\n> Given an array of size *n*, find the majority element. The majority element is the element that appears **more than** `⌊ n/2 ⌋` times.\n>\n> You may assume that the array is non-empty and the majority element always exist in the array.\n>\n> **Example 1:**\n>\n> ```\n> Input: [3,2,3]\n> Output: 3\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: [2,2,1,1,1,2,2]\n> Output: 2\n> ```\n\nSolution 1 HashMap\n\n```java\nclass Solution {\n    public int majorityElement(int[] nums) {\n        HashMap<Integer, Integer> map = new HashMap<>();\n        int N = nums.length;\n        for (int i = 0; i < N; i++) {\n            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\n        }\n        int res = 0;\n        for (Map.Entry<Integer,Integer> s : map.entrySet()) {\n            if (s.getValue() > N/2) {\n                res = s.getKey();\n                break;\n            }\n        }\n        return res;\n    }\n}\n```\n\nSolution 2 Sort\n\n```java\nclass Solution {\n    public int majorityElement(int[] nums) {\n        Arrays.sort(nums);\n        return nums[nums.length/2];\n    }\n}\n```\nSolution 3 摩尔投票法\n\n- 首先假定数组头元素即为众数，设定计数器为1，从第二个数开始遍历，如果和头元素相同则计数器加1，如果不相同则减1，之后判断计数器是否为0，如果不为0则继续下一步循环，如果为0则将众数指针指向当前元素，以此类推，最后众数指针指向的元素即为众数，时间复杂度～O(n)，空间复杂度～O(1)\n\n```java\nclass Solution {\n    public int majorityElement(int[] nums) {\n        int res = nums[0];\n        int count = 1;\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i] == res) count++;\n            else {\n                count--;\n                if (count == 0) {\n                    res = nums[i];\n                    count = 1;\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n### 189. Rotate Array (Easy) [@](https://leetcode.com/problems/rotate-array/)\n\n> Given an array, rotate the array to the right by *k* steps, where *k* is non-negative.\n>\n> **Example 1:**\n>\n> ```\n> Input: [1,2,3,4,5,6,7] and k = 3\n> Output: [5,6,7,1,2,3,4]\n> Explanation:\n> rotate 1 steps to the right: [7,1,2,3,4,5,6]\n> rotate 2 steps to the right: [6,7,1,2,3,4,5]\n> rotate 3 steps to the right: [5,6,7,1,2,3,4]\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: [-1,-100,3,99] and k = 2\n> Output: [3,99,-1,-100]\n> Explanation: \n> rotate 1 steps to the right: [99,-1,-100,3]\n> rotate 2 steps to the right: [3,99,-1,-100]\n> ```\n>\n> **Note:**\n>\n> - Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.\n> - Could you do it in-place with O(1) extra space?\n\nSolution 1 Extra Array\n\n```java\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        int N = nums.length;\n        int[] temp = new int[N];\n        for (int i = 0; i < N; i++) {\n            temp[(i+k) % N] = nums[i];\n        }\n        for (int i = 0; i < N; i++) {\n            nums[i] = temp[i];\n        }\n    }\n}\n```\n\nSolution 2 Cyclic Replacements\n\n- [Leetcode CN](https://leetcode-cn.com/problems/rotate-array/solution/xuan-zhuan-shu-zu-by-leetcode/)\n\n```java\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        int count = 0;\n        for (int start = 0; count < nums.length; start++) {\n            int cur = start;\n            int prev = nums[cur];\n            do {\n                int next = (cur + k) % nums.length;\n                int temp = nums[next];\n                nums[next] = prev;\n                prev = temp;\n                cur = next;\n                count++;\n            }while (start != cur);\n        }\n    }\n}\n```\nSolution 3 Reverse\n- 先反转所有，再分别反转前k个位置和后面所有\n```java\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        k %= nums.length;\n        reverse(nums, 0, nums.length - 1);\n        reverse(nums, 0, k - 1);\n        reverse(nums, k, nums.length - 1);\n    }\n    private void reverse(int[] nums, int start, int end) {\n        while (start < end) {\n            int temp = nums[start];\n            nums[start] = nums[end];\n            nums[end] = temp;\n            start++;\n            end--;\n        }\n    }\n}\n```\n\n\n## Linked List\n\n### 138. Copy List with Random Pointer (Medium) [@](https://leetcode.com/problems/copy-list-with-random-pointer/)\n\n> A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.\n>\n> Return a [**deep copy**](https://en.wikipedia.org/wiki/Object_copying#Deep_copy) of the list.\n>\n> The Linked List is represented in the input/output as a list of `n` nodes. Each node is represented as a pair of `[val, random_index]` where:\n>\n> - `val`: an integer representing `Node.val`\n> - `random_index`: the index of the node (range from `0` to `n-1`) where random pointer points to, or `null` if it does not point to any node.\n>\n> **Example 1:**\n>\n> ![img](https://assets.leetcode.com/uploads/2019/12/18/e1.png)\n>\n> ```\n> Input: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\n> Output: [[7,null],[13,0],[11,4],[10,2],[1,0]]\n> ```\n>\n> **Example 2:**\n>\n> ![img](https://assets.leetcode.com/uploads/2019/12/18/e2.png)\n>\n> ```\n> Input: head = [[1,1],[2,1]]\n> Output: [[1,1],[2,1]]\n> ```\n>\n> **Example 3:**\n>\n> **![img](https://assets.leetcode.com/uploads/2019/12/18/e3.png)**\n>\n> ```\n> Input: head = [[3,null],[3,0],[3,null]]\n> Output: [[3,null],[3,0],[3,null]]\n> ```\n>\n> **Example 4:**\n>\n> ```\n> Input: head = []\n> Output: []\n> Explanation: Given linked list is empty (null pointer), so return null.\n> ```\n\nSolution 1 HashMap + 2 iterations \n\n第一种方法，就是使用HashMap来坐，HashMap的key存原始pointer，value存新的pointer。\n\n- 第一遍，先不copy random的值，只copy数值建立好新的链表。并把新旧pointer存在HashMap中。\n- 第二遍，遍历旧表，复制random的值，因为第一遍已经把链表复制好了并且也存在HashMap里了，所以只需从HashMap中，把当前旧的node.random作为key值，得到新的value的值，并把其赋给新node.random就好。\n\n```java\n/*\n// Definition for a Node.\nclass Node {\n    int val;\n    Node next;\n    Node random;\n\n    public Node(int val) {\n        this.val = val;\n        this.next = null;\n        this.random = null;\n    }\n}\n*/\nclass Solution {\n    public Node copyRandomList(Node head) {\n        if (head == null) return null;\n        HashMap<Node, Node> map = new HashMap<>();\n        Node newHead = new Node(head.val);\n        map.put(head, newHead);\n        Node oldPtr = head.next;\n        Node newPtr = newHead;\n        //first iterate the linked list\n        while (oldPtr != null) {\n            //link next node\n            Node newNode = new Node(oldPtr.val);\n            newPtr.next = newNode;\n            //update hashmap\n            map.put(oldPtr, newNode);\n            \n            oldPtr = oldPtr.next;\n            newPtr = newPtr.next;\n        }\n        \n        oldPtr = head;\n        newPtr = newHead;\n        //second iterate the linked list -> update random ptr\n        while(oldPtr != null) {\n            //update random ptr of new list\n            newPtr.random = map.get(oldPtr.random);\n            \n            oldPtr = oldPtr.next;\n            newPtr = newPtr.next;\n        }\n        \n        return newHead;\n    }\n}\n```\nSolution 2 3-iteration\n\n第二种方法不使用HashMap来做，使空间复杂度降为O(1)，不过需要3次遍历list，时间复杂度为O(3n)=O(n)。\n\n- 第一遍，对每个node进行复制，并插入其原始node的后面，新旧交替，变成重复链表。如：原始：1->2->3->null，复制后：1->1->2->2->3->3->null\n- 第二遍，遍历每个旧node，把旧node的random的复制给新node的random，因为链表已经是新旧交替的。所以复制方法为：**node.next.random = node.random.next** 前面是说旧node的next的random，就是新node的random，后面是旧node的random的next，正好是新node，是从旧random复制来的。\n- 第三遍，则是把新旧两个表拆开，返回新的表即可。\n\n```java\n/*\n// Definition for a Node.\nclass Node {\n    int val;\n    Node next;\n    Node random;\n\n    public Node(int val) {\n        this.val = val;\n        this.next = null;\n        this.random = null;\n    }\n}\n*/\nclass Solution {\n    public Node copyRandomList(Node head) {\n        if (head == null) return null;\n        Node cur = head;\n        //1st iteration: copy current node and link it to next\n        while (cur != null) {\n            Node newNode = new Node(cur.val);\n            newNode.next = cur.next;\n            cur.next = newNode;\n            \n            cur = newNode.next;\n        }\n        //2ed iteration: update random node\n        cur = head;\n        while (cur != null) {\n            if (cur.random != null) {\n                cur.next.random = cur.random.next;\n            }\n            cur = cur.next.next;\n        }\n        //3rd iteration: \n        cur = head; //point to old node\n        Node newHead = head.next;//initialize new head\n        Node copy = newHead;//point to new node\n        \n        // method 1\n//         while (copy.next != null) {\n//             //old\n//             cur.next = cur.next.next;\n//             cur = cur.next;\n            \n//             //new\n//             copy.next = copy.next.next;\n//             copy = copy.next;\n//         }\n//         cur.next = cur.next.next;\n        \n        //method 2\n        while (cur != null) {\n            copy = cur.next;\n            cur.next = copy.next;\n            if (copy.next != null) {\n                copy.next = copy.next.next;\n            }\n            cur = cur.next;\n        }\n        return newHead;\n    }\n}\n```\n\n### 141. Linked List Cycle (Easy) [@](https://leetcode.com/problems/linked-list-cycle/)\n\n> Given a linked list, determine if it has a cycle in it.\n>\n> To represent a cycle in the given linked list, we use an integer `pos` which represents the position (0-indexed) in the linked list where tail connects to. If `pos` is `-1`, then there is no cycle in the linked list.\n>\n> \n>\n> **Example 1:**\n>\n> ```\n> Input: head = [3,2,0,-4], pos = 1\n> Output: true\n> Explanation: There is a cycle in the linked list, where tail connects to the second node.\n> ```\n>\n> ![img](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png)\n>\n> **Example 2:**\n>\n> ```\n> Input: head = [1,2], pos = 0\n> Output: true\n> Explanation: There is a cycle in the linked list, where tail connects to the first node.\n> ```\n>\n> ![img](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png)\n>\n> **Example 3:**\n>\n> ```\n> Input: head = [1], pos = -1\n> Output: false\n> Explanation: There is no cycle in the linked list.\n> ```\n>\n> ![img](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png)\n>\n> \n>\n> **Follow up:**\n>\n> Can you solve it using *O(1)* (i.e. constant) memory?\n\nSolution 1 HashSet\n\n```java\npublic boolean hasCycle(ListNode head) {\n    Set<ListNode> nodesSeen = new HashSet<>();\n    while (head != null) {\n        if (nodesSeen.contains(head)) {\n            return true;\n        } else {\n            nodesSeen.add(head);\n        }\n        head = head.next;\n    }\n    return false;\n}\n```\n\nSolution 2 Two ptrs\n- if slow and fast ptr meet then it much contains a cycle.\n```java\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n        if (head == null || head.next == null) return false;\n        \n        ListNode slow = head;\n        ListNode fast = head.next;\n        while (slow != fast) {\n            if (fast == null || fast.next == null)\n                return false;\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        return true;\n    }\n}\n```\n### 146. LRU Cache (Medium) [@](https://leetcode.com/problems/lru-cache/)\n\n> Design and implement a data structure for [Least Recently Used (LRU) cache](https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU). It should support the following operations: `get` and `put`.\n>\n> `get(key)` - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.\n> `put(key, value)` - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.\n>\n> The cache is initialized with a **positive** capacity.\n>\n> **Follow up:**\n> Could you do both operations in **O(1)** time complexity?\n>\n> **Example:**\n>\n> ```\n> LRUCache cache = new LRUCache( 2 /* capacity */ );\n> \n> cache.put(1, 1);\n> cache.put(2, 2);\n> cache.get(1);       // returns 1\n> cache.put(3, 3);    // evicts key 2\n> cache.get(2);       // returns -1 (not found)\n> cache.put(4, 4);    // evicts key 1\n> cache.get(1);       // returns -1 (not found)\n> cache.get(3);       // returns 3\n> cache.get(4);       // returns 4\n> ```\n\nSolution 1 LinkedHashMap\n\n- [LinkedHashMap](https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html)\n- LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder)\n- 作为一般规则，默认负载因子（0.75）在时间和空间成本上提供了很好的折衷。较高的值会降低空间开销，但提高查找成本（体现在大多数的HashMap类的操作，包括get和put）。设置初始大小时，应该考虑预计的entry数在map及其负载系数，并且尽量减少rehash操作的次数。如果初始容量大于最大条目数除以负载因子，rehash操作将不会发生。\n\n\n```java\nclass LRUCache extends LinkedHashMap<Integer, Integer>{\n    private int capacity;\n    \n    public LRUCache(int capacity) {\n        super(capacity, 0.75F, true);\n        this.capacity = capacity;\n    }\n    \n    public int get(int key) {\n        return super.getOrDefault(key, -1);\n    }\n    \n    public void put(int key, int value) {\n        super.put(key, value);\n    }\n    \n    @Override\n    protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {\n        return size() > capacity;\n    }\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n```\nSolution 2 Linked List + HashMap (implementation of sol 1)\n\n```java\n\nclass LRUCache {\n    \n    class DLinkedNode {\n        int key;\n        int val;\n        DLinkedNode prev;\n        DLinkedNode next;\n    }\n    \n    private void addNode(DLinkedNode node) {\n        //always add node right after head\n        node.next = head.next;\n        node.prev = head;\n        \n        head.next.prev = node;\n        head.next = node;\n    }\n    \n    private void removeNode(DLinkedNode node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n    \n    private void moveToHead(DLinkedNode node) {\n        removeNode(node);\n        addNode(node);\n    }\n    \n    private DLinkedNode popTail() {\n        DLinkedNode res = tail.prev;\n        removeNode(res);\n        return res;\n    }\n    \n    private HashMap<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();\n    private int size;\n    private int capacity;\n    private DLinkedNode head, tail;\n    \n    public LRUCache(int capacity) {\n        this.size = 0;\n        this.capacity = capacity;\n        \n        head = new DLinkedNode();\n        tail = new DLinkedNode();\n        \n        head.next = tail;\n        tail.prev = head;\n    }\n    \n    public int get(int key) {\n        DLinkedNode node = cache.get(key);\n        \n        if (node == null) \n            return -1;\n        else {\n            //used => move to head\n            moveToHead(node);\n            return node.val;\n        }\n    }\n    \n    public void put(int key, int value) {\n        DLinkedNode node = cache.get(key);\n        \n        if (node == null) {\n            DLinkedNode newNode = new DLinkedNode();\n            newNode.key = key;\n            newNode.val = value;\n            \n            cache.put(key, newNode);//update cache(HashMap)\n            addNode(newNode); //update Linked List\n            \n            size++;\n            \n            if (size > capacity) {\n                //pop tail\n                DLinkedNode tail = popTail();\n                cache.remove(tail.key);\n                size--;\n            }\n        }else {\n            //update val\n            node.val = value;\n            moveToHead(node);\n        }\n    }\n    \n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n```\n\n### 148. Sort List (Medium) [@](https://leetcode.com/problems/sort-list/)\n\n> Sort a linked list in *O*(*n* log *n*) time using constant space complexity.\n>\n> **Example 1:**\n>\n> ```\n> Input: 4->2->1->3\n> Output: 1->2->3->4\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: -1->5->3->4->0\n> Output: -1->0->3->4->5\n> ```\n\nSolution 1 Merge sort\n- 空间复杂度O(logn)， 不符合要求\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode sortList(ListNode head) {\n        if (head == null || head.next == null) return head;\n        \n        //find the mid point\n        ListNode slow = head, fast = head.next;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        //mid = slow\n        ListNode tmp = slow.next;\n        slow.next = null; //cut\n        //divide\n        ListNode left = sortList(head);\n        ListNode right = sortList(tmp);\n        //merge\n        ListNode cur = new ListNode(0);\n        ListNode res = cur;\n        while (left != null && right != null) {\n            if (left.val < right.val) {\n                cur.next = left;\n                left = left.next;\n            }else {\n                cur.next = right;\n                right = right.next;\n            }\n            cur = cur.next;\n        }\n        //add the rest of left or right part\n        cur.next = left != null ? left : right;\n        return res.next;\n    }\n}\n```\nSolution 2 Iteration\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode sortList(ListNode head) {\n        if (head == null || head.next == null) return head;\n        \n        ListNode dummy = new ListNode(-1);\n        dummy.next = head;\n        //len of list\n        int length = 0;\n        while (head != null) {\n            length++;\n            head = head.next;\n        }\n        head = dummy.next;\n        \n        //loop logn times\n        for (int i = 1; i < length; i+= i) {\n            //list was divided into 4 parts:\n            //1. already sorted; 2. left part of list to be sorted;\n            //3. right part of list to be sorted; 4. unsorted part of list\n            ListNode success = dummy;\n            ListNode left = null;\n            ListNode right = null;\n            while (head != null) {\n                left = head;\n                head = cutFromHead(head, i);\n                right = head;\n                head = cutFromHead(head, i);\n                //merge sort left and right, put them after success, and update success\n                success.next = mergeLists(left, right);\n                while (success.next != null) success = success.next;\n            }\n            head = dummy.next;\n        }\n        return dummy.next;\n    }\n    //cut the list from head with n-len and return (n+1)th node\n    private ListNode cutFromHead(ListNode head, int n) {\n        while (head != null && --n > 0) {\n            head = head.next;\n        }\n        \n        if (head == null) return null;\n        \n        ListNode next = head.next;\n        head.next = null; //cut\n        return next;\n    }\n    //merge sort 2 lists\n    private ListNode mergeLists(ListNode left, ListNode right) {\n        if (left == null) return right;\n        if (right == null) return left;\n        \n        ListNode dummy = new ListNode(-1);\n        ListNode cur = dummy;\n        \n        while (left != null && right != null) {\n            if (left.val < right.val) {\n                cur.next = left;\n                left = left.next;\n            }else {\n                cur.next = right;\n                right = right.next;\n            }\n            cur = cur.next;\n        }\n        cur.next = left != null ? left : right;\n        return dummy.next;\n    }\n}\n```\n### 160. Intersection of Two Linked Lists (Easy) [@](https://leetcode.com/problems/intersection-of-two-linked-lists/)\n\n> Write a program to find the node at which the intersection of two singly linked lists begins.\n>\n> For example, the following two linked lists:\n>\n> [![img](https://assets.leetcode.com/uploads/2018/12/13/160_statement.png)](https://assets.leetcode.com/uploads/2018/12/13/160_statement.png)\n>\n> begin to intersect at node c1.\n>\n> \n>\n> **Example 1:**\n>\n> [![img](https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png)\n>\n> ```\n> Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\n> Output: Reference of the node with value = 8\n> Input Explanation: The intersected node's value is 8 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,0,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.\n> ```\n>\n> \n>\n> **Example 2:**\n>\n> [![img](https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png)\n>\n> ```\n> Input: intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n> Output: Reference of the node with value = 2\n> Input Explanation: The intersected node's value is 2 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [0,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.\n> ```\n>\n> \n>\n> **Example 3:**\n>\n> [![img](https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png)\n>\n> ```\n> Input: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n> Output: null\n> Input Explanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.\n> Explanation: The two lists do not intersect, so return null.\n> ```\n>\n> \n>\n> **Notes:**\n>\n> - If the two linked lists have no intersection at all, return `null`.\n> - The linked lists must retain their original structure after the function returns.\n> - You may assume there are no cycles anywhere in the entire linked structure.\n> - Your code should preferably run in O(n) time and use only O(1) memory.\n\nSolution 1 Two round iteration\n- 尾部对齐，找出长度差，长的先走\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        int lenA=0, lenB=0;\n        ListNode A=headA, B=headB;\n        while(A != null){\n            lenA ++;\n            A = A.next;\n        }\n\n        while(B != null) {\n            lenB++;\n            B = B.next;\n        }\n        A = headA;\n        B = headB;\n\n        while(lenA > lenB){\n            A = A.next;\n            lenA --;\n        }\n        while(lenA < lenB){\n            B = B.next;\n            lenB --;\n        }\n\n        while(A != B){\n            A = A.next;\n            B = B.next;\n        }\n\n        return A;\n    }\n}\n```\n\nSolution 2 Two pointer + 环\n- 转化成判断环的问题\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null) return null;\n        \n        ListNode curA = headA;\n        ListNode curB = headB;\n        //将自身最后连接到另一个链表头，若存在intersection则形成环\n        //如果形成环，则curA和curB一定在环的入口相交\n        //若没有形成环，则都到达null\n        while (curA != curB) {\n            curA = curA == null ? headB : curA.next;\n            curB = curB == null ? headA : curB.next;\n        }\n        return curA;\n    }\n}\n```\n\n## Stack\n\n### 150. Evaluate Reverse Polish Notation (Medium) [@](https://leetcode.com/problems/evaluate-reverse-polish-notation/)\n\n> Evaluate the value of an arithmetic expression in [Reverse Polish Notation](http://en.wikipedia.org/wiki/Reverse_Polish_notation).\n>\n> Valid operators are `+`, `-`, `*`, `/`. Each operand may be an integer or another expression.\n>\n> **Note:**\n>\n> - Division between two integers should truncate toward zero.\n> - The given RPN expression is always valid. That means the expression would always evaluate to a result and there won't be any divide by zero operation.\n>\n> **Example 1:**\n>\n> ```\n> Input: [\"2\", \"1\", \"+\", \"3\", \"*\"]\n> Output: 9\n> Explanation: ((2 + 1) * 3) = 9\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: [\"4\", \"13\", \"5\", \"/\", \"+\"]\n> Output: 6\n> Explanation: (4 + (13 / 5)) = 6\n> ```\n>\n> **Example 3:**\n>\n> ```\n> Input: [\"10\", \"6\", \"9\", \"3\", \"+\", \"-11\", \"*\", \"/\", \"*\", \"17\", \"+\", \"5\", \"+\"]\n> Output: 22\n> Explanation: \n>   ((10 * (6 / ((9 + 3) * -11))) + 17) + 5\n> = ((10 * (6 / (12 * -11))) + 17) + 5\n> = ((10 * (6 / -132)) + 17) + 5\n> = ((10 * 0) + 17) + 5\n> = (0 + 17) + 5\n> = 17 + 5\n> = 22\n> ```\n\nSolution 1 Stack\n```java\nclass Solution {\n    public int evalRPN(String[] tokens) {\n        Stack<Integer> stack = new Stack<>();\n        for (String s : tokens) {\n            if (s.equals(\"+\")) {\n                stack.push(stack.pop() + stack.pop());\n            } else if (s.equals(\"-\")) {\n                stack.push(- stack.pop() + stack.pop());\n            } else if (s.equals(\"*\")) {\n                stack.push(stack.pop() * stack.pop());\n            } else if (s.equals(\"/\")) {\n                int dividend = stack.pop();\n                stack.push(stack.pop() / dividend);\n            } else { //normal numbers\n                stack.push(Integer.parseInt(s));\n            }\n        }\n        return stack.pop();\n    }\n}\n```\n\n### 155. Min Stack (Medium) [@](https://leetcode.com/problems/min-stack/submissions/)\n\n> Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n>\n> - push(x) -- Push element x onto stack.\n> - pop() -- Removes the element on top of the stack.\n> - top() -- Get the top element.\n> - getMin() -- Retrieve the minimum element in the stack.\n>\n>  \n>\n> **Example:**\n>\n> ```\n> MinStack minStack = new MinStack();\n> minStack.push(-2);\n> minStack.push(0);\n> minStack.push(-3);\n> minStack.getMin();   --> Returns -3.\n> minStack.pop();\n> minStack.top();      --> Returns 0.\n> minStack.getMin();   --> Returns -2.\n> ```\n\nSolution 1 synchronous data stack and helper stack\n```java\nclass MinStack {\n    \n    private Stack<Integer> data;\n    private Stack<Integer> minElement;\n\n    /** initialize your data structure here. */\n    public MinStack() {\n        data = new Stack<>();\n        minElement = new Stack<>();\n    }\n    \n    public void push(int x) {\n        data.add(x);\n        if (minElement.isEmpty() || minElement.peek() >= x) {\n            minElement.add(x);\n        } else {\n            minElement.add(minElement.peek());\n        }\n    }\n    \n    public void pop() {\n        if (!data.isEmpty()) {\n            data.pop();\n            minElement.pop();\n        }\n    }\n    \n    public int top() {\n        if (!data.isEmpty()) {\n            return data.peek();\n        }\n        throw new RuntimeException(\"stack is empty\");\n    }\n    \n    public int getMin() {\n        if (!minElement.isEmpty()) {\n            return minElement.peek();\n        }\n        throw new RuntimeException(\"stack is empty\");\n    }\n}\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack obj = new MinStack();\n * obj.push(x);\n * obj.pop();\n * int param_3 = obj.top();\n * int param_4 = obj.getMin();\n */\n```\n\nSolution 2 asynchronous \n\n```java\nclass MinStack {\n    \n    private Stack<Integer> data;\n    private Stack<Integer> minElement;\n\n    /** initialize your data structure here. */\n    public MinStack() {\n        data = new Stack<>();\n        minElement = new Stack<>();\n    }\n    \n    // 思路 2：辅助栈和数据栈不同步\n    // 关键 1：辅助栈的元素空的时候，必须放入新进来的数\n    // 关键 2：新来的数小于或者等于辅助栈栈顶元素的时候，才放入（特别注意这里等于要考虑进去）\n    // 关键 3：出栈的时候，辅助栈的栈顶元素等于数据栈的栈顶元素，才出栈，即\"出栈保持同步\"就可以了\n    \n    public void push(int x) {\n        data.add(x);\n        // 辅助栈在必要的时候才增加\n        if (minElement.isEmpty() || minElement.peek() >= x) {\n            minElement.add(x);\n        }\n    }\n    \n    public void pop() {\n        //关键3: 数据栈一定pop\n        if (!data.isEmpty()) {\n            // 注意：声明成 int 类型，这里完成了自动拆箱，从 Integer 转成了 int，因此下面的比较可以使用 \"==\" 运算符\n            // 参考资料：https://www.cnblogs.com/GuoYaxiang/p/6931264.html\n            // 如果把 top 变量声明成 Integer 类型，下面的比较就得使用 equals 方法\n            int top = data.pop();\n            if (top == minElement.peek()) {\n                minElement.pop();\n            }\n        }\n    }\n    \n    public int top() {\n        if (!data.isEmpty()) {\n            return data.peek();\n        }\n        throw new RuntimeException(\"stack is empty\");\n    }\n    \n    public int getMin() {\n        if (!minElement.isEmpty()) {\n            return minElement.peek();\n        }\n        throw new RuntimeException(\"stack is empty\");\n    }\n}\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack obj = new MinStack();\n * obj.push(x);\n * obj.pop();\n * int param_3 = obj.top();\n * int param_4 = obj.getMin();\n */\n```\nSolution 3 Linked List\n\n```java\nclass MinStack {\n    \n    private Node head;\n    \n    private class Node {\n        int val;\n        int min;\n        Node next;\n        \n        Node(int val, int min, Node next) {\n            this.val = val;\n            this.min = min;\n            this.next = next;\n        }\n    }\n    \n    public void push(int x) {\n        if (head == null) {\n            head = new Node(x, x, null);\n        } else {\n            head = new Node(x, Math.min(head.min, x), head);\n        }\n    }\n    \n    public void pop() {\n        head = head.next;\n    }\n    \n    public int top() {\n        return head.val;\n    }\n    \n    public int getMin() {\n        return head.min;\n    }\n}\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack obj = new MinStack();\n * obj.push(x);\n * obj.pop();\n * int param_3 = obj.top();\n * int param_4 = obj.getMin();\n */\n```\n\n## Math\n\n### 172. Factorial Trailing Zeroes (Easy) [@](https://leetcode.com/problems/factorial-trailing-zeroes/)\n\n> Given an integer *n*, return the number of trailing zeroes in *n*!.\n>\n> **Example 1:**\n>\n> ```\n> Input: 3\n> Output: 0\n> Explanation: 3! = 6, no trailing zero.\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: 5\n> Output: 1\n> Explanation: 5! = 120, one trailing zero.\n> ```\n>\n> **Note:** Your solution should be in logarithmic time complexity.\n\nSolution \n\n- 判断n!中有多少个5\n- [Detail](https://leetcode-cn.com/problems/factorial-trailing-zeroes/solution/xiang-xi-tong-su-de-si-lu-fen-xi-by-windliang-3/)\n\n```java\npublic int trailingZeroes(int n) {\n    int count = 0;\n    while (n > 0) {\n        count += n / 5;\n        n = n / 5;\n    }\n    return count;\n}\n```\n### 190. Reverse Bits (Easy) [@](https://leetcode.com/problems/reverse-bits/)\n\n> Reverse bits of a given 32 bits unsigned integer.\n>\n> \n>\n> **Example 1:**\n>\n> ```\n> Input: 00000010100101000001111010011100\n> Output: 00111001011110000010100101000000\n> Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: 11111111111111111111111111111101\n> Output: 10111111111111111111111111111111\n> Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111.\n> ```\n>\n> \n>\n> **Note:**\n>\n> - Note that in some languages such as Java, there is no unsigned integer type. In this case, both input and output will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned.\n> - In Java, the compiler represents the signed integers using [2's complement notation](https://en.wikipedia.org/wiki/Two's_complement). Therefore, in **Example 2** above the input represents the signed integer `-3` and the output represents the signed integer `-1073741825`.\n>\n>  \n>\n> **Follow up**:\n>\n> If this function is called many times, how would you optimize it?\n\nSolution 1 shift\n\n```java\npublic class Solution {\n    // you need treat n as an unsigned value\n    public int reverseBits(int n) {\n        int res = 0;\n        int count = 0;\n        while (count < 32) {\n            res <<= 1; //res is shifted by 1 position to left\n            res |= (n & 1); //just pick the last pos of n to OR res\n            n >>= 1; //n is shifted by 1 pos to right => get rid of the last pos\n            count++;\n        }\n        return res;\n    }\n}\n```\n### 191. Number of 1 Bits (Easy) [@](https://leetcode.com/problems/number-of-1-bits/)\n\n> Write a function that takes an unsigned integer and return the number of '1' bits it has (also known as the [Hamming weight](http://en.wikipedia.org/wiki/Hamming_weight)).\n>\n> \n>\n> **Example 1:**\n>\n> ```\n> Input: 00000000000000000000000000001011\n> Output: 3\n> Explanation: The input binary string 00000000000000000000000000001011 has a total of three '1' bits.\n> ```\n>\n> **Example 2:**\n>\n> ```\n> Input: 00000000000000000000000010000000\n> Output: 1\n> Explanation: The input binary string 00000000000000000000000010000000 has a total of one '1' bit.\n> ```\n>\n> **Example 3:**\n>\n> ```\n> Input: 11111111111111111111111111111101\n> Output: 31\n> Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one '1' bits.\n> ```\n>\n> \n>\n> **Note:**\n>\n> - Note that in some languages such as Java, there is no unsigned integer type. In this case, the input will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned.\n> - In Java, the compiler represents the signed integers using [2's complement notation](https://en.wikipedia.org/wiki/Two's_complement). Therefore, in **Example 3** above the input represents the signed integer `-3`.\n>\n>  \n>\n> **Follow up**:\n>\n> If this function is called many times, how would you optimize it?\n\nSolution 1\n\n```java\npublic class Solution {\n    // you need to treat n as an unsigned value\n    public int hammingWeight(int n) {\n        int res = 0;\n        for (int i = 0; i < 32; i++) {\n            if ((n & 1) != 0) {\n                res++;\n            }\n            n >>= 1;\n        }\n        return res;\n    }\n}\n```\nSolution 2 Flip\n```java\npublic class Solution {\n    // you need to treat n as an unsigned value\n    public int hammingWeight(int n) {\n        int res = 0;\n        while (n != 0) {\n            res++;\n            //always flip the least-significant 1-bit to 0\n            n &= (n - 1);\n        }\n        return res;\n    }\n}\n```\n\n## Graph\n\n## Sliding Window\n\n## Partition","slug":"Leetcode-Summary","published":1,"updated":"2020-01-20T22:04:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcqk30xf000cpu9kamvp0t7r","content":"<p>Sources:</p>\n<ol>\n<li>summer</li>\n<li>1-50</li>\n<li>Top Interview Questions (before 200)</li>\n</ol>\n<h2 id=\"DFS-memo\"><a href=\"#DFS-memo\" class=\"headerlink\" title=\"DFS + memo\"></a>DFS + memo</h2><h3 id=\"98-Validate-Binary-Search-Tree-Medium\"><a href=\"#98-Validate-Binary-Search-Tree-Medium\" class=\"headerlink\" title=\"98. Validate Binary Search Tree (Medium) @\"></a>98. Validate Binary Search Tree (Medium) <a href=\"https://leetcode.com/problems/validate-binary-search-tree/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a binary tree, determine if it is a valid binary search tree (BST).</p>\n<p>Assume a BST is defined as follows:</p>\n<ul>\n<li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node’s key.</li>\n<li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node’s key.</li>\n<li>Both the left and right subtrees must also be binary search trees.</li>\n</ul>\n</blockquote>\n<p><strong>Solution 1 Recursion</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">helper</span><span class=\"params\">(TreeNode node, Integer lower, Integer upper)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> val = node.val;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lower != <span class=\"keyword\">null</span> &amp;&amp; val &lt;= lower) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (upper != <span class=\"keyword\">null</span> &amp;&amp; val &gt;= upper) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!helper(node.left, lower, val)) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!helper(node.right, val, upper)) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isValidBST</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> helper(root, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>Solution 2 Iteration</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LinkedList&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> LinkedList();</span><br><span class=\"line\">LinkedList&lt;Integer&gt; uppers = <span class=\"keyword\">new</span> LinkedList(), lowers = <span class=\"keyword\">new</span> LinkedList();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(TreeNode root, Integer lower, Integer upper)</span> </span>&#123;</span><br><span class=\"line\">    stack.add(root);</span><br><span class=\"line\">    uppers.add(upper);</span><br><span class=\"line\">    lowers.add(lower);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isValidBST</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">    Integer lower = <span class=\"keyword\">null</span>, upper = <span class=\"keyword\">null</span>, val;</span><br><span class=\"line\">    update(root, lower, upper);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!stack.isEmpty()) &#123;</span><br><span class=\"line\">        root = stack.poll();</span><br><span class=\"line\">        lower = lowers.poll();</span><br><span class=\"line\">        upper = uppers.poll();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        val = root.val;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lower != <span class=\"keyword\">null</span> &amp;&amp; val &lt;= lower) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (upper != <span class=\"keyword\">null</span> &amp;&amp; val &gt;= upper) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        update(root.left, lower, val);</span><br><span class=\"line\">        update(root.right, val, upper);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>Solution 3 Inorder Traversal</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isValidBST</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">    Stack&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> Stack();</span><br><span class=\"line\">    <span class=\"keyword\">double</span> inorder = - Double.MAX_VALUE;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!stack.isEmpty() || root != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (root != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            stack.push(root);</span><br><span class=\"line\">            root = root.left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        root = stack.pop();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.val &lt;= inorder) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        inorder = root.val;</span><br><span class=\"line\">        root = root.right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"101-Symmetric-Tree-Easy\"><a href=\"#101-Symmetric-Tree-Easy\" class=\"headerlink\" title=\"101. Symmetric Tree (Easy) @\"></a>101. Symmetric Tree (Easy) <a href=\"https://leetcode.com/problems/symmetric-tree/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>\n<p>For example, this binary tree <code>[1,2,2,3,4,4,3]</code> is symmetric:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;  1</span><br><span class=\"line\">&gt; / \\</span><br><span class=\"line\">&gt; 2   2</span><br><span class=\"line\">&gt; / \\ / \\</span><br><span class=\"line\">&gt; 3  4 4  3</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p>But the following <code>[1,2,2,null,3,null,3]</code> is not:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;  1</span><br><span class=\"line\">&gt; / \\</span><br><span class=\"line\">&gt; 2   2</span><br><span class=\"line\">&gt; \\   \\</span><br><span class=\"line\">&gt; 3    3</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p><strong>Solution 1 Recursion</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isMirror</span><span class=\"params\">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t1 == <span class=\"keyword\">null</span> &amp;&amp; t2 == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t1 == <span class=\"keyword\">null</span> || t2 == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (t1.val == t2.val) &amp;&amp; isMirror(t1.right, t2.left) &amp;&amp; isMirror(t1.left, t2.right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isSymmetric</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> isMirror(root.left, root.right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>Solution 2 Iteration</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isSymmetric</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    Queue&lt;TreeNode&gt; q = <span class=\"keyword\">new</span> LinkedList();</span><br><span class=\"line\">    q.add(root.left);</span><br><span class=\"line\">    q.add(root.right);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!q.isEmpty()) &#123;</span><br><span class=\"line\">        TreeNode t1 = q.poll();</span><br><span class=\"line\">        TreeNode t2 = q.poll();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t1 == <span class=\"keyword\">null</span> &amp;&amp; t2 == <span class=\"keyword\">null</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t1 == <span class=\"keyword\">null</span> || t2 == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t1.val != t2.val) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        q.add(t1.left);</span><br><span class=\"line\">        q.add(t2.right);</span><br><span class=\"line\">        q.add(t1.right);</span><br><span class=\"line\">        q.add(t2.left);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"104-Maximum-Depth-of-Binary-Tree-Easy\"><a href=\"#104-Maximum-Depth-of-Binary-Tree-Easy\" class=\"headerlink\" title=\"104. Maximum Depth of Binary Tree (Easy) @\"></a>104. Maximum Depth of Binary Tree (Easy) <a href=\"https://leetcode.com/problems/maximum-depth-of-binary-tree/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a binary tree, find its maximum depth.</p>\n<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>\n<p><strong>Note:</strong> A leaf is a node with no children.</p>\n<p><strong>Example:</strong></p>\n<p>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;  3</span><br><span class=\"line\">&gt; / \\</span><br><span class=\"line\">&gt; 9  20</span><br><span class=\"line\">&gt;  /  \\</span><br><span class=\"line\">&gt; 15   7</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p>return its depth = 3.</p>\n</blockquote>\n<p><strong>Solution 1 Recursion</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxDepth</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>Solution 2 Iteration (BFS)</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxDepth</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        LinkedList&lt;TreeNode&gt; queue = <span class=\"keyword\">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> level = <span class=\"number\">0</span>;</span><br><span class=\"line\">        queue.add(root);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> curNum = <span class=\"number\">1</span>, nextNum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">            TreeNode node = queue.poll();</span><br><span class=\"line\">            curNum--;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node.left != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                nextNum++;</span><br><span class=\"line\">                queue.add(node.left);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node.right != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                nextNum++;</span><br><span class=\"line\">                queue.add(node.right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (curNum == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                curNum = nextNum;</span><br><span class=\"line\">                nextNum = <span class=\"number\">0</span>;</span><br><span class=\"line\">                level++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> level;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal-Medium\"><a href=\"#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal-Medium\" class=\"headerlink\" title=\"105.  Construct Binary Tree from Preorder and Inorder Traversal (Medium) @\"></a>105.  Construct Binary Tree from Preorder and Inorder Traversal (Medium) <a href=\"https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given preorder and inorder traversal of a tree, construct the binary tree.</p>\n<p><strong>Note:</strong><br>You may assume that duplicates do not exist in the tree.</p>\n<p>For example, given</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; preorder = [3,9,20,15,7]</span><br><span class=\"line\">&gt; inorder = [9,3,15,20,7]</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p>Return the following binary tree:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;  3</span><br><span class=\"line\">&gt; / \\</span><br><span class=\"line\">&gt; 9  20</span><br><span class=\"line\">&gt;  /  \\</span><br><span class=\"line\">&gt; 15   7</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p><strong>Solution Divide and Conquer + Recursion</strong> </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">buildTree</span><span class=\"params\">(<span class=\"keyword\">int</span>[] preorder, <span class=\"keyword\">int</span>[] inorder)</span> </span>&#123;</span><br><span class=\"line\">        TreeNode root = createTree(preorder, <span class=\"number\">0</span>, preorder.length-<span class=\"number\">1</span>, inorder, <span class=\"number\">0</span>, inorder.length-<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> TreeNode <span class=\"title\">createTree</span><span class=\"params\">(<span class=\"keyword\">int</span>[] preorder, <span class=\"keyword\">int</span> startPre, <span class=\"keyword\">int</span> endPre, <span class=\"keyword\">int</span>[] inorder, <span class=\"keyword\">int</span> startIn, <span class=\"keyword\">int</span> endIn)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (startPre &gt; endPre || startIn &gt; endIn) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        TreeNode root = <span class=\"keyword\">new</span> TreeNode(preorder[startPre]);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = startIn; i &lt;= endIn; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (inorder[i] == preorder[startPre]) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//i-startIn是左子树长度</span></span><br><span class=\"line\">                root.left = createTree(preorder, startPre + <span class=\"number\">1</span>, startPre + i - startIn, inorder, startIn, i-<span class=\"number\">1</span>);</span><br><span class=\"line\">                <span class=\"comment\">//右子树开始节点是从左子树开始节点加上左子树的长度</span></span><br><span class=\"line\">                root.right = createTree(preorder, startPre + <span class=\"number\">1</span> + i - startIn, endPre, inorder, i + <span class=\"number\">1</span>, endIn);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"108-Convert-Sorted-Array-to-Binary-Search-Tree-Easy\"><a href=\"#108-Convert-Sorted-Array-to-Binary-Search-Tree-Easy\" class=\"headerlink\" title=\"108. Convert Sorted Array to Binary Search Tree (Easy) @\"></a>108. Convert Sorted Array to Binary Search Tree (Easy) <a href=\"https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p>\n<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of <em>every</em> node never differ by more than 1.</p>\n<p><strong>Example:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Given the sorted array: [-10,-3,0,5,9],</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt;    0</span><br><span class=\"line\">&gt;   / \\</span><br><span class=\"line\">&gt; -3   9</span><br><span class=\"line\">&gt; /   /</span><br><span class=\"line\">&gt; -10  5</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p><strong>Solution 1 Recursion</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">sortedArrayToBST</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dfs(nums, <span class=\"number\">0</span>, nums.length-<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> TreeNode <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> end)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (start &gt; end) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = (start + end) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        TreeNode root = <span class=\"keyword\">new</span> TreeNode(nums[mid]);</span><br><span class=\"line\">        root.left = dfs(nums, start, mid - <span class=\"number\">1</span>);</span><br><span class=\"line\">        root.right = dfs(nums, mid + <span class=\"number\">1</span>, end);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"116-Populating-Next-Right-Pointers-in-Each-Node-Medium\"><a href=\"#116-Populating-Next-Right-Pointers-in-Each-Node-Medium\" class=\"headerlink\" title=\"116. Populating Next Right Pointers in Each Node (Medium) @\"></a>116. Populating Next Right Pointers in Each Node (Medium) <a href=\"https://leetcode.com/problems/populating-next-right-pointers-in-each-node/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>You are given a <strong>perfect binary tree</strong> where all leaves are on the same level, and every parent has two children.</p>\n<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p>\n<p>Initially, all next pointers are set to <code>NULL</code>.</p>\n<p><strong>Follow up:</strong></p>\n<ul>\n<li>You may only use constant extra space.</li>\n<li>Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem.</li>\n</ul>\n</blockquote>\n<p><strong>Solution 1 Recursion</strong></p>\n<p>这道题解法还是挺直白的，如果当前节点有左孩子，那么左孩子的next就指向右孩子。如果当前节点有右孩子，那么判断，如果当前节点的next是null，说明当前节点已经到了最右边，那么右孩子也是最右边的，所以右孩子指向null。如果当前节点的next不是null，那么当前节点的右孩子的next就需要指向当前节点next的左孩子。递归求解就好。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">// Definition for a Node.</span></span><br><span class=\"line\"><span class=\"comment\">class Node &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    public int val;</span></span><br><span class=\"line\"><span class=\"comment\">    public Node left;</span></span><br><span class=\"line\"><span class=\"comment\">    public Node right;</span></span><br><span class=\"line\"><span class=\"comment\">    public Node next;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    public Node() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">    </span></span><br><span class=\"line\"><span class=\"comment\">    public Node(int _val) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        val = _val;</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    public Node(int _val, Node _left, Node _right, Node _next) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        val = _val;</span></span><br><span class=\"line\"><span class=\"comment\">        left = _left;</span></span><br><span class=\"line\"><span class=\"comment\">        right = _right;</span></span><br><span class=\"line\"><span class=\"comment\">        next = _next;</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Node <span class=\"title\">connect</span><span class=\"params\">(Node root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.left != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            root.left.next = root.right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.right != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                root.right.next = root.next.left;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                root.right.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        connect(root.left);</span><br><span class=\"line\">        connect(root.right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"124-Binary-Tree-Maximum-Path-Sum-Hard\"><a href=\"#124-Binary-Tree-Maximum-Path-Sum-Hard\" class=\"headerlink\" title=\"124. Binary Tree Maximum Path Sum (Hard) @\"></a>124. Binary Tree Maximum Path Sum (Hard) <a href=\"https://leetcode.com/problems/binary-tree-maximum-path-sum/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a <strong>non-empty</strong> binary tree, find the maximum path sum.</p>\n<p>For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain <strong>at least one node</strong> and does not need to go through the root.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [1,2,3]</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt;     1</span><br><span class=\"line\">&gt;    / \\</span><br><span class=\"line\">&gt;   2   3</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; Output: 6</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [-10,9,20,null,null,15,7]</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; -10</span><br><span class=\"line\">&gt; / \\</span><br><span class=\"line\">&gt; 9  20</span><br><span class=\"line\">&gt;  /  \\</span><br><span class=\"line\">&gt; 15   7</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; Output: 42</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<ul>\n<li>递归的思想，DFS，从下到上</li>\n<li>每个节点可以与其左右节点结合，但每个节点作为子节点返回时，只能选去该节点的值和其较大子节点的值的和返回<br>Solution<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = Integer.MIN_VALUE;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxPathSum</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        helper(root);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">helper</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = Math.max(helper(root.left), <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> right = Math.max(helper(root.right), <span class=\"number\">0</span>);</span><br><span class=\"line\">        res = Math.max(res, left + right + root.val);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.max(left, right) + root.val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"130-Surrounded-Regions-Medium\"><a href=\"#130-Surrounded-Regions-Medium\" class=\"headerlink\" title=\"130. Surrounded Regions (Medium) @\"></a>130. Surrounded Regions (Medium) <a href=\"https://leetcode.com/problems/surrounded-regions/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a 2D board containing <code>&#39;X&#39;</code> and <code>&#39;O&#39;</code> (<strong>the letter O</strong>), capture all regions surrounded by <code>&#39;X&#39;</code>.</p>\n<p>A region is captured by flipping all <code>&#39;O&#39;</code>s into <code>&#39;X&#39;</code>s in that surrounded region.</p>\n<p><strong>Example:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; X X X X</span><br><span class=\"line\">&gt; X O O X</span><br><span class=\"line\">&gt; X X O X</span><br><span class=\"line\">&gt; X O X X</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p>After running your function, the board should be:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; X X X X</span><br><span class=\"line\">&gt; X X X X</span><br><span class=\"line\">&gt; X X X X</span><br><span class=\"line\">&gt; X O X X</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Explanation:</strong></p>\n<p>Surrounded regions shouldn’t be on the border, which means that any <code>&#39;O&#39;</code> on the border of the board are not flipped to <code>&#39;X&#39;</code>. Any <code>&#39;O&#39;</code> that is not on the border and it is not connected to an <code>&#39;O&#39;</code> on the border will be flipped to <code>&#39;X&#39;</code>. Two cells are connected if they are adjacent cells connected horizontally or vertically.</p>\n</blockquote>\n<p><strong>Solution Recursion</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">(<span class=\"keyword\">char</span>[][] board)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (board == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rows = board.length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rows &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> cols = board[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cols &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 找到边缘‘O’</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; rows; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (board[i][<span class=\"number\">0</span>] == <span class=\"string\">'O'</span>)</span><br><span class=\"line\">                dfs(board, i, <span class=\"number\">0</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (board[i][cols-<span class=\"number\">1</span>] == <span class=\"string\">'O'</span>)</span><br><span class=\"line\">                dfs(board, i, cols-<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; cols; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (board[<span class=\"number\">0</span>][i] == <span class=\"string\">'O'</span>)</span><br><span class=\"line\">                dfs(board, <span class=\"number\">0</span>, i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (board[rows-<span class=\"number\">1</span>][i] == <span class=\"string\">'O'</span>)</span><br><span class=\"line\">                dfs(board, rows-<span class=\"number\">1</span>, i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; rows; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; cols; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (board[i][j] == <span class=\"string\">'#'</span>)</span><br><span class=\"line\">                    board[i][j] = <span class=\"string\">'O'</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (board[i][j] == <span class=\"string\">'O'</span>)</span><br><span class=\"line\">                    board[i][j] = <span class=\"string\">'X'</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//每遇到‘O’后，向四个方向递归搜索，所有相邻‘O’变为‘#’</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">char</span>[][] board, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (board[i][j] == <span class=\"string\">'O'</span>) &#123;</span><br><span class=\"line\">            board[i][j] = <span class=\"string\">'#'</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 跳过四周边缘</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &lt; board.length - <span class=\"number\">2</span>)</span><br><span class=\"line\">                dfs(board, i + <span class=\"number\">1</span>, j);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">                dfs(board, i - <span class=\"number\">1</span>, j);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (j &lt; board[<span class=\"number\">0</span>].length - <span class=\"number\">2</span>)</span><br><span class=\"line\">                dfs(board, i, j + <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (j &gt; <span class=\"number\">1</span>) </span><br><span class=\"line\">                dfs(board, i, j - <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"200-Number-of-Islands-Medium\"><a href=\"#200-Number-of-Islands-Medium\" class=\"headerlink\" title=\"200. Number of Islands (Medium) @\"></a>200. Number of Islands (Medium) <a href=\"https://leetcode.com/problems/number-of-islands/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a 2d grid map of <code>&#39;1&#39;</code>s (land) and <code>&#39;0&#39;</code>s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input:</span><br><span class=\"line\">&gt; 11110</span><br><span class=\"line\">&gt; 11010</span><br><span class=\"line\">&gt; 11000</span><br><span class=\"line\">&gt; 00000</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; Output: 1</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input:</span><br><span class=\"line\">&gt; 11000</span><br><span class=\"line\">&gt; 11000</span><br><span class=\"line\">&gt; 00100</span><br><span class=\"line\">&gt; 00011</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; Output: 3</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p><strong>Solution DFS + Recursion</strong></p>\n<ul>\n<li>采用DFS，访问过的‘1’转为‘0’，继续遍历<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">numIslands</span><span class=\"params\">(<span class=\"keyword\">char</span>[][] grid)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (grid == <span class=\"keyword\">null</span> || grid.length == <span class=\"number\">0</span> || grid[<span class=\"number\">0</span>].length == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rows = grid.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> cols = grid[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; rows; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; cols; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (grid[i][j] == <span class=\"string\">'1'</span>)&#123;</span><br><span class=\"line\">                    count++;</span><br><span class=\"line\">                    dfs(grid, i, j);    </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">char</span>[][] grid, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &lt; <span class=\"number\">0</span> || i &gt; grid.length-<span class=\"number\">1</span> || j &lt; <span class=\"number\">0</span> || j &gt; grid[<span class=\"number\">0</span>].length-<span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (grid[i][j] == <span class=\"string\">'0'</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (grid[i][j] == <span class=\"string\">'1'</span>) &#123;</span><br><span class=\"line\">            grid[i][j] = <span class=\"string\">'0'</span>;</span><br><span class=\"line\">            dfs(grid, i-<span class=\"number\">1</span>, j);</span><br><span class=\"line\">            dfs(grid, i+<span class=\"number\">1</span>, j);</span><br><span class=\"line\">            dfs(grid, i, j-<span class=\"number\">1</span>);</span><br><span class=\"line\">            dfs(grid, i, j+<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"207-Course-Schedule-Medium\"><a href=\"#207-Course-Schedule-Medium\" class=\"headerlink\" title=\"207. Course Schedule (Medium) @\"></a>207. Course Schedule (Medium) <a href=\"https://leetcode.com/problems/course-schedule/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>There are a total of <em>n</em> courses you have to take, labeled from <code>0</code> to <code>n-1</code>.</p>\n<p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: <code>[0,1]</code></p>\n<p>Given the total number of courses and a list of prerequisite <strong>pairs</strong>, is it possible for you to finish all courses?</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: 2, [[1,0]] </span><br><span class=\"line\">&gt; Output: true</span><br><span class=\"line\">&gt; Explanation: There are a total of 2 courses to take. </span><br><span class=\"line\">&gt;           To take course 1 you should have finished course 0. So it is possible.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: 2, [[1,0],[0,1]]</span><br><span class=\"line\">&gt; Output: false</span><br><span class=\"line\">&gt; Explanation: There are a total of 2 courses to take. </span><br><span class=\"line\">&gt;           To take course 1 you should have finished course 0, and to take course 0 you should</span><br><span class=\"line\">&gt;           also have finished course 1. So it is impossible.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Note:</strong></p>\n<ol>\n<li>The input prerequisites is a graph represented by <strong>a list of edges</strong>, not adjacency matrices. Read more about <a href=\"https://www.khanacademy.org/computing/computer-science/algorithms/graph-representation/a/representing-graphs\" target=\"_blank\" rel=\"noopener\">how a graph is represented</a>.</li>\n<li>You may assume that there are no duplicate edges in the input prerequisites.</li>\n</ol>\n</blockquote>\n<p><strong>Solution Topology</strong></p>\n<ul>\n<li>此问题等价于图中是否有无环的存在（拓扑排序解决问题）<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">canFinish</span><span class=\"params\">(<span class=\"keyword\">int</span> numCourses, <span class=\"keyword\">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;Integer, List&lt;Integer&gt;&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] indegree = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[numCourses]; </span><br><span class=\"line\">        <span class=\"comment\">//初始化图，利用hashmap</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; prerequisites.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> s_node = prerequisites[i][<span class=\"number\">0</span>];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> e_node = prerequisites[i][<span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!map.containsKey(s_node))</span><br><span class=\"line\">                map.put(s_node, <span class=\"keyword\">new</span> ArrayList&lt;&gt;());</span><br><span class=\"line\">            map.get(s_node).add(e_node);</span><br><span class=\"line\">            indegree[e_node]++;<span class=\"comment\">//更新每个点的入度</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//储存所有入度为0的节点-&gt;拓扑排序起始点</span></span><br><span class=\"line\">        Queue&lt;Integer&gt; q = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (indegree[i] == <span class=\"number\">0</span>)</span><br><span class=\"line\">                q.offer(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//计算可拓扑排序的节点个数</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!q.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> val = q.poll();</span><br><span class=\"line\">            count++;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (map.containsKey(val)) &#123;</span><br><span class=\"line\">                List&lt;Integer&gt; tmp = map.get(val);</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; tmp.size(); i++) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> idx = tmp.get(i);</span><br><span class=\"line\">                    indegree[idx]--;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (indegree[idx] == <span class=\"number\">0</span>)</span><br><span class=\"line\">                        q.offer(idx);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> count == numCourses;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"210-Course-Schedule-II-Medium\"><a href=\"#210-Course-Schedule-II-Medium\" class=\"headerlink\" title=\"210. Course Schedule II (Medium) @\"></a>210. Course Schedule II (Medium) <a href=\"https://leetcode.com/problems/course-schedule-ii/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>There are a total of <em>n</em> courses you have to take, labeled from <code>0</code> to <code>n-1</code>.</p>\n<p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: <code>[0,1]</code></p>\n<p>Given the total number of courses and a list of prerequisite <strong>pairs</strong>, return the ordering of courses you should take to finish all courses.</p>\n<p>There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: 2, [[1,0]] </span><br><span class=\"line\">&gt; Output: [0,1]</span><br><span class=\"line\">&gt; Explanation: There are a total of 2 courses to take. To take course 1 you should have finished   </span><br><span class=\"line\">&gt;           course 0. So the correct course order is [0,1] .</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: 4, [[1,0],[2,0],[3,1],[3,2]]</span><br><span class=\"line\">&gt; Output: [0,1,2,3] or [0,2,1,3]</span><br><span class=\"line\">&gt; Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both     </span><br><span class=\"line\">&gt;           courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. </span><br><span class=\"line\">&gt;           So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3] .</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Note:</strong></p>\n<ol>\n<li>The input prerequisites is a graph represented by <strong>a list of edges</strong>, not adjacency matrices. Read more about <a href=\"https://www.khanacademy.org/computing/computer-science/algorithms/graph-representation/a/representing-graphs\" target=\"_blank\" rel=\"noopener\">how a graph is represented</a>.</li>\n<li>You may assume that there are no duplicate edges in the input prerequisites.</li>\n</ol>\n</blockquote>\n<p><strong>Solution Topology</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] findOrder(<span class=\"keyword\">int</span> numCourses, <span class=\"keyword\">int</span>[][] prerequisites) &#123;</span><br><span class=\"line\">        Map&lt;Integer, List&lt;Integer&gt;&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] indegree = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[numCourses]; </span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] res = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[numCourses];</span><br><span class=\"line\">        <span class=\"comment\">//初始化图，利用hashmap</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; prerequisites.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> s_node = prerequisites[i][<span class=\"number\">0</span>];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> e_node = prerequisites[i][<span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!map.containsKey(s_node))</span><br><span class=\"line\">                map.put(s_node, <span class=\"keyword\">new</span> ArrayList&lt;&gt;());</span><br><span class=\"line\">            map.get(s_node).add(e_node);</span><br><span class=\"line\">            indegree[e_node]++;<span class=\"comment\">//更新每个点的入度</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//储存所有入度为0的节点-&gt;拓扑排序起始点</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = numCourses - <span class=\"number\">1</span>;</span><br><span class=\"line\">        Queue&lt;Integer&gt; q = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (indegree[i] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                q.offer(i);</span><br><span class=\"line\">                res[index--] = i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//拓扑排序</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!q.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> val = q.poll();</span><br><span class=\"line\">            <span class=\"comment\">//获取val指向的节点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (map.containsKey(val)) &#123;</span><br><span class=\"line\">                List&lt;Integer&gt; tmp = map.get(val);</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; tmp.size(); i++) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> idx = tmp.get(i);</span><br><span class=\"line\">                    indegree[idx]--;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (indegree[idx] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        q.offer(idx);</span><br><span class=\"line\">                        res[index--] = idx;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index != -<span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"BFS\"><a href=\"#BFS\" class=\"headerlink\" title=\"BFS\"></a>BFS</h2><h3 id=\"102-Binary-Tree-Level-Order-Traversal-Medium\"><a href=\"#102-Binary-Tree-Level-Order-Traversal-Medium\" class=\"headerlink\" title=\"102. Binary Tree Level Order Traversal (Medium) @\"></a>102. Binary Tree Level Order Traversal (Medium) <a href=\"https://leetcode.com/problems/binary-tree-level-order-traversal/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a binary tree, return the <em>level order</em> traversal of its nodes’ values. (ie, from left to right, level by level).</p>\n<p>For example:<br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;  3</span><br><span class=\"line\">&gt; / \\</span><br><span class=\"line\">&gt; 9  20</span><br><span class=\"line\">&gt;  /  \\</span><br><span class=\"line\">&gt; 15   7</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p>return its level order traversal as:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; [</span><br><span class=\"line\">&gt; [3],</span><br><span class=\"line\">&gt; [9,20],</span><br><span class=\"line\">&gt; [15,7]</span><br><span class=\"line\">&gt; ]</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p><strong>Solution 1 Recursion</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class=\"line\">        helper(root, res, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">helper</span><span class=\"params\">(TreeNode root, List&lt;List&lt;Integer&gt;&gt; res, <span class=\"keyword\">int</span> level)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (res.size() &lt; level+<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            res.add(<span class=\"keyword\">new</span> ArrayList&lt;Integer&gt; ());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        res.get(level).add(root.val);</span><br><span class=\"line\">        </span><br><span class=\"line\">        helper(root.left, res, level+<span class=\"number\">1</span>);</span><br><span class=\"line\">        helper(root.right, res, level+<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>Solution 2 Iteration (Queue)</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Queue&lt;TreeNode&gt; queue = <span class=\"keyword\">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class=\"line\">        queue.offer(root);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> level = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//start current level</span></span><br><span class=\"line\">            res.add(<span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;());</span><br><span class=\"line\">            <span class=\"comment\">//num of elements in current level</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> len = queue.size();</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">                TreeNode node = queue.poll();</span><br><span class=\"line\">                <span class=\"comment\">//get the val in each level</span></span><br><span class=\"line\">                res.get(level).add(node.val);</span><br><span class=\"line\">                <span class=\"comment\">//add child nodes to queue</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node.left != <span class=\"keyword\">null</span>) queue.offer(node.left);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node.right != <span class=\"keyword\">null</span>) queue.offer(node.right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//go to next level</span></span><br><span class=\"line\">            level++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"103-Binary-Tree-Zigzag-Level-Order-Traversal-Medium\"><a href=\"#103-Binary-Tree-Zigzag-Level-Order-Traversal-Medium\" class=\"headerlink\" title=\"103. Binary Tree Zigzag Level Order Traversal (Medium) @\"></a>103. Binary Tree Zigzag Level Order Traversal (Medium) <a href=\"https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a binary tree, return the <em>zigzag level order</em> traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).</p>\n<p>For example:<br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;  3</span><br><span class=\"line\">&gt; / \\</span><br><span class=\"line\">&gt; 9  20</span><br><span class=\"line\">&gt;  /  \\</span><br><span class=\"line\">&gt; 15   7</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p>return its zigzag level order traversal as:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; [</span><br><span class=\"line\">&gt; [3],</span><br><span class=\"line\">&gt; [20,9],</span><br><span class=\"line\">&gt; [15,7]</span><br><span class=\"line\">&gt; ]</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p><strong>Solution Recursion</strong></p>\n<ul>\n<li>based on 102, add a flag to identify reverse<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class=\"line\">        helper(root, res, <span class=\"number\">0</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">helper</span><span class=\"params\">(TreeNode root, List&lt;List&lt;Integer&gt;&gt; res, <span class=\"keyword\">int</span> level, <span class=\"keyword\">boolean</span> flag)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (res.size() &lt; level+<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            res.add(<span class=\"keyword\">new</span> LinkedList&lt;Integer&gt; ());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (flag) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//convert to LinkedList</span></span><br><span class=\"line\">            ((LinkedList&lt;Integer&gt;)res.get(level)).addFirst(root.val);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            res.get(level).add(root.val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        helper(root.left, res, level+<span class=\"number\">1</span>, !flag);</span><br><span class=\"line\">        helper(root.right, res, level+<span class=\"number\">1</span>, !flag);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"127-Word-Ladder-Medium\"><a href=\"#127-Word-Ladder-Medium\" class=\"headerlink\" title=\"127. Word Ladder (Medium) @\"></a>127. Word Ladder (Medium) <a href=\"https://leetcode.com/problems/word-ladder/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary’s word list, find the length of shortest transformation sequence from <em>beginWord</em> to <em>endWord</em>, such that:</p>\n<ol>\n<li>Only one letter can be changed at a time.</li>\n<li>Each transformed word must exist in the word list. Note that <em>beginWord</em> is <em>not</em> a transformed word.</li>\n</ol>\n<p><strong>Note:</strong></p>\n<ul>\n<li>Return 0 if there is no such transformation sequence.</li>\n<li>All words have the same length.</li>\n<li>All words contain only lowercase alphabetic characters.</li>\n<li>You may assume no duplicates in the word list.</li>\n<li>You may assume <em>beginWord</em> and <em>endWord</em> are non-empty and are not the same.</li>\n</ul>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input:</span><br><span class=\"line\">&gt; beginWord = &quot;hit&quot;,</span><br><span class=\"line\">&gt; endWord = &quot;cog&quot;,</span><br><span class=\"line\">&gt; wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; Output: 5</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; Explanation: As one shortest transformation is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,</span><br><span class=\"line\">&gt; return its length 5.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input:</span><br><span class=\"line\">&gt; beginWord = &quot;hit&quot;</span><br><span class=\"line\">&gt; endWord = &quot;cog&quot;</span><br><span class=\"line\">&gt; wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; Output: 0</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; Explanation: The endWord &quot;cog&quot; is not in wordList, therefore no </span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p><strong>Solution 1 BFS (Time Limit Exceeded)</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">ladderLength</span><span class=\"params\">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!wordList.contains(endWord)) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        Queue&lt;String&gt; queue = <span class=\"keyword\">new</span> LinkedList&lt;String&gt;();</span><br><span class=\"line\">        queue.offer(beginWord);</span><br><span class=\"line\">        HashMap&lt;String, Integer&gt; maps = <span class=\"keyword\">new</span> HashMap&lt;String, Integer&gt;(); <span class=\"comment\">//store the level of each string</span></span><br><span class=\"line\">        maps.put(beginWord, <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (wordList.contains(beginWord)) wordList.remove(beginWord);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">            String top = queue.poll();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> len = top.length();</span><br><span class=\"line\">            StringBuilder builder;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">int</span> level = maps.get(top);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//find the strings which is one char diff with top</span></span><br><span class=\"line\">                builder = <span class=\"keyword\">new</span> StringBuilder(top);</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> c = <span class=\"string\">'a'</span>; c &lt;= <span class=\"string\">'z'</span>; c++) &#123;</span><br><span class=\"line\">                    builder.setCharAt(i, c);</span><br><span class=\"line\">                    String tmpStr = builder.toString();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (tmpStr.equals(top))<span class=\"comment\">//match top</span></span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    <span class=\"comment\">//add to next level</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (wordList.contains(tmpStr)) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (tmpStr.equals(endWord))<span class=\"comment\">//match endWord-&gt;return </span></span><br><span class=\"line\">                            <span class=\"keyword\">return</span> level+<span class=\"number\">1</span>;</span><br><span class=\"line\">                        queue.offer(tmpStr);</span><br><span class=\"line\">                        wordList.remove(tmpStr);</span><br><span class=\"line\">                        maps.put(tmpStr, level+<span class=\"number\">1</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 2 Bidirectional Breadth First Search<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">ladderLength</span><span class=\"params\">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!wordList.contains(endWord)) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//top-&gt;down</span></span><br><span class=\"line\">        Queue&lt;String&gt; queue1 = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        queue1.add(beginWord);</span><br><span class=\"line\">        <span class=\"comment\">//down-&gt;top</span></span><br><span class=\"line\">        Queue&lt;String&gt; queue2 = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        queue2.add(endWord);</span><br><span class=\"line\">        </span><br><span class=\"line\">        Set&lt;String&gt; visited = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        visited.add(endWord);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> step = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(queue1.size() &gt; <span class=\"number\">0</span> &amp;&amp; queue2.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// always start from smaller number of queue </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(queue1.size() &gt; queue2.size()) &#123;</span><br><span class=\"line\">                Queue&lt;String&gt; temp = queue1;</span><br><span class=\"line\">                queue1 = queue2;</span><br><span class=\"line\">                queue2 = temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            Queue&lt;String&gt; nextQueue = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(!queue1.isEmpty()) &#123;</span><br><span class=\"line\">                String cur = queue1.poll();</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(String word: wordList) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(valid(cur, word)) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(queue2.contains(word)) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">return</span> step+<span class=\"number\">1</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        </span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(!visited.contains(word)) &#123;</span><br><span class=\"line\">                            nextQueue.add(word);</span><br><span class=\"line\">                            visited.add(word);                            </span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            queue1 = nextQueue;</span><br><span class=\"line\">            step++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//whether step==1</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">valid</span><span class=\"params\">(String a, String b)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> diff = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; a.length(); ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(a.charAt(i) != b.charAt(i)) &#123;</span><br><span class=\"line\">                diff++;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(diff &gt;= <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"DP-DP-lt-–-gt-DFS-memo\"><a href=\"#DP-DP-lt-–-gt-DFS-memo\" class=\"headerlink\" title=\"DP (DP&lt;–&gt;DFS + memo)\"></a>DP (DP&lt;–&gt;DFS + memo)</h2><h3 id=\"53-Maximum-Subarray-Easy\"><a href=\"#53-Maximum-Subarray-Easy\" class=\"headerlink\" title=\"53.Maximum Subarray (Easy) @\"></a>53.Maximum Subarray (Easy) <a href=\"https://leetcode.com/problems/maximum-subarray/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given an integer array <code>nums</code>, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p>\n<p><strong>Example:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class=\"line\">&gt; Output: 6</span><br><span class=\"line\">&gt; Explanation: [4,-1,2,1] has the largest sum = 6.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Follow up:</strong></p>\n<p>If you have figured out the O(<em>n</em>) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p>\n</blockquote>\n<p><strong>Solution 1</strong></p>\n<ul>\n<li>遍历所有子序列O(n^3) -&gt; 住需要遍历从起始位置开始的子序列 O(n^2) -&gt;</li>\n<li>起始位置为负时，显然不是最大子序列和起始点。所以从负数部位最大子序列和的起点出发 O(n)<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxSubArray</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nSize = nums.length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nSize == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxSum = Integer.MIN_VALUE;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nSize; i++) &#123;</span><br><span class=\"line\">            nSum += nums[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nSum &gt; maxSum)</span><br><span class=\"line\">                maxSum = nSum;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nSum &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                nSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxSum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"62-Unique-Paths-Medium\"><a href=\"#62-Unique-Paths-Medium\" class=\"headerlink\" title=\"62. Unique Paths (Medium) @\"></a>62. Unique Paths (Medium) <a href=\"https://leetcode.com/problems/unique-paths/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>A robot is located at the top-left corner of a <em>m</em> x <em>n</em> grid (marked ‘Start’ in the diagram below).</p>\n<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>\n<p>How many possible unique paths are there?</p>\n<p><strong>Note:</strong> <em>m</em> and <em>n</em> will be at most 100.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: m = 3, n = 2</span><br><span class=\"line\">&gt; Output: 3</span><br><span class=\"line\">&gt; Explanation:</span><br><span class=\"line\">&gt; From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:</span><br><span class=\"line\">&gt; 1. Right -&gt; Right -&gt; Down</span><br><span class=\"line\">&gt; 2. Right -&gt; Down -&gt; Right</span><br><span class=\"line\">&gt; 3. Down -&gt; Right -&gt; Right</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p><strong>Solution 1</strong> </p>\n<ul>\n<li>dp[i] [j] = dp[i-1] [j] + dp[i] [j-1]</li>\n<li>O(m*n)<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">uniquePaths</span><span class=\"params\">(<span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//dp[i][j] = dp[i-1][j] + dp[i][j-1];</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[m][n];</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                    dp[i][j] += dp[i-<span class=\"number\">1</span>][j];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                    dp[i][j] += dp[i][j-<span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[m-<span class=\"number\">1</span>][n-<span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>Solution 2</strong></p>\n<ul>\n<li>空间复杂度 O(m*n) -&gt; O(n)</li>\n<li>dp[j]: (0,0) -&gt; (i,j)</li>\n<li>dp[j-1]表示dp[j]上方的值</li>\n<li>dp[j] = dp[j] + dp[j-1]</li>\n<li>一列一列更新，只保存一列的数据<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">uniquePaths</span><span class=\"params\">(<span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//dp[j]: num of paths from (0,0) to (i-1,j)</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">                dp[j] += dp[j-<span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n-<span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"70-Climbing-Stairs-Easy\"><a href=\"#70-Climbing-Stairs-Easy\" class=\"headerlink\" title=\"70. Climbing Stairs (Easy) @\"></a>70. Climbing Stairs (Easy) <a href=\"https://leetcode.com/problems/climbing-stairs/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>You are climbing a stair case. It takes <em>n</em> steps to reach to the top.</p>\n<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>\n<p><strong>Note:</strong> Given <em>n</em> will be a positive integer.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: 2</span><br><span class=\"line\">&gt; Output: 2</span><br><span class=\"line\">&gt; Explanation: There are two ways to climb to the top.</span><br><span class=\"line\">&gt; 1. 1 step + 1 step</span><br><span class=\"line\">&gt; 2. 2 steps</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: 3</span><br><span class=\"line\">&gt; Output: 3</span><br><span class=\"line\">&gt; Explanation: There are three ways to climb to the top.</span><br><span class=\"line\">&gt; 1. 1 step + 1 step + 1 step</span><br><span class=\"line\">&gt; 2. 1 step + 2 steps</span><br><span class=\"line\">&gt; 3. 2 steps + 1 step</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution 1 DP</p>\n<ul>\n<li>假设梯子有n层，那么如何爬到第n层呢，因为每次只能怕1或2步，那么爬到第n层的方法要么是从第n-1层一步上来的，要不就是从n-2层2步上来的，所以递推公式非常容易的就得出了<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">climbStairs</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//dp[i] = dp[i-1] + dp[i-2];</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n+<span class=\"number\">1</span>];</span><br><span class=\"line\">        dp[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        dp[<span class=\"number\">2</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">3</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            dp[i] = dp[i - <span class=\"number\">1</span>] + dp[i - <span class=\"number\">2</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>Solution 2 Fibonacci Number<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">climbStairs</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> first = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> second = <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">3</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> third = first + second;</span><br><span class=\"line\">            first = second;</span><br><span class=\"line\">            second = third;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> second;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"91-Decode-Ways-Medium\"><a href=\"#91-Decode-Ways-Medium\" class=\"headerlink\" title=\"91. Decode Ways (Medium) @\"></a>91. Decode Ways (Medium) <a href=\"https://leetcode.com/problems/decode-ways/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>A message containing letters from <code>A-Z</code> is being encoded to numbers using the following mapping:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; &apos;A&apos; -&gt; 1</span><br><span class=\"line\">&gt; &apos;B&apos; -&gt; 2</span><br><span class=\"line\">&gt; ...</span><br><span class=\"line\">&gt; &apos;Z&apos; -&gt; 26</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p>Given a <strong>non-empty</strong> string containing only digits, determine the total number of ways to decode it.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: &quot;12&quot;</span><br><span class=\"line\">&gt; Output: 2</span><br><span class=\"line\">&gt; Explanation: It could be decoded as &quot;AB&quot; (1 2) or &quot;L&quot; (12).</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: &quot;226&quot;</span><br><span class=\"line\">&gt; Output: 3</span><br><span class=\"line\">&gt; Explanation: It could be decoded as &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), or &quot;BBF&quot; (2 2 6).</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p><strong>Solution</strong></p>\n<ul>\n<li><p>设定状态为：<code>dp[i]</code>表示<code>s</code>从<code>0</code>开始，长度为<code>i</code>的子串的解码方式数量，于是我们最终要求的答案便是<code>dp[n]</code>。</p>\n<p>那么如何求解<code>dp[i]</code>呢？这个很简单，枚举最后一个字母对应1位还是2位，将f转化为规模更小的子问题。</p>\n<ul>\n<li>设<code>dp[i] = 0</code></li>\n<li>枚举最后一个字母对应1位（要求<code>s[i - 1] != &#39;0&#39;</code>)，那么有<code>dp[i] += dp[i-1]</code>；</li>\n<li>枚举最后一个字母对应2位（要求<code>i &gt; 1</code>且<code>s[i - 2]</code>和<code>s[i - 1]</code>组成的字符串在<code>&quot;10&quot;~&quot;26&quot;</code>的范围内），那么有<code>dp[i] += dp[i - 2]</code>；</li>\n</ul>\n</li>\n<li><p>也就是说，我们可以通过dp[i - 1]和dp[i - 2]计算出dp[i]来，这就是我们的状态和转移方程。</p>\n</li>\n<li><p>在具体实现中，我们可以按照i从1到n的顺序，依次计算出所有的dp[i]。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">numDecodings</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.length() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[s.length()+<span class=\"number\">1</span>];</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">//dp[i] 表示s从0开始，长度为i的字串的解码方式数量</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; s.length()+<span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s.charAt(i-<span class=\"number\">1</span>) != <span class=\"string\">'0'</span>) </span><br><span class=\"line\">                dp[i] += dp[i-<span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">2</span> &amp;&amp; (s.substring(i-<span class=\"number\">2</span>, i).compareTo(<span class=\"string\">\"10\"</span>) &gt;= <span class=\"number\">0</span> &amp;&amp; s.substring(i-<span class=\"number\">2</span>, i).compareTo(<span class=\"string\">\"26\"</span>) &lt;= <span class=\"number\">0</span>))</span><br><span class=\"line\">                dp[i] += dp[i - <span class=\"number\">2</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[s.length()];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"121-Best-Time-to-Buy-and-Sell-Stock-Easy\"><a href=\"#121-Best-Time-to-Buy-and-Sell-Stock-Easy\" class=\"headerlink\" title=\"121. Best Time to Buy and Sell Stock (Easy) @\"></a>121. Best Time to Buy and Sell Stock (Easy) <a href=\"https://leetcode.com/problems/best-time-to-buy-and-sell-stock/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n</blockquote>\n<p><strong>Solution</strong></p>\n<p>如果是动态规划的思路， 基本上我们要定义状态dp[i]， 然后看dp[i]和dp[i-1]或者dp[i-k]之间的关系。<br>假设我们定义dp[i]是在i天的最大利润， 那么和前面的重叠子问题的关系是什么呢？</p>\n<ul>\n<li>一种情况当然是前面子问题里面的最大利润已经是整体的最大利润， 那么dp[i]=dp[i-1]<br>还有一种情况是， 前面虽然取得了利润， 但是第i天卖出（对应到前面某一天买入)会产生更大的利润<br>这时候，dp[i] = prices[i] - prices[j]<br>也就是说, 整个递推公式是: dp[i] = Math.max(dp[i-1], prices[i]-prices[j]), 其中, j&lt;i<br>这样， 对于每个dp[i], 都只和之前的状态和数据有关， 和后面的选择已经无关了。<br>然后这时候要考虑， prices[j]是哪个值会产生最大利润？ 当然是目前为止的最小值。<br>也就是说， dp[j] = min prices so far， 而且这个值的好处是， 在一次遍历的过程中，可以直接随着遍历更新这个值。那么， 可以保存一个min值， 这样整体一次遍历就可以了。</li>\n<li>有一个错误的思路， 就是一次遍历求出最小价格和最大价格， 然后得出利润。<br>这个解法的错误的地方在于， 最大价格可能是最小价格的前面， 不能直接使用。<br>反例比如[3,1,2]</li>\n<li>前面的错误在于把顺序不符合要求的情况包括进去了，<br>当然， 这个过程可以更简化。 甚至可以不需要用这么复杂的动态规划的思路, 直接对问题进行分析。<br>对于最大利润的买入和卖出位置， 虽然买入和卖出可能出现在任意位置， 但是我们考虑如果固定其中一个价格会怎么样？<br>实际上， 如果买入的位置已经选中， 那么卖出的位置也确定了。 反过来也成立， 如果卖出的位置已经选择， 那么买入的位置也确定了。</li>\n</ul>\n<p>这里假设卖出的位置是i, 那么， 买入的位置就是在i前面的价格里面的最小价格。<br>那么，如果我们从左向右遍历， 每次保存目前已经遇到过的最小价格， 那么，prices[i]-min就是在i这个位置卖出的最大利润，这样就可以在一次遍历的过程中求解整体的最大利润。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public int maxProfit(int[] prices) &#123;</span><br><span class=\"line\">        if (prices.length == 0) return 0;</span><br><span class=\"line\">        int[] dp = new int[prices.length];</span><br><span class=\"line\">        int min = prices[0];</span><br><span class=\"line\">        </span><br><span class=\"line\">        for (int i = 1; i &lt; prices.length; i++) &#123;</span><br><span class=\"line\">            min = Math.min(prices[i], min);</span><br><span class=\"line\">            dp[i] = Math.max(dp[i-1], prices[i] - min);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return dp[prices.length - 1];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>可将dp[]换为max，降低空间复杂度</li>\n</ul>\n<h3 id=\"139-Word-Break-Medium\"><a href=\"#139-Word-Break-Medium\" class=\"headerlink\" title=\"139. Word Break (Medium) @\"></a>139. Word Break (Medium) <a href=\"https://leetcode.com/problems/word-break/\" target=\"_blank\" rel=\"noopener\">@</a></h3><p>Solution 1</p>\n<ol>\n<li>一个直观的思路是暴力解，首先从头开始，看看每个单词能不能成为成为字符串的开头， 如果匹配上了， 可以对后面的继续这个过程</li>\n<li>但是这个过程有一点重复， 其实每次计算都是计算的时候，问题是判断某一个子字符串是不是满足要求， 而某一个子字符串，在这个问题里面其实就是原始字符串的index， 那么， 这个子问题可能是重叠的。<br>比如， 针对”abcdef”和[“ab”, “cd”, “abcd”]<br>那么， 针对index=4 （从1开始计数， 可以有ab+cd 或者abcd两种方式， 那么，一个计算过了，后面的就不需要再计算了。</li>\n<li>这样，就可以应用动态规划的思想， 设置dp[i]表示在i位已经满足要求的， 然后从前向后遍历，看看每一位是否可以走到更多的位；</li>\n<li>动态规划的常用套路，就是看prefix， 因为计算prefix的时候，问题已经求解过了，固定了； 当然要从postfix去理解也可以， 但是那样通常会是解问题的自然思路，但是从动态规划bottom up的方式，往往不是那么好理解。<br>而当然，如果用记忆化递归的方式去理解，也是可以的。 但是同样要抽象出需要记忆的状态。 对于每个substring， 其实也是要用index来定义状态。 当然，完全用string做key也可能可以， 但是那样会浪费很多空间。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">wordBreak</span><span class=\"params\">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class=\"line\">        Set&lt;String&gt; wordSet = <span class=\"keyword\">new</span> HashSet&lt;&gt;(wordDict);</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span>[] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[s.length() + <span class=\"number\">1</span>];</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"comment\">//i--开始位置</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!dp[i]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"comment\">//j--结束位置</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i+<span class=\"number\">1</span>; j &lt;= s.length(); j++) &#123;</span><br><span class=\"line\">                String subStr = s.substring(i, j);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (wordSet.contains(subStr)) &#123;</span><br><span class=\"line\">                    dp[j] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[s.length()];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"140-Word-Break-II-Hard\"><a href=\"#140-Word-Break-II-Hard\" class=\"headerlink\" title=\"140. Word Break II (Hard) @\"></a>140. Word Break II (Hard) <a href=\"https://leetcode.com/problems/word-break-ii/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a <strong>non-empty</strong> string <em>s</em> and a dictionary <em>wordDict</em> containing a list of <strong>non-empty</strong> words, add spaces in <em>s</em> to construct a sentence where each word is a valid dictionary word. Return all such possible sentences.</p>\n<p><strong>Note:</strong></p>\n<ul>\n<li>The same word in the dictionary may be reused multiple times in the segmentation.</li>\n<li>You may assume the dictionary does not contain duplicate words.</li>\n</ul>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input:</span><br><span class=\"line\">&gt; s = &quot;catsanddog&quot;</span><br><span class=\"line\">&gt; wordDict = [&quot;cat&quot;, &quot;cats&quot;, &quot;and&quot;, &quot;sand&quot;, &quot;dog&quot;]</span><br><span class=\"line\">&gt; Output:</span><br><span class=\"line\">&gt; [</span><br><span class=\"line\">&gt;   &quot;cats and dog&quot;,</span><br><span class=\"line\">&gt;   &quot;cat sand dog&quot;</span><br><span class=\"line\">&gt; ]</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input:</span><br><span class=\"line\">&gt; s = &quot;pineapplepenapple&quot;</span><br><span class=\"line\">&gt; wordDict = [&quot;apple&quot;, &quot;pen&quot;, &quot;applepen&quot;, &quot;pine&quot;, &quot;pineapple&quot;]</span><br><span class=\"line\">&gt; Output:</span><br><span class=\"line\">&gt; [</span><br><span class=\"line\">&gt;   &quot;pine apple pen apple&quot;,</span><br><span class=\"line\">&gt;   &quot;pineapple pen apple&quot;,</span><br><span class=\"line\">&gt;   &quot;pine applepen apple&quot;</span><br><span class=\"line\">&gt; ]</span><br><span class=\"line\">&gt; Explanation: Note that you are allowed to reuse a dictionary word.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input:</span><br><span class=\"line\">&gt; s = &quot;catsandog&quot;</span><br><span class=\"line\">&gt; wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]</span><br><span class=\"line\">&gt; Output:</span><br><span class=\"line\">&gt; []</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution Recursion</p>\n<ul>\n<li>Python</li>\n<li>递归调用wordBerak()</li>\n<li><a href=\"https://www.youtube.com/watch?v=JqOIRBC0_9c\" target=\"_blank\" rel=\"noopener\">Youtube 题解</a></li>\n<li><img src=\":/ce516b8d2d2e441d9d46426147b9d38c\" alt=\"leetcode_140.png\"></li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wordBreak</span><span class=\"params\">(self, s: str, wordDict: List[str])</span> -&gt; List[str]:</span></span><br><span class=\"line\">        words = set(wordDict)</span><br><span class=\"line\">        memo = &#123;&#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wordBreak</span><span class=\"params\">(s)</span>:</span></span><br><span class=\"line\">            <span class=\"comment\"># already in memory, return directly</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> s <span class=\"keyword\">in</span> memo: </span><br><span class=\"line\">                <span class=\"keyword\">return</span> memo[s]</span><br><span class=\"line\">            <span class=\"comment\"># answer for s</span></span><br><span class=\"line\">            ans = []</span><br><span class=\"line\">            <span class=\"keyword\">if</span> s <span class=\"keyword\">in</span> words:</span><br><span class=\"line\">                ans.append(s)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(s)):</span><br><span class=\"line\">                <span class=\"comment\"># check whether right part is a word</span></span><br><span class=\"line\">                right = s[i:]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> right <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> words:</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span></span><br><span class=\"line\">                <span class=\"comment\"># append to the answer for left part</span></span><br><span class=\"line\">                ans += [w + <span class=\"string\">\" \"</span> + right <span class=\"keyword\">for</span> w <span class=\"keyword\">in</span> wordBreak(s[<span class=\"number\">0</span>:i])]</span><br><span class=\"line\">            memo[s] = ans</span><br><span class=\"line\">            <span class=\"keyword\">return</span> memo[s]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> wordBreak(s)</span><br></pre></td></tr></table></figure>\n<h3 id=\"152-Maximum-Product-Subarray-Medium\"><a href=\"#152-Maximum-Product-Subarray-Medium\" class=\"headerlink\" title=\"152. Maximum Product Subarray (Medium) @\"></a>152. Maximum Product Subarray (Medium) <a href=\"https://leetcode.com/problems/maximum-product-subarray/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given an integer array <code>nums</code>, find the contiguous subarray within an array (containing at least one number) which has the largest product.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [2,3,-2,4]</span><br><span class=\"line\">&gt; Output: 6</span><br><span class=\"line\">&gt; Explanation: [2,3] has the largest product 6.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [-2,0,-1]</span><br><span class=\"line\">&gt; Output: 0</span><br><span class=\"line\">&gt; Explanation: The result cannot be 2, because [-2,-1] is not a subarray.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution DP</p>\n<ul>\n<li>同时记录最大积和最小积，dp[i][0]表示以nums[i]结尾的子序列的最小积，dp[i][1]表示以nums[i]结尾的子序列的最大积。初始状态：<br>dp[0] [0] = nums[0];<br>dp[0] [1] = nums[0];</li>\n<li>由于可能存在负数，所以有三个数参与判断，状态转移方程：<br>dp[i] [0] = min( min(dp[i - 1] [0] <em> nums[i], dp[i - 1] [1] </em> nums[i]), nums[i])<br>dp[i] [1] = max( max(dp[i - 1] [0] <em> nums[i], dp[i - 1] [1] </em> nums[i]), nums[i])</li>\n<li>可以在用一个变量result记录结果，每次计算出最大积时就更新一下result，最后返回result就行，见下面我的代码1，时间复杂度是O(n)O(n)，空间复杂度是O(n)O(n)</li>\n<li>通过状态转移方程可以看出计算dp[i] []时只需要用到dp[i - 1] []，与dp[i - 2] []及前面的结果没有关系，因此空间复杂度可以进一步优化，只用两个变量localMin和localMax存储前一个位置的最大积和最小积</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxProduct</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums == <span class=\"keyword\">null</span> || nums.length == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> localMin = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> localMax = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> globalMax = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp = localMin;</span><br><span class=\"line\">            localMin = Math.min(Math.min(tmp * nums[i], localMax * nums[i]), nums[i]);</span><br><span class=\"line\">            localMax = Math.max(Math.max(localMax * nums[i], tmp * nums[i]), nums[i]);</span><br><span class=\"line\">            globalMax = Math.max(localMax, globalMax);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> globalMax;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"198-House-Robber-Easy\"><a href=\"#198-House-Robber-Easy\" class=\"headerlink\" title=\"198.House Robber (Easy) @\"></a>198.House Robber (Easy) <a href=\"https://leetcode.com/problems/house-robber/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and <strong>it will automatically contact the police if two adjacent houses were broken into on the same night</strong>.</p>\n<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight <strong>without alerting the police</strong>.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [1,2,3,1]</span><br><span class=\"line\">&gt; Output: 4</span><br><span class=\"line\">&gt; Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).</span><br><span class=\"line\">&gt;           Total amount you can rob = 1 + 3 = 4.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [2,7,9,3,1]</span><br><span class=\"line\">&gt; Output: 12</span><br><span class=\"line\">&gt; Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).</span><br><span class=\"line\">&gt;           Total amount you can rob = 2 + 9 + 1 = 12.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution 1 DP</p>\n<ul>\n<li>递推公式</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dp[0] = num[0] （当i=0时）</span><br><span class=\"line\">dp[1] = max(num[0], num[1]) （当i=1时）</span><br><span class=\"line\">dp[i] = max(num[i] + dp[i - 2], dp[i - 1])   （当i !=0 and i != 1时）</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">rob</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums == <span class=\"keyword\">null</span> || nums.length == <span class=\"number\">0</span>) </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[nums.length+<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span>)</span><br><span class=\"line\">                dp[i] = nums[i];</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i == <span class=\"number\">1</span>)</span><br><span class=\"line\">                dp[i] = Math.max(nums[i], nums[i-<span class=\"number\">1</span>]);</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                dp[i] = Math.max(dp[i-<span class=\"number\">2</span>]+nums[i], dp[i-<span class=\"number\">1</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[nums.length-<span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 2</p>\n<ul>\n<li>优化空间复杂度 O(1)</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">rob</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> rob = <span class=\"number\">0</span>, notrob = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp = rob;</span><br><span class=\"line\">        rob = notrob + nums[i];</span><br><span class=\"line\">        notrob = Math.max(temp, notrob);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Math.max(rob, notrob);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Binary-Search\"><a href=\"#Binary-Search\" class=\"headerlink\" title=\"Binary Search\"></a>Binary Search</h2><h3 id=\"69-Sqrt-x-Easy\"><a href=\"#69-Sqrt-x-Easy\" class=\"headerlink\" title=\"69. Sqrt(x) (Easy) @\"></a>69. Sqrt(x) (Easy) <a href=\"https://leetcode.com/problems/sqrtx/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Implement <code>int sqrt(int x)</code>.</p>\n<p>Compute and return the square root of <em>x</em>, where <em>x</em> is guaranteed to be a non-negative integer.</p>\n<p>Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: 4</span><br><span class=\"line\">&gt; Output: 2</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: 8</span><br><span class=\"line\">&gt; Output: 2</span><br><span class=\"line\">&gt; Explanation: The square root of 8 is 2.82842..., and since </span><br><span class=\"line\">&gt;           the decimal part is truncated, 2 is returned.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public int mySqrt(int x) &#123;</span><br><span class=\"line\">        if (x &lt; 2) return x;</span><br><span class=\"line\">        int left = 0;</span><br><span class=\"line\">        int right = x/2+1;</span><br><span class=\"line\">        long mid = 0;</span><br><span class=\"line\">        while (left &lt;= right) &#123;</span><br><span class=\"line\">            mid = (left + right) / 2;</span><br><span class=\"line\">            if (mid * mid == x) &#123;</span><br><span class=\"line\">                return (int)mid;</span><br><span class=\"line\">            &#125;else if (mid * mid &gt; x) &#123;</span><br><span class=\"line\">                right = (int)mid -1;</span><br><span class=\"line\">            &#125;else &#123;</span><br><span class=\"line\">                left = (int)mid + 1;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"162-Find-Peak-Element-Medium\"><a href=\"#162-Find-Peak-Element-Medium\" class=\"headerlink\" title=\"162. Find Peak Element (Medium) @\"></a>162. Find Peak Element (Medium) <a href=\"https://leetcode.com/problems/find-peak-element/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>A peak element is an element that is greater than its neighbors.</p>\n<p>Given an input array <code>nums</code>, where <code>nums[i] ≠ nums[i+1]</code>, find a peak element and return its index.</p>\n<p>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.</p>\n<p>You may imagine that <code>nums[-1] = nums[n] = -∞</code>.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: nums = [1,2,3,1]</span><br><span class=\"line\">&gt; Output: 2</span><br><span class=\"line\">&gt; Explanation: 3 is a peak element and your function should return the index number 2.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: nums = [1,2,1,3,5,6,4]</span><br><span class=\"line\">&gt; Output: 1 or 5 </span><br><span class=\"line\">&gt; Explanation: Your function can return either index number 1 where the peak element is 2, </span><br><span class=\"line\">&gt;           or index number 5 where the peak element is 6.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution</p>\n<ul>\n<li>因为nums[-1] = nums[n] = -∞, 所以当nums[mid] &lt; nums[mid+1] 时，mid右侧必定有peak，同理点那个nums[mid] &gt;= nums[mid+1]时，mid及其左侧必有peak<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public int findPeakElement(int[] nums) &#123;</span><br><span class=\"line\">        int n = nums.length;</span><br><span class=\"line\">        int left = 0, right = n-1;</span><br><span class=\"line\">        while (left &lt; right) &#123;</span><br><span class=\"line\">            int mid = (left + right) / 2;</span><br><span class=\"line\">            if (nums[mid] &lt; nums[mid+1]) &#123;</span><br><span class=\"line\">                //mid右侧必定有peak</span><br><span class=\"line\">                left = mid + 1;</span><br><span class=\"line\">            &#125;else &#123;</span><br><span class=\"line\">                //包括mid在内左侧必有peak</span><br><span class=\"line\">                right = mid;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return left;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"Greedy\"><a href=\"#Greedy\" class=\"headerlink\" title=\"Greedy\"></a>Greedy</h2><h3 id=\"55-Jump-Game-Medium\"><a href=\"#55-Jump-Game-Medium\" class=\"headerlink\" title=\"55. Jump Game (Medium) @\"></a>55. Jump Game (Medium) <a href=\"https://leetcode.com/problems/jump-game/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>\n<p>Each element in the array represents your maximum jump length at that position.</p>\n<p>Determine if you are able to reach the last index.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [2,3,1,1,4]</span><br><span class=\"line\">&gt; Output: true</span><br><span class=\"line\">&gt; Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [3,2,1,0,4]</span><br><span class=\"line\">&gt; Output: false</span><br><span class=\"line\">&gt; Explanation: You will always arrive at index 3 no matter what. Its maximum</span><br><span class=\"line\">&gt;           jump length is 0, which makes it impossible to reach the last index.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution 1 Greedy</p>\n<ul>\n<li>维护一个reach（最远可达距离），每次前进一步，如果i一直在reach范围内，则可达<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public boolean canJump(int[] nums) &#123;</span><br><span class=\"line\">        int reach = 0;</span><br><span class=\"line\">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            if (i &gt; reach)</span><br><span class=\"line\">                return false;</span><br><span class=\"line\">            reach = Math.max(reach, i + nums[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>Solution 2 Zero Point</p>\n<ul>\n<li>若无0点则一定可达任一点</li>\n<li>故只需考虑0点，判断可否跳过此0点即此0点向前数第k个位置的元素大于k即可跳过<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public boolean canJump(int[] nums) &#123;</span><br><span class=\"line\">        int i = nums.length - 2; //0点</span><br><span class=\"line\">        while(i &gt;= 0) &#123;</span><br><span class=\"line\">            if (nums[i] == 0) &#123;</span><br><span class=\"line\">                int j = i - 1;//向前找可以跳过0点的位置</span><br><span class=\"line\">                while (j &gt;= 0) &#123;</span><br><span class=\"line\">                    if (j + nums[j] &gt; i) &#123;</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    j--;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if (j == -1)</span><br><span class=\"line\">                    return false;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            i--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"122-Best-Time-to-Buy-and-Sell-Stock-II-Easy\"><a href=\"#122-Best-Time-to-Buy-and-Sell-Stock-II-Easy\" class=\"headerlink\" title=\"122. Best Time to Buy and Sell Stock II (Easy) @\"></a>122. Best Time to Buy and Sell Stock II (Easy) <a href=\"https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p>\n<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).</p>\n<p><strong>Note:</strong> You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [7,1,5,3,6,4]</span><br><span class=\"line\">&gt; Output: 7</span><br><span class=\"line\">&gt; Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.</span><br><span class=\"line\">&gt;           Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [1,2,3,4,5]</span><br><span class=\"line\">&gt; Output: 4</span><br><span class=\"line\">&gt; Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.</span><br><span class=\"line\">&gt;           Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are</span><br><span class=\"line\">&gt;           engaging multiple transactions at the same time. You must sell before buying again.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [7,6,4,3,1]</span><br><span class=\"line\">&gt; Output: 0</span><br><span class=\"line\">&gt; Explanation: In this case, no transaction is done, i.e. max profit = 0.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution Greedy</p>\n<ul>\n<li>累计所有前低后高的差值<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public int maxProfit(int[] prices) &#123;</span><br><span class=\"line\">        int profit = 0;</span><br><span class=\"line\">        for (int i = 1; i &lt; prices.length; i++) &#123;</span><br><span class=\"line\">            if (prices[i] - prices[i-1] &gt; 0)</span><br><span class=\"line\">                profit += prices[i] - prices[i-1];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return profit;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"134-Gas-Station-Medium\"><a href=\"#134-Gas-Station-Medium\" class=\"headerlink\" title=\"134. Gas Station (Medium) @\"></a>134. Gas Station (Medium) <a href=\"https://leetcode.com/problems/gas-station/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>There are <em>N</em> gas stations along a circular route, where the amount of gas at station <em>i</em> is <code>gas[i]</code>.</p>\n<p>You have a car with an unlimited gas tank and it costs <code>cost[i]</code> of gas to travel from station <em>i</em> to its next station (<em>i</em>+1). You begin the journey with an empty tank at one of the gas stations.</p>\n<p>Return the starting gas station’s index if you can travel around the circuit once in the clockwise direction, otherwise return -1.</p>\n<p><strong>Note:</strong></p>\n<ul>\n<li>If there exists a solution, it is guaranteed to be unique.</li>\n<li>Both input arrays are non-empty and have the same length.</li>\n<li>Each element in the input arrays is a non-negative integer.</li>\n</ul>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: </span><br><span class=\"line\">&gt; gas  = [1,2,3,4,5]</span><br><span class=\"line\">&gt; cost = [3,4,5,1,2]</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; Output: 3</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; Explanation:</span><br><span class=\"line\">&gt; Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4</span><br><span class=\"line\">&gt; Travel to station 4. Your tank = 4 - 1 + 5 = 8</span><br><span class=\"line\">&gt; Travel to station 0. Your tank = 8 - 2 + 1 = 7</span><br><span class=\"line\">&gt; Travel to station 1. Your tank = 7 - 3 + 2 = 6</span><br><span class=\"line\">&gt; Travel to station 2. Your tank = 6 - 4 + 3 = 5</span><br><span class=\"line\">&gt; Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.</span><br><span class=\"line\">&gt; Therefore, return 3 as the starting index.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: </span><br><span class=\"line\">&gt; gas  = [2,3,4]</span><br><span class=\"line\">&gt; cost = [3,4,3]</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; Output: -1</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; Explanation:</span><br><span class=\"line\">&gt; You can&apos;t start at station 0 or 1, as there is not enough gas to travel to the next station.</span><br><span class=\"line\">&gt; Let&apos;s start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4</span><br><span class=\"line\">&gt; Travel to station 0. Your tank = 4 - 3 + 2 = 3</span><br><span class=\"line\">&gt; Travel to station 1. Your tank = 3 - 3 + 3 = 3</span><br><span class=\"line\">&gt; You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.</span><br><span class=\"line\">&gt; Therefore, you can&apos;t travel around the circuit once no matter where you start.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution Greedy</p>\n<ul>\n<li>sum(gas) &gt;= sum(cost) =&gt; 有解</li>\n<li>只要找到一个起点i，从这个点出发的所有gas的和总比cost和打即可<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public int canCompleteCircuit(int[] gas, int[] cost) &#123;</span><br><span class=\"line\">        int sum = 0, subsum = 0, begin = 0;</span><br><span class=\"line\">        for (int i = 0; i &lt; gas.length; i++) &#123;</span><br><span class=\"line\">            sum += gas[i] - cost[i];</span><br><span class=\"line\">            subsum += gas[i] - cost[i];</span><br><span class=\"line\">            if (subsum &lt; 0) &#123;</span><br><span class=\"line\">                subsum = 0;</span><br><span class=\"line\">                begin = i + 1;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (sum &lt; 0) return -1;</span><br><span class=\"line\">        return begin;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"Tree\"><a href=\"#Tree\" class=\"headerlink\" title=\"Tree\"></a>Tree</h2><h3 id=\"94-Binary-Tree-Inorder-Traversal-Medium\"><a href=\"#94-Binary-Tree-Inorder-Traversal-Medium\" class=\"headerlink\" title=\"94. Binary Tree Inorder Traversal (Medium)  @\"></a>94. Binary Tree Inorder Traversal (Medium)  <a href=\"https://leetcode.com/problems/binary-tree-inorder-traversal/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a binary tree, return the <em>inorder</em> traversal of its nodes’ values.</p>\n<p><strong>Example:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [1,null,2,3]</span><br><span class=\"line\">&gt; 1</span><br><span class=\"line\">&gt;  \\</span><br><span class=\"line\">&gt;   2</span><br><span class=\"line\">&gt;  /</span><br><span class=\"line\">&gt; 3</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; Output: [1,3,2]</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</p>\n</blockquote>\n<p>Solution 1 Recursion</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">inorderTraversal</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        helper(root, res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">helper</span><span class=\"params\">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root.left != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                helper(root.left, res);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res.add(root.val);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root.right != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                helper(root.right, res);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 2 Stack</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">inorderTraversal</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        Stack&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">        TreeNode cur = root;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur != <span class=\"keyword\">null</span> || !stack.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (cur != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                stack.push(cur);</span><br><span class=\"line\">                cur = cur.left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cur = stack.pop();</span><br><span class=\"line\">            res.add(cur.val);</span><br><span class=\"line\">            cur = cur.right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Backtracking\"><a href=\"#Backtracking\" class=\"headerlink\" title=\"Backtracking\"></a>Backtracking</h2><h3 id=\"78-Subsets-Medium\"><a href=\"#78-Subsets-Medium\" class=\"headerlink\" title=\"78. Subsets (Medium) @\"></a>78. Subsets (Medium) <a href=\"https://leetcode.com/problems/subsets/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a set of <strong>distinct</strong> integers, <em>nums</em>, return all possible subsets (the power set).</p>\n<p><strong>Note:</strong> The solution set must not contain duplicate subsets.</p>\n<p><strong>Example:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: nums = [1,2,3]</span><br><span class=\"line\">&gt; Output:</span><br><span class=\"line\">&gt; [</span><br><span class=\"line\">&gt; [3],</span><br><span class=\"line\">&gt; [1],</span><br><span class=\"line\">&gt; [2],</span><br><span class=\"line\">&gt; [1,2,3],</span><br><span class=\"line\">&gt; [1,3],</span><br><span class=\"line\">&gt; [2,3],</span><br><span class=\"line\">&gt; [1,2],</span><br><span class=\"line\">&gt; []</span><br><span class=\"line\">&gt; ]</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution 1 Recursion<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class=\"keyword\">int</span>[] nums) &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class=\"line\">        List&lt;Integer&gt; cur = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</span><br><span class=\"line\">        backtrack(res, cur, nums, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">backtrack</span><span class=\"params\">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; cur, <span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">        res.add(<span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;(cur));</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = j; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            cur.add(nums[i]);<span class=\"comment\">//add nums[i]</span></span><br><span class=\"line\">            backtrack(res, cur, nums, i+<span class=\"number\">1</span>);<span class=\"comment\">// Recursion</span></span><br><span class=\"line\">            cur.remove(cur.size()-<span class=\"number\">1</span>);<span class=\"comment\">//remove nums[i]</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Solution 2 Iteration<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class=\"keyword\">int</span>[] nums) &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class=\"line\">        res.add(<span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;());</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> num : nums) &#123; <span class=\"comment\">//pick up each element from nums</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> size = res.size();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//pick up each element in current res</span></span><br><span class=\"line\">                List&lt;Integer&gt; temp = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;(res.get(i));</span><br><span class=\"line\">                temp.add(num);<span class=\"comment\">//put num into temp</span></span><br><span class=\"line\">                res.add(temp);<span class=\"comment\">//add temp into res</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"79-Word-Search-Medium\"><a href=\"#79-Word-Search-Medium\" class=\"headerlink\" title=\"79. Word Search (Medium) @\"></a>79. Word Search (Medium) <a href=\"https://leetcode.com/problems/word-search/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a 2D board and a word, find if the word exists in the grid.</p>\n<p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>\n<p><strong>Example:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; board =</span><br><span class=\"line\">&gt; [</span><br><span class=\"line\">&gt; [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;],</span><br><span class=\"line\">&gt; [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;],</span><br><span class=\"line\">&gt; [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]</span><br><span class=\"line\">&gt; ]</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; Given word = &quot;ABCCED&quot;, return true.</span><br><span class=\"line\">&gt; Given word = &quot;SEE&quot;, return true.</span><br><span class=\"line\">&gt; Given word = &quot;ABCB&quot;, return false.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution dfs + backtrack<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//direction: right, down, left, up</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] drow = &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, -<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] dcol = &#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>, -<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">exist</span><span class=\"params\">(<span class=\"keyword\">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span>[][] isVisited = <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[board.length][board[<span class=\"number\">0</span>].length];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; board.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; board[<span class=\"number\">0</span>].length; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (isThisWay(board, word, i, j, <span class=\"number\">0</span>, isVisited))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isThisWay</span><span class=\"params\">(<span class=\"keyword\">char</span>[][] board, String word, <span class=\"keyword\">int</span> row, <span class=\"keyword\">int</span> col, <span class=\"keyword\">int</span> index, <span class=\"keyword\">boolean</span>[][] isVisited)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (row &lt; <span class=\"number\">0</span> || row &gt;= board.length || col &lt; <span class=\"number\">0</span> || col &gt;= board[<span class=\"number\">0</span>].length || isVisited[row][col] || board[row][col] != word.charAt(index))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (++index == word.length())</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>; <span class=\"comment\">// complete matching</span></span><br><span class=\"line\">        isVisited[row][col] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isThisWay(board, word, row + drow[i], col + dcol[i], index, isVisited))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        isVisited[row][col] = <span class=\"keyword\">false</span>;<span class=\"comment\">//backtrack if false</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"131-Palindrome-Partitioning-Medium\"><a href=\"#131-Palindrome-Partitioning-Medium\" class=\"headerlink\" title=\"131. Palindrome Partitioning (Medium) @\"></a>131. Palindrome Partitioning (Medium) <a href=\"https://leetcode.com/problems/palindrome-partitioning/\" target=\"_blank\" rel=\"noopener\">@</a></h3><p>Solution DFS + backtracking</p>\n<ul>\n<li>递归寻找子问题，如果子串回文，则加入res<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class=\"line\">        List&lt;List&lt;String&gt;&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;List&lt;String&gt;&gt;();</span><br><span class=\"line\">        List&lt;String&gt; cur = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.length() == <span class=\"number\">0</span> || s == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        </span><br><span class=\"line\">        backtrack(s, <span class=\"number\">0</span>, cur, res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">backtrack</span><span class=\"params\">(String s, <span class=\"keyword\">int</span> start, List&lt;String&gt; cur, List&lt;List&lt;String&gt;&gt; res)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//recursion complete condition</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (start == s.length()) &#123;</span><br><span class=\"line\">            res.add(<span class=\"keyword\">new</span> ArrayList&lt;String&gt;(cur));</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = start; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">            String str = s.substring(start, i + <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isPalindrome(str)) &#123;</span><br><span class=\"line\">                cur.add(str);</span><br><span class=\"line\">                backtrack(s, i+<span class=\"number\">1</span>, cur, res);</span><br><span class=\"line\">                cur.remove(cur.size()-<span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(String str)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>, right = str.length() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (str.charAt(left) != str.charAt(right)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            left++;</span><br><span class=\"line\">            right--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"212-Word-Search-II-Hard\"><a href=\"#212-Word-Search-II-Hard\" class=\"headerlink\" title=\"212. Word Search II (Hard) @\"></a>212. Word Search II (Hard) <a href=\"https://leetcode.com/problems/word-search-ii/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a 2D board and a list of words from the dictionary, find all words in the board.</p>\n<p>Each word must be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.</p>\n<p><strong>Example:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: </span><br><span class=\"line\">&gt; board = [</span><br><span class=\"line\">&gt; [&apos;o&apos;,&apos;a&apos;,&apos;a&apos;,&apos;n&apos;],</span><br><span class=\"line\">&gt; [&apos;e&apos;,&apos;t&apos;,&apos;a&apos;,&apos;e&apos;],</span><br><span class=\"line\">&gt; [&apos;i&apos;,&apos;h&apos;,&apos;k&apos;,&apos;r&apos;],</span><br><span class=\"line\">&gt; [&apos;i&apos;,&apos;f&apos;,&apos;l&apos;,&apos;v&apos;]</span><br><span class=\"line\">&gt; ]</span><br><span class=\"line\">&gt; words = [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;]</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; Output: [&quot;eat&quot;,&quot;oath&quot;]</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Note:</strong></p>\n<ol>\n<li>All inputs are consist of lowercase letters <code>a-z</code>.</li>\n<li>The values of <code>words</code> are distinct.</li>\n</ol>\n</blockquote>\n<p><a href=\"https://www.cnblogs.com/Dylan-Java-NYC/p/4944555.html\" target=\"_blank\" rel=\"noopener\">Solution</a> Tire + DFS</p>\n<blockquote>\n<p><a href=\"http://www.cnblogs.com/Dylan-Java-NYC/p/4944270.html\" target=\"_blank\" rel=\"noopener\">Word Search</a>的进阶版题目，同时可以利用<a href=\"http://www.cnblogs.com/Dylan-Java-NYC/p/4888830.html\" target=\"_blank\" rel=\"noopener\">Implement Trie (Prefix Tree)</a>.</p>\n<p>生成Trie树，把所有的词都insert进去。</p>\n<p>然后从board上的每一个char开始dfs查找。</p>\n<p>终止条件有两个， 一个 i 和 j 出界，或者board[i][j]已经用过了. 另一个是把board[i][j]加到当前item后，若没有以更新过item为prefix的时候就可以返回了.</p>\n<p>search 更新过的item, 若是有就加到res中, <strong>并且继续，这里不能return,</strong> 因为有可能有 “aabc” “aabcb”两个词同时存在的情况，只检查了”aabc”就return会漏掉”aabcb”.</p>\n<p>标记当前used为true, 然后board四个方向都做recursion. used再改回来.</p>\n<p>Note: 如果board 是[a a], words 只有一个[a], 此时小心重复加了，所以要用HashSet生成res, 最后再用res生成的List返回。</p>\n<p>m = board.length, n = board[0].length, k = words.length, l 是 word的平均长度.</p>\n<p>Time Complexity: O(k<em>l + m</em>n<em>l</em>4^l). k<em>l是简历Trie用时间. m</em>n是外部循环, l是search Trie时间, 4^l是recursion + backtracking的时间.</p>\n<p>Space: O(k<em>l + l). k</em>l是Trie数的大小. 用了l层stack.</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;String&gt; <span class=\"title\">findWords</span><span class=\"params\">(<span class=\"keyword\">char</span>[][] board, String[] words)</span> </span>&#123;</span><br><span class=\"line\">        HashSet&lt;String&gt; res = <span class=\"keyword\">new</span> HashSet&lt;String&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(words == <span class=\"keyword\">null</span> || words.length == <span class=\"number\">0</span> || board == <span class=\"keyword\">null</span> || board.length == <span class=\"number\">0</span> || board[<span class=\"number\">0</span>].length == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList(res);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Trie trie = <span class=\"keyword\">new</span> Trie();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i&lt;words.length; i++)&#123;</span><br><span class=\"line\">            trie.insert(words[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> [][] used = <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[board.length][board[<span class=\"number\">0</span>].length];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i&lt;board.length; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j&lt;board[<span class=\"number\">0</span>].length; j++)&#123;</span><br><span class=\"line\">                findHelper(board,trie,used,<span class=\"string\">\"\"</span>,i,j,res);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList(res);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">findHelper</span><span class=\"params\">(<span class=\"keyword\">char</span>[][] board, Trie trie, <span class=\"keyword\">boolean</span> [][] used, String item, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j, HashSet&lt;String&gt; res)</span></span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i&lt;<span class=\"number\">0</span> || j&lt;<span class=\"number\">0</span> || i&gt;= board.length || j&gt;=board[<span class=\"number\">0</span>].length || used[i][j])&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        item = item+board[i][j];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!trie.startsWith(item))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(trie.search(item))&#123;</span><br><span class=\"line\">            res.add(item);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        used[i][j] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        findHelper(board,trie,used,item,i+<span class=\"number\">1</span>,j,res);</span><br><span class=\"line\">        findHelper(board,trie,used,item,i-<span class=\"number\">1</span>,j,res);</span><br><span class=\"line\">        findHelper(board,trie,used,item,i,j+<span class=\"number\">1</span>,res);</span><br><span class=\"line\">        findHelper(board,trie,used,item,i,j-<span class=\"number\">1</span>,res);</span><br><span class=\"line\">        used[i][j] = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TrieNode</span></span>&#123;</span><br><span class=\"line\">    String val = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">    TrieNode [] nexts;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TrieNode</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        nexts = <span class=\"keyword\">new</span> TrieNode[<span class=\"number\">26</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Trie</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> TrieNode root;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Trie</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        root = <span class=\"keyword\">new</span> TrieNode();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(String word)</span></span>&#123;</span><br><span class=\"line\">        TrieNode p = root;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">char</span> c : word.toCharArray())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(p.nexts[c-<span class=\"string\">'a'</span>] == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                p.nexts[c-<span class=\"string\">'a'</span>] = <span class=\"keyword\">new</span> TrieNode();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            p = p.nexts[c-<span class=\"string\">'a'</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        p.val = word;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">search</span><span class=\"params\">(String word)</span></span>&#123;</span><br><span class=\"line\">        TrieNode p = root;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">char</span> c : word.toCharArray())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(p.nexts[c-<span class=\"string\">'a'</span>] == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            p = p.nexts[c-<span class=\"string\">'a'</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p.val.equals(word);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">startsWith</span><span class=\"params\">(String prefix)</span></span>&#123;</span><br><span class=\"line\">        TrieNode p = root;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">char</span> c : prefix.toCharArray())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(p.nexts[c-<span class=\"string\">'a'</span>] == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            p = p.nexts[c-<span class=\"string\">'a'</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h2><h3 id=\"12-Integer-to-Roman-Easy\"><a href=\"#12-Integer-to-Roman-Easy\" class=\"headerlink\" title=\"12. Integer to Roman (Easy) @\"></a>12. Integer to Roman (Easy) <a href=\"https://leetcode.com/problems/integer-to-roman/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Roman numerals are represented by seven different symbols: <code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Symbol       Value</span><br><span class=\"line\">&gt; I             1</span><br><span class=\"line\">&gt; V             5</span><br><span class=\"line\">&gt; X             10</span><br><span class=\"line\">&gt; L             50</span><br><span class=\"line\">&gt; C             100</span><br><span class=\"line\">&gt; D             500</span><br><span class=\"line\">&gt; M             1000</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p>For example, two is written as <code>II</code> in Roman numeral, just two one’s added together. Twelve is written as, <code>XII</code>, which is simply <code>X</code> + <code>II</code>. The number twenty seven is written as <code>XXVII</code>, which is <code>XX</code> + <code>V</code> + <code>II</code>.</p>\n<p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not <code>IIII</code>. Instead, the number four is written as <code>IV</code>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as <code>IX</code>. There are six instances where subtraction is used:</p>\n<ul>\n<li><code>I</code> can be placed before <code>V</code> (5) and <code>X</code> (10) to make 4 and 9. </li>\n<li><code>X</code> can be placed before <code>L</code> (50) and <code>C</code> (100) to make 40 and 90. </li>\n<li><code>C</code> can be placed before <code>D</code> (500) and <code>M</code> (1000) to make 400 and 900.</li>\n</ul>\n<p>Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: 3</span><br><span class=\"line\">&gt; Output: &quot;III&quot;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: 4</span><br><span class=\"line\">&gt; Output: &quot;IV&quot;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: 9</span><br><span class=\"line\">&gt; Output: &quot;IX&quot;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 4:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: 58</span><br><span class=\"line\">&gt; Output: &quot;LVIII&quot;</span><br><span class=\"line\">&gt; Explanation: L = 50, V = 5, III = 3.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution</p>\n<ul>\n<li>计算每个位的值，并用对应字符串表示</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">intToRoman</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">        String[] M = &#123;<span class=\"string\">\"\"</span>, <span class=\"string\">\"M\"</span>, <span class=\"string\">\"MM\"</span>, <span class=\"string\">\"MMM\"</span>&#125;;</span><br><span class=\"line\">        String[] C = &#123;<span class=\"string\">\"\"</span>, <span class=\"string\">\"C\"</span>, <span class=\"string\">\"CC\"</span>, <span class=\"string\">\"CCC\"</span>, <span class=\"string\">\"CD\"</span>, <span class=\"string\">\"D\"</span>, <span class=\"string\">\"DC\"</span>, <span class=\"string\">\"DCC\"</span>, <span class=\"string\">\"DCCC\"</span>, <span class=\"string\">\"CM\"</span>&#125;;</span><br><span class=\"line\">        String[] X = &#123;<span class=\"string\">\"\"</span>, <span class=\"string\">\"X\"</span>, <span class=\"string\">\"XX\"</span>, <span class=\"string\">\"XXX\"</span>, <span class=\"string\">\"XL\"</span>, <span class=\"string\">\"L\"</span>, <span class=\"string\">\"LX\"</span>, <span class=\"string\">\"LXX\"</span>, <span class=\"string\">\"LXXX\"</span>, <span class=\"string\">\"XC\"</span>&#125;;</span><br><span class=\"line\">        String[] I = &#123;<span class=\"string\">\"\"</span>, <span class=\"string\">\"I\"</span>, <span class=\"string\">\"II\"</span>, <span class=\"string\">\"III\"</span>, <span class=\"string\">\"IV\"</span>, <span class=\"string\">\"V\"</span>, <span class=\"string\">\"VI\"</span>, <span class=\"string\">\"VII\"</span>, <span class=\"string\">\"VIII\"</span>, <span class=\"string\">\"IX\"</span>&#125;;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> M[(num/<span class=\"number\">1000</span>)]+C[(num%<span class=\"number\">1000</span>)/<span class=\"number\">100</span>]+X[(num%<span class=\"number\">100</span>)/<span class=\"number\">10</span>]+I[(num%<span class=\"number\">10</span>)];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"13-Roman-to-Integer-Easy\"><a href=\"#13-Roman-to-Integer-Easy\" class=\"headerlink\" title=\"13. Roman to Integer (Easy) @\"></a>13. Roman to Integer (Easy) <a href=\"https://leetcode.com/problems/roman-to-integer/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Roman numerals are represented by seven different symbols: <code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Symbol       Value</span><br><span class=\"line\">&gt; I             1</span><br><span class=\"line\">&gt; V             5</span><br><span class=\"line\">&gt; X             10</span><br><span class=\"line\">&gt; L             50</span><br><span class=\"line\">&gt; C             100</span><br><span class=\"line\">&gt; D             500</span><br><span class=\"line\">&gt; M             1000</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p>For example, two is written as <code>II</code> in Roman numeral, just two one’s added together. Twelve is written as, <code>XII</code>, which is simply <code>X</code> + <code>II</code>. The number twenty seven is written as <code>XXVII</code>, which is <code>XX</code> + <code>V</code> + <code>II</code>.</p>\n<p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not <code>IIII</code>. Instead, the number four is written as <code>IV</code>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as <code>IX</code>. There are six instances where subtraction is used:</p>\n<ul>\n<li><code>I</code> can be placed before <code>V</code> (5) and <code>X</code> (10) to make 4 and 9. </li>\n<li><code>X</code> can be placed before <code>L</code> (50) and <code>C</code> (100) to make 40 and 90. </li>\n<li><code>C</code> can be placed before <code>D</code> (500) and <code>M</code> (1000) to make 400 and 900.</li>\n</ul>\n<p>Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: &quot;III&quot;</span><br><span class=\"line\">&gt; Output: 3</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: &quot;IV&quot;</span><br><span class=\"line\">&gt; Output: 4</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: &quot;IX&quot;</span><br><span class=\"line\">&gt; Output: 9</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 4:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: &quot;LVIII&quot;</span><br><span class=\"line\">&gt; Output: 58</span><br><span class=\"line\">&gt; Explanation: L = 50, V= 5, III = 3.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 5:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: &quot;MCMXCIV&quot;</span><br><span class=\"line\">&gt; Output: 1994</span><br><span class=\"line\">&gt; Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution 1</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">romanToInt</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        HashMap&lt;Character, Integer&gt; hm = <span class=\"keyword\">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class=\"line\">        hm.put(<span class=\"string\">'I'</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        hm.put(<span class=\"string\">'V'</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">        hm.put(<span class=\"string\">'X'</span>, <span class=\"number\">10</span>);</span><br><span class=\"line\">        hm.put(<span class=\"string\">'L'</span>, <span class=\"number\">50</span>);</span><br><span class=\"line\">        hm.put(<span class=\"string\">'C'</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">        hm.put(<span class=\"string\">'D'</span>, <span class=\"number\">500</span>);</span><br><span class=\"line\">        hm.put(<span class=\"string\">'M'</span>, <span class=\"number\">1000</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxDigit = <span class=\"number\">0</span>, val = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = s.length() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> cur = hm.get(s.charAt(i));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cur &gt;= maxDigit) &#123;</span><br><span class=\"line\">                val += cur;</span><br><span class=\"line\">                maxDigit = cur;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                val -= cur;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 2</p>\n<ul>\n<li>仅有 I X C 可能成为前缀，所以遇到需要考虑是否更新前缀</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">romanToInt</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> x = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> prev = <span class=\"string\">' '</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// if (prev == ' ') prev = s.charAt(i);</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">switch</span> (s.charAt(i)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"string\">'M'</span>:</span><br><span class=\"line\">                    x += prev == <span class=\"string\">'C'</span> ? <span class=\"number\">900</span> : <span class=\"number\">1000</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"string\">'D'</span>:</span><br><span class=\"line\">                    x += prev == <span class=\"string\">'C'</span> ? <span class=\"number\">400</span> : <span class=\"number\">500</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"string\">'C'</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (i &lt; s.length() - <span class=\"number\">1</span> &amp;&amp; (s.charAt(i + <span class=\"number\">1</span>) == <span class=\"string\">'D'</span> || s.charAt(i + <span class=\"number\">1</span>) == <span class=\"string\">'M'</span>)) &#123;</span><br><span class=\"line\">                        prev = <span class=\"string\">'C'</span>;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        x += prev == <span class=\"string\">'X'</span> ? <span class=\"number\">90</span> : <span class=\"number\">100</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"string\">'L'</span>:</span><br><span class=\"line\">                    x += prev == <span class=\"string\">'X'</span> ? <span class=\"number\">40</span> : <span class=\"number\">50</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"string\">'X'</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (i &lt; s.length() - <span class=\"number\">1</span> &amp;&amp; (s.charAt(i + <span class=\"number\">1</span>) == <span class=\"string\">'L'</span> || s.charAt(i + <span class=\"number\">1</span>) == <span class=\"string\">'C'</span>)) &#123;</span><br><span class=\"line\">                        prev = <span class=\"string\">'X'</span>;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        x += prev == <span class=\"string\">'I'</span> ? <span class=\"number\">9</span> : <span class=\"number\">10</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"string\">'V'</span>:</span><br><span class=\"line\">                    x += prev == <span class=\"string\">'I'</span> ? <span class=\"number\">4</span> : <span class=\"number\">5</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"string\">'I'</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (i &lt; s.length() - <span class=\"number\">1</span> &amp;&amp; (s.charAt(i + <span class=\"number\">1</span>) == <span class=\"string\">'V'</span> || s.charAt(i + <span class=\"number\">1</span>) == <span class=\"string\">'X'</span>)) &#123;</span><br><span class=\"line\">                        prev = <span class=\"string\">'I'</span>;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        x += <span class=\"number\">1</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"14-Longest-Common-Prefix-Easy\"><a href=\"#14-Longest-Common-Prefix-Easy\" class=\"headerlink\" title=\"14. Longest Common Prefix (Easy) @\"></a>14. Longest Common Prefix (Easy) <a href=\"https://leetcode.com/problems/longest-common-prefix/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Write a function to find the longest common prefix string amongst an array of strings.</p>\n<p>If there is no common prefix, return an empty string <code>&quot;&quot;</code>.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class=\"line\">&gt; Output: &quot;fl&quot;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class=\"line\">&gt; Output: &quot;&quot;</span><br><span class=\"line\">&gt; Explanation: There is no common prefix among the input strings.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Note:</strong></p>\n<p>All given inputs are in lowercase letters <code>a-z</code>.</p>\n</blockquote>\n<p>Solution 1 Recursion + Divide and Conquer</p>\n<ul>\n<li>二分所有串，一半一半考虑找出commonPrefix</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">longestCommonPrefix</span><span class=\"params\">(String[] strs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (strs.length == <span class=\"number\">0</span> || strs == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>; <span class=\"comment\">//特殊情况</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> longestCommonPrefix(strs, <span class=\"number\">0</span>, strs.length-<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">longestCommonPrefix</span><span class=\"params\">(String[] strs, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l == r) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> strs[l];</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> mid = (l+r)/<span class=\"number\">2</span>;</span><br><span class=\"line\">            String lcpLeft = longestCommonPrefix(strs, l, mid);<span class=\"comment\">//左区间</span></span><br><span class=\"line\">            String lcpRight = longestCommonPrefix(strs, mid+<span class=\"number\">1</span>, r);<span class=\"comment\">//右区间</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> commonPrefix(lcpLeft, lcpRight);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">commonPrefix</span><span class=\"params\">(String ls, String rs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> min = Math.min(ls.length(), rs.length());</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i&lt;min; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ls.charAt(i) != rs.charAt(i)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ls.substring(<span class=\"number\">0</span>,i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ls.substring(<span class=\"number\">0</span>,min);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 2 Divide and Conquer</p>\n<ul>\n<li>假设commonPrefix长度，二分最短串长度</li>\n<li>如果存在，则l和r最后汇聚在commonPrefix的尾部</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">longestCommonPrefix</span><span class=\"params\">(String[] strs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (strs.length == <span class=\"number\">0</span> || strs == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> minLen = Integer.MAX_VALUE;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class=\"line\">            minLen = Math.min(strs[i].length(), minLen);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = <span class=\"number\">0</span>, r = minLen;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l &lt;= r) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> mid = (l + r) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isCommonPrefix(strs, mid)) &#123;</span><br><span class=\"line\">                l = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                r= mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> strs[<span class=\"number\">0</span>].substring(<span class=\"number\">0</span>, (l+r)/<span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isCommonPrefix</span><span class=\"params\">(String[] strs, <span class=\"keyword\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\">        String s = strs[<span class=\"number\">0</span>].substring(<span class=\"number\">0</span>, len);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; strs.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!strs[i].startsWith(s)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"28-Implement-strStr-Easy\"><a href=\"#28-Implement-strStr-Easy\" class=\"headerlink\" title=\"28. Implement strStr()  (Easy)  @\"></a>28. Implement strStr()  (Easy)  <a href=\"https://leetcode.com/problems/implement-strstr/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Implement <a href=\"http://www.cplusplus.com/reference/cstring/strstr/\" target=\"_blank\" rel=\"noopener\">strStr()</a>.</p>\n<p>Return the index of the first occurrence of needle in haystack, or <strong>-1</strong> if needle is not part of haystack.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: haystack = &quot;hello&quot;, needle = &quot;ll&quot;</span><br><span class=\"line\">&gt; Output: 2</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;</span><br><span class=\"line\">&gt; Output: -1</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution 1 Iteration</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">strStr</span><span class=\"params\">(String haystack, String needle)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (needle.length() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; haystack.length() - needle.length() + <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (haystack.charAt(i) == needle.charAt(<span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (j &lt; needle.length() &amp;&amp; haystack.charAt(i+j) == needle.charAt(j)) &#123;</span><br><span class=\"line\">                    j++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j == needle.length())</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 2 KMP (Knuth–Morris–Pratt <a href=\"https://en.wikipedia.org/wiki/String-searching_algorithm\" target=\"_blank\" rel=\"noopener\">string-searching algorithm</a>)</p>\n<ul>\n<li>核心是PMT(Partial Match Table)数组：前缀B – A=BS (S为非空字符串)；PMT 中的值是字符串的前缀集合与后缀集合的交集中最长元素的长度</li>\n<li><img src=\":/67dad347bcda4fb7998271ac90779b10\" alt=\"IMG_0923.JPG\"></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">strStr</span><span class=\"params\">(String haystack, String needle)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (needle.length() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = -<span class=\"number\">1</span>, N = needle.length(), M = haystack.length();</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] next = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[N];</span><br><span class=\"line\">        next[<span class=\"number\">0</span>] = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; N-<span class=\"number\">1</span>) &#123;<span class=\"comment\">// generate next array</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (j == -<span class=\"number\">1</span> || needle.charAt(i) == needle.charAt(j)) &#123;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">                next[i] = j;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                j = next[j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        i = <span class=\"number\">0</span>; j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; M &amp;&amp; j &lt; N) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (j == -<span class=\"number\">1</span> || haystack.charAt(i) == needle.charAt(j)) &#123;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                j = next[j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (j == N) </span><br><span class=\"line\">            <span class=\"keyword\">return</span> i-j;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 3 HashMap</p>\n<ul>\n<li>直接containsKey匹配子串</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">strStr</span><span class=\"params\">(String haystack, String needle)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (needle.length() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (needle.length() &gt; haystack.length()) <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        HashMap&lt;String, Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        map.put(haystack, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"comment\">//put each needle-len substring of haystack into the hashmap</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= haystack.length() - needle.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (map.containsKey(needle)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> map.get(needle);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            map.put(haystack.substring(i, i+needle.length()), i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> map.getOrDefault(needle, -<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"38-Count-and-Say-Easy\"><a href=\"#38-Count-and-Say-Easy\" class=\"headerlink\" title=\"38. Count and Say (Easy) @\"></a>38. Count and Say (Easy) <a href=\"https://leetcode.com/problems/count-and-say/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>The count-and-say sequence is the sequence of integers with the first five terms as following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; 1.     1</span><br><span class=\"line\">&gt; 2.     11</span><br><span class=\"line\">&gt; 3.     21</span><br><span class=\"line\">&gt; 4.     1211</span><br><span class=\"line\">&gt; 5.     111221</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><code>1</code> is read off as <code>&quot;one 1&quot;</code> or <code>11</code>.<br><code>11</code> is read off as <code>&quot;two 1s&quot;</code> or <code>21</code>.<br><code>21</code> is read off as <code>&quot;one 2</code>, then <code>one 1&quot;</code> or <code>1211</code>.</p>\n<p>Given an integer <em>n</em> where 1 ≤ <em>n</em> ≤ 30, generate the <em>n</em>th term of the count-and-say sequence. You can do so recursively, in other words from the previous member read off the digits, counting the number of digits in groups of the same digit.</p>\n<p>Note: Each term of the sequence of integers will be represented as a string.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: 1</span><br><span class=\"line\">&gt; Output: &quot;1&quot;</span><br><span class=\"line\">&gt; Explanation: This is the base case.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: 4</span><br><span class=\"line\">&gt; Output: &quot;1211&quot;</span><br><span class=\"line\">&gt; Explanation: For n = 3 the term was &quot;21&quot; in which we have two groups &quot;2&quot; and &quot;1&quot;, &quot;2&quot; can be read as &quot;12&quot; which means frequency = 1 and value = 2, the same way &quot;1&quot; is read as &quot;11&quot;, so the answer is the concatenation of &quot;12&quot; and &quot;11&quot; which is &quot;1211&quot;.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution 1 Recursion</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">countAndSay</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"1\"</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            String preStr = countAndSay(n-<span class=\"number\">1</span>);</span><br><span class=\"line\">            String res = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> len = <span class=\"number\">1</span>; <span class=\"comment\">//len of same char</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; <span class=\"comment\">//idx of preStr</span></span><br><span class=\"line\">            <span class=\"comment\">//scan preStr to determine the following string</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (i &lt; preStr.length()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (preStr.charAt(i) == preStr.charAt(i-<span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                    len++;</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    res += String.valueOf(len) + String.valueOf(preStr.charAt(i-<span class=\"number\">1</span>));</span><br><span class=\"line\">                    len = <span class=\"number\">1</span>; <span class=\"comment\">//reset len of same char</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res += String.valueOf(len) + String.valueOf(preStr.charAt(i-<span class=\"number\">1</span>));</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res.toString();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 1 Improvement </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">countAndSay</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"1\"</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            String preStr = countAndSay(n-<span class=\"number\">1</span>);</span><br><span class=\"line\">            StringBuilder res = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> len = <span class=\"number\">1</span>; <span class=\"comment\">//len of same char</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; <span class=\"comment\">//idx of preStr</span></span><br><span class=\"line\">            <span class=\"comment\">//scan preStr to determine the following string</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (i &lt; preStr.length()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (preStr.charAt(i) == preStr.charAt(i-<span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                    len++;</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// res += String.valueOf(len) + String.valueOf(preStr.charAt(i-1));</span></span><br><span class=\"line\">                    res.append(len).append(preStr.charAt(i-<span class=\"number\">1</span>));</span><br><span class=\"line\">                    len = <span class=\"number\">1</span>; <span class=\"comment\">//reset len of same char</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// res += String.valueOf(len) + String.valueOf(preStr.charAt(i-1));</span></span><br><span class=\"line\">            res.append(len).append(preStr.charAt(i-<span class=\"number\">1</span>));</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res.toString();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 2 Recursion</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">countAndSay</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"1\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> read(countAndSay(n-<span class=\"number\">1</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">read</span><span class=\"params\">(String preStr)</span> </span>&#123;</span><br><span class=\"line\">        StringBuilder res = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; preStr.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> c = preStr.charAt(i); <span class=\"comment\">//current char</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> len = <span class=\"number\">1</span>; <span class=\"comment\">//len of same char</span></span><br><span class=\"line\">            <span class=\"comment\">//find and append next \"len+c\"</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> ((i+<span class=\"number\">1</span>) &lt; preStr.length()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (preStr.charAt(i+<span class=\"number\">1</span>) != c) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    i++;</span><br><span class=\"line\">                    len++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res.append(len).append(c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"49-Group-Anagrams-Medium\"><a href=\"#49-Group-Anagrams-Medium\" class=\"headerlink\" title=\"49. Group Anagrams (Medium) @\"></a>49. Group Anagrams (Medium) <a href=\"https://leetcode.com/problems/group-anagrams/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given an array of strings, group anagrams together.</p>\n<p><strong>Example:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],</span><br><span class=\"line\">&gt; Output:</span><br><span class=\"line\">&gt; [</span><br><span class=\"line\">&gt; [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],</span><br><span class=\"line\">&gt; [&quot;nat&quot;,&quot;tan&quot;],</span><br><span class=\"line\">&gt; [&quot;bat&quot;]</span><br><span class=\"line\">&gt; ]</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Note:</strong></p>\n<ul>\n<li>All inputs will be in lowercase.</li>\n<li>The order of your output does not matter.</li>\n</ul>\n</blockquote>\n<p>Solution 1 Hash Map</p>\n<ul>\n<li>sort(str) 找到同字母的串</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(strs == <span class=\"keyword\">null</span> || strs.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            List&lt;List&lt;String&gt;&gt; ans = <span class=\"keyword\">new</span> ArrayList&lt;List&lt;String&gt;&gt;();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        HashMap&lt;String, List&lt;String&gt;&gt; hash = <span class=\"keyword\">new</span> HashMap&lt;String, List&lt;String&gt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String str:strs) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span>[] c = str.toCharArray();</span><br><span class=\"line\">            Arrays.sort(c);</span><br><span class=\"line\">            String temp = String.valueOf(c);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!hash.containsKey(temp)) &#123;</span><br><span class=\"line\">                List&lt;String&gt; vals = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();</span><br><span class=\"line\">                vals.add(str);</span><br><span class=\"line\">                hash.put(temp, vals);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                hash.get(temp).add(str);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        List&lt;List&lt;String&gt;&gt; ans = <span class=\"keyword\">new</span> ArrayList&lt;List&lt;String&gt;&gt;();</span><br><span class=\"line\">        ans.addAll(hash.values());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 2 Hash Map + Prime Number</p>\n<ul>\n<li>每个字母对应一个质数，计算所有字符串的积</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//26个质数对应26个字母</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] primes = &#123;<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">11</span>, <span class=\"number\">13</span>, <span class=\"number\">17</span>, <span class=\"number\">19</span>, <span class=\"number\">23</span>, <span class=\"number\">29</span>, <span class=\"number\">31</span>, <span class=\"number\">41</span>, <span class=\"number\">43</span>, <span class=\"number\">47</span>, <span class=\"number\">53</span>, <span class=\"number\">59</span>, <span class=\"number\">61</span>, <span class=\"number\">67</span>, <span class=\"number\">71</span>, <span class=\"number\">73</span>, <span class=\"number\">79</span>, <span class=\"number\">83</span>, <span class=\"number\">89</span>, <span class=\"number\">97</span>, <span class=\"number\">101</span>, <span class=\"number\">103</span>&#125;;</span><br><span class=\"line\">        List&lt;List&lt;String&gt;&gt; ans = <span class=\"keyword\">new</span> ArrayList&lt;List&lt;String&gt;&gt;();</span><br><span class=\"line\">        HashMap&lt;Integer, List&lt;String&gt;&gt; hash = <span class=\"keyword\">new</span> HashMap&lt;Integer, List&lt;String&gt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String str:strs) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> key = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> c : str.toCharArray()) &#123;</span><br><span class=\"line\">                key *= primes[c-<span class=\"string\">'a'</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!hash.containsKey(key)) &#123;</span><br><span class=\"line\">                List&lt;String&gt; vals = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();</span><br><span class=\"line\">                vals.add(str);</span><br><span class=\"line\">                hash.put(key, vals);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                hash.get(key).add(str);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans.addAll(hash.values());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"58-Length-of-Last-Word-Easy\"><a href=\"#58-Length-of-Last-Word-Easy\" class=\"headerlink\" title=\"58. Length of Last Word (Easy) @\"></a>58. Length of Last Word (Easy) <a href=\"https://leetcode.com/problems/length-of-last-word/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a string <em>s</em> consists of upper/lower-case alphabets and empty space characters <code>&#39; &#39;</code>, return the length of last word (last word means the last appearing word if we loop from left to right) in the string.</p>\n<p>If the last word does not exist, return 0.</p>\n<p><strong>Note:</strong> A word is defined as a <strong>maximal substring</strong> consisting of non-space characters only.</p>\n<p><strong>Example:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: &quot;Hello World&quot;</span><br><span class=\"line\">&gt; Output: 5</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution </p>\n<ul>\n<li>Start = 第一个非’ ‘字符</li>\n<li>End = 下一个‘ ’</li>\n<li>注意while条件顺序，首先判断是否越界</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">lengthOfLastWord</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s == <span class=\"keyword\">null</span> || s.length() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> first = s.length() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">//the first not-' ' character --- start</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (first &gt;= <span class=\"number\">0</span> &amp;&amp; s.charAt(first) == <span class=\"string\">' '</span>)</span><br><span class=\"line\">            first--;</span><br><span class=\"line\">        <span class=\"comment\">//next ' ' position --- end</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (first &gt;= <span class=\"number\">0</span> &amp;&amp; s.charAt(first) != <span class=\"string\">' '</span>) &#123;</span><br><span class=\"line\">            first--;</span><br><span class=\"line\">            count++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"87-Scramble-String-Hard\"><a href=\"#87-Scramble-String-Hard\" class=\"headerlink\" title=\"87.  Scramble String (Hard) @\"></a>87.  Scramble String (Hard) <a href=\"https://leetcode.com/problems/scramble-string/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a string <em>s1</em>, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.</p>\n<p>Below is one possible representation of <em>s1</em> = <code>&quot;great&quot;</code>:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;  great</span><br><span class=\"line\">&gt; /    \\</span><br><span class=\"line\">&gt; gr    eat</span><br><span class=\"line\">&gt; / \\    /  \\</span><br><span class=\"line\">&gt; g   r  e   at</span><br><span class=\"line\">&gt;         / \\</span><br><span class=\"line\">&gt;        a   t</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p>To scramble the string, we may choose any non-leaf node and swap its two children.</p>\n<p>For example, if we choose the node <code>&quot;gr&quot;</code> and swap its two children, it produces a scrambled string <code>&quot;rgeat&quot;</code>.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;  rgeat</span><br><span class=\"line\">&gt; /    \\</span><br><span class=\"line\">&gt; rg    eat</span><br><span class=\"line\">&gt; / \\    /  \\</span><br><span class=\"line\">&gt; r   g  e   at</span><br><span class=\"line\">&gt;         / \\</span><br><span class=\"line\">&gt;        a   t</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p>We say that <code>&quot;rgeat&quot;</code> is a scrambled string of <code>&quot;great&quot;</code>.</p>\n<p>Similarly, if we continue to swap the children of nodes <code>&quot;eat&quot;</code> and <code>&quot;at&quot;</code>, it produces a scrambled string <code>&quot;rgtae&quot;</code>.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;  rgtae</span><br><span class=\"line\">&gt; /    \\</span><br><span class=\"line\">&gt; rg    tae</span><br><span class=\"line\">&gt; / \\    /  \\</span><br><span class=\"line\">&gt; r   g  ta  e</span><br><span class=\"line\">&gt;     / \\</span><br><span class=\"line\">&gt;    t   a</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p>We say that <code>&quot;rgtae&quot;</code> is a scrambled string of <code>&quot;great&quot;</code>.</p>\n<p>Given two strings <em>s1</em> and <em>s2</em> of the same length, determine if <em>s2</em> is a scrambled string of <em>s1</em>.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: s1 = &quot;great&quot;, s2 = &quot;rgeat&quot;</span><br><span class=\"line\">&gt; Output: true</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: s1 = &quot;abcde&quot;, s2 = &quot;caebd&quot;</span><br><span class=\"line\">&gt; Output: false</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution 1 Recursion</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isScramble</span><span class=\"params\">(String s1, String s2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//len of str</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s1.length() != s2.length()) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s1.equals(s2)) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//num of letters</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] letter = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class=\"line\">            letter[s1.charAt(i) - <span class=\"string\">'a'</span>]++;</span><br><span class=\"line\">            letter[s2.charAt(i) - <span class=\"string\">'a'</span>]--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//diff num of letters -&gt; false</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">26</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (letter[i] != <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//loop through all cut points</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; s1.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isScramble(s1.substring(<span class=\"number\">0</span>, i), s2.substring(<span class=\"number\">0</span>, i)) &amp;&amp; isScramble(s1.substring(i), s2.substring(i)))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"comment\">//switch</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isScramble(s1.substring(i), s2.substring(<span class=\"number\">0</span>, s2.length() - i)) &amp;&amp; isScramble(s1.substring(<span class=\"number\">0</span>, i), s2.substring(s2.length() - i)))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 2 Recursion + Memorization</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isScramble</span><span class=\"params\">(String s1, String s2)</span> </span>&#123;</span><br><span class=\"line\">        HashMap&lt;String, Integer&gt; memo = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> isSrambleHelper(s1, s2, memo);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isSrambleHelper</span><span class=\"params\">(String s1, String s2, HashMap&lt;String, Integer&gt; memo)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//previous res</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = memo.getOrDefault(s1 + <span class=\"string\">\"#\"</span> + s2, -<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (res == <span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (res == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//len of str</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s1.length() != s2.length()) &#123;</span><br><span class=\"line\">            memo.put(s1 + <span class=\"string\">\"#\"</span> + s2, <span class=\"number\">0</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s1.equals(s2)) &#123;</span><br><span class=\"line\">            memo.put(s1 + <span class=\"string\">\"#\"</span> + s2, <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//num of letters</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] letter = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class=\"line\">            letter[s1.charAt(i) - <span class=\"string\">'a'</span>]++;</span><br><span class=\"line\">            letter[s2.charAt(i) - <span class=\"string\">'a'</span>]--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//diff num of letters -&gt; false</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">26</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (letter[i] != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                memo.put(s1 + <span class=\"string\">\"#\"</span> + s2, <span class=\"number\">0</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//loop through all cut points</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; s1.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isScramble(s1.substring(<span class=\"number\">0</span>, i), s2.substring(<span class=\"number\">0</span>, i)) &amp;&amp; isScramble(s1.substring(i), s2.substring(i))) &#123;</span><br><span class=\"line\">                memo.put(s1 + <span class=\"string\">\"#\"</span> + s2, <span class=\"number\">1</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">            <span class=\"comment\">//switch</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isScramble(s1.substring(i), s2.substring(<span class=\"number\">0</span>, s2.length() - i)) &amp;&amp; isScramble(s1.substring(<span class=\"number\">0</span>, i), s2.substring(s2.length() - i))) &#123;</span><br><span class=\"line\">                memo.put(s1 + <span class=\"string\">\"#\"</span> + s2, <span class=\"number\">1</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        memo.put(s1 + <span class=\"string\">\"#\"</span> + s2, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 3 DP</p>\n<ul>\n<li><a href=\"https://leetcode-cn.com/problems/scramble-string/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-1-2/\" target=\"_blank\" rel=\"noopener\">solution detail</a></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isScramble</span><span class=\"params\">(String s1, String s2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//len of str</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s1.length() != s2.length()) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s1.equals(s2)) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//num of letters</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] letter = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class=\"line\">            letter[s1.charAt(i) - <span class=\"string\">'a'</span>]++;</span><br><span class=\"line\">            letter[s2.charAt(i) - <span class=\"string\">'a'</span>]--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//diff num of letters -&gt; false</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">26</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (letter[i] != <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> length = s1.length();</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span>[][][] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[length + <span class=\"number\">1</span>][length][length];</span><br><span class=\"line\">        <span class=\"comment\">//loop through all the len of str</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> len = <span class=\"number\">1</span>; len &lt; length + <span class=\"number\">1</span>; len++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//start of s1</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i + len &lt; length + <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//start of s2</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j + len &lt; length + <span class=\"number\">1</span>; j++) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (len == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                        dp[len][i][j] = s1.charAt(i) == s2.charAt(j);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">//loop through all the cut point</span></span><br><span class=\"line\">                        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> q = <span class=\"number\">1</span>; q &lt; len; q++) &#123;</span><br><span class=\"line\">                            dp[len][i][j] = (dp[q][i][j] &amp;&amp; dp[len-q][i+q][j+q]) || (dp[q][i][j+len-q] &amp;&amp; dp[len-q][i+q][j]);</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (dp[len][i][j])</span><br><span class=\"line\">                                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[length][<span class=\"number\">0</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"125-Valid-Palindrome-Easy\"><a href=\"#125-Valid-Palindrome-Easy\" class=\"headerlink\" title=\"125. Valid Palindrome (Easy) @\"></a>125. Valid Palindrome (Easy) <a href=\"https://leetcode.com/problems/valid-palindrome/submissions/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p>\n<p><strong>Note:</strong> For the purpose of this problem, we define empty string as valid palindrome.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class=\"line\">&gt; Output: true</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: &quot;race a car&quot;</span><br><span class=\"line\">&gt; Output: false</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.length() == <span class=\"number\">0</span> || s == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        s = s.toLowerCase();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>, right = s.length() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!Character.isLetterOrDigit(s.charAt(left))) &#123;</span><br><span class=\"line\">                left ++;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!Character.isLetterOrDigit(s.charAt(right))) &#123;</span><br><span class=\"line\">                right --;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s.charAt(left) == s.charAt(right)) &#123;</span><br><span class=\"line\">                left ++;</span><br><span class=\"line\">                right --;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"151-Reverse-Words-in-a-String-Medium\"><a href=\"#151-Reverse-Words-in-a-String-Medium\" class=\"headerlink\" title=\"151. Reverse Words in a String (Medium)  @\"></a>151. Reverse Words in a String (Medium)  <a href=\"https://leetcode.com/problems/reverse-words-in-a-string/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given an input string, reverse the string word by word.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: &quot;the sky is blue&quot;</span><br><span class=\"line\">&gt; Output: &quot;blue is sky the&quot;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: &quot;  hello world!  &quot;</span><br><span class=\"line\">&gt; Output: &quot;world! hello&quot;</span><br><span class=\"line\">&gt; Explanation: Your reversed string should not contain leading or trailing spaces.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: &quot;a good   example&quot;</span><br><span class=\"line\">&gt; Output: &quot;example good a&quot;</span><br><span class=\"line\">&gt; Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution 1 Library function</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">reverseWords</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        StringBuilder ans = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        <span class=\"comment\">//去掉s的首尾空格 然后将字符串拆分</span></span><br><span class=\"line\">        String[] str = s.trim().split(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = str.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//空格后面的空格会变成空字符串</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!str[i].equals(<span class=\"string\">\"\"</span>)) ans.append(str[i] + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//去掉最后添加上的空格</span></span><br><span class=\"line\">        ans = <span class=\"keyword\">new</span> StringBuilder(ans.toString().trim());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 2 从后向前</p>\n<ul>\n<li>将源字符串转换为数组，然后从后向前读取，遇到空格，判断是否单词结束</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">reverseWords</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s == <span class=\"keyword\">null</span> || s.length() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">char</span>[] chars = s.toCharArray();</span><br><span class=\"line\">        StringBuffer ans = <span class=\"keyword\">new</span> StringBuffer();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>, ptr = s.length()-<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">//从后向前扫描</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(ptr &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//空格两种情况：单词结束 和 未开始</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (chars[ptr] == <span class=\"string\">' '</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (count != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    ans.append(chars, ptr + <span class=\"number\">1</span>, count).append(<span class=\"string\">' '</span>);</span><br><span class=\"line\">                    count = <span class=\"number\">0</span>;<span class=\"comment\">//重置count</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            <span class=\"comment\">//遇到字母</span></span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                count++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ptr--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//处理最后一个单词</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (count != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            ans.append(chars, <span class=\"number\">0</span>, count).append(<span class=\"string\">' '</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//去除最后一个空格</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans.length() == <span class=\"number\">0</span> ? <span class=\"string\">\"\"</span> : ans.toString().substring(<span class=\"number\">0</span>, ans.length()-<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 3</p>\n<ul>\n<li>整句全部逆置，再逐个单词逆置</li>\n</ul>\n<h3 id=\"166-Fraction-to-Recurring-Decimal-Medium\"><a href=\"#166-Fraction-to-Recurring-Decimal-Medium\" class=\"headerlink\" title=\"166. Fraction to Recurring Decimal (Medium) @\"></a>166. Fraction to Recurring Decimal (Medium) <a href=\"https://leetcode.com/problems/fraction-to-recurring-decimal/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.</p>\n<p>If the fractional part is repeating, enclose the repeating part in parentheses.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: numerator = 1, denominator = 2</span><br><span class=\"line\">&gt; Output: &quot;0.5&quot;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: numerator = 2, denominator = 1</span><br><span class=\"line\">&gt; Output: &quot;2&quot;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: numerator = 2, denominator = 3</span><br><span class=\"line\">&gt; Output: &quot;0.(6)&quot;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution HashMap</p>\n<ul>\n<li>利用哈希表存储余数位置，以判断是否存在重复的对应小数位</li>\n<li>当出现重复则加入“（）”</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">fractionToDecimal</span><span class=\"params\">(<span class=\"keyword\">int</span> numerator, <span class=\"keyword\">int</span> denominator)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (numerator == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"string\">\"0\"</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        StringBuilder fraction = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        <span class=\"comment\">//positive or negative</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (numerator &lt; <span class=\"number\">0</span> ^ denominator &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            fraction.append(<span class=\"string\">\"-\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Long dividend = Math.abs(Long.valueOf(numerator));</span><br><span class=\"line\">        Long divisor = Math.abs(Long.valueOf(denominator));</span><br><span class=\"line\">        <span class=\"comment\">//Integer Part</span></span><br><span class=\"line\">        fraction.append(String.valueOf(dividend/divisor));</span><br><span class=\"line\">        Long remainder = dividend % divisor;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (remainder == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> fraction.toString();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//Decimal Part</span></span><br><span class=\"line\">        fraction.append(<span class=\"string\">\".\"</span>);</span><br><span class=\"line\">        Map&lt;Long, Integer&gt; pos = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (remainder != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//repeat</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pos.containsKey(remainder)) &#123;</span><br><span class=\"line\">                fraction.insert(pos.get(remainder), <span class=\"string\">\"(\"</span>);</span><br><span class=\"line\">                fraction.append(<span class=\"string\">\")\"</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//add new decimal num</span></span><br><span class=\"line\">            pos.put(remainder, fraction.length()); <span class=\"comment\">//add remainder's position</span></span><br><span class=\"line\">            remainder *= <span class=\"number\">10</span>;</span><br><span class=\"line\">            fraction.append(String.valueOf(remainder / divisor));<span class=\"comment\">//add corresponding decimal</span></span><br><span class=\"line\">            remainder %= divisor;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fraction.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"168-Excel-Sheet-Column-Title-Easy\"><a href=\"#168-Excel-Sheet-Column-Title-Easy\" class=\"headerlink\" title=\"168. Excel Sheet Column Title (Easy) @\"></a>168. Excel Sheet Column Title (Easy) <a href=\"https://leetcode.com/problems/excel-sheet-column-title/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a positive integer, return its corresponding column title as appear in an Excel sheet.</p>\n<p>For example:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;  1 -&gt; A</span><br><span class=\"line\">&gt;  2 -&gt; B</span><br><span class=\"line\">&gt;  3 -&gt; C</span><br><span class=\"line\">&gt;  ...</span><br><span class=\"line\">&gt;  26 -&gt; Z</span><br><span class=\"line\">&gt;  27 -&gt; AA</span><br><span class=\"line\">&gt;  28 -&gt; AB </span><br><span class=\"line\">&gt;  ...</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: 1</span><br><span class=\"line\">&gt; Output: &quot;A&quot;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: 28</span><br><span class=\"line\">&gt; Output: &quot;AB&quot;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: 701</span><br><span class=\"line\">&gt; Output: &quot;ZY&quot;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution 进制转换</p>\n<ul>\n<li>注意是1 - 26 所以使用 n-1</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">convertToTitle</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        StringBuilder str = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (n &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            str.insert(<span class=\"number\">0</span>, (<span class=\"keyword\">char</span>)((n-<span class=\"number\">1</span>)%<span class=\"number\">26</span> + <span class=\"string\">'A'</span>));</span><br><span class=\"line\">            n = (n-<span class=\"number\">1</span>)/<span class=\"number\">26</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> str.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"171-Excel-Sheet-Column-Number-Easy\"><a href=\"#171-Excel-Sheet-Column-Number-Easy\" class=\"headerlink\" title=\"171. Excel Sheet Column Number (Easy) @\"></a>171. Excel Sheet Column Number (Easy) <a href=\"https://leetcode.com/problems/excel-sheet-column-number/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a column title as appear in an Excel sheet, return its corresponding column number.</p>\n<p>For example:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;  A -&gt; 1</span><br><span class=\"line\">&gt;  B -&gt; 2</span><br><span class=\"line\">&gt;  C -&gt; 3</span><br><span class=\"line\">&gt;  ...</span><br><span class=\"line\">&gt;  Z -&gt; 26</span><br><span class=\"line\">&gt;  AA -&gt; 27</span><br><span class=\"line\">&gt;  AB -&gt; 28 </span><br><span class=\"line\">&gt;  ...</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: &quot;A&quot;</span><br><span class=\"line\">&gt; Output: 1</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: &quot;AB&quot;</span><br><span class=\"line\">&gt; Output: 28</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: &quot;ZY&quot;</span><br><span class=\"line\">&gt; Output: 701</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">titleToNumber</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> c : s.toCharArray()) &#123;</span><br><span class=\"line\">            ans = ans * <span class=\"number\">26</span> + (<span class=\"keyword\">int</span>)(c - <span class=\"string\">'A'</span> + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"179-Largest-Number-Medium\"><a href=\"#179-Largest-Number-Medium\" class=\"headerlink\" title=\"179. Largest Number (Medium) @\"></a>179. Largest Number (Medium) <a href=\"https://leetcode.com/problems/largest-number/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a list of non negative integers, arrange them such that they form the largest number.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [10,2]</span><br><span class=\"line\">&gt; Output: &quot;210&quot;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [3,30,34,5,9]</span><br><span class=\"line\">&gt; Output: &quot;9534330&quot;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Note:</strong> The result may be very large, so you need to return a string instead of an integer.</p>\n</blockquote>\n<p>Solution </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LargerNumberComparator</span> <span class=\"keyword\">implements</span> <span class=\"title\">Comparator</span>&lt;<span class=\"title\">String</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(String a, String b)</span> </span>&#123;</span><br><span class=\"line\">            String order1 = a + b;</span><br><span class=\"line\">            String order2 = b + a;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> order2.compareTo(order1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">largestNumber</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//convert to strings</span></span><br><span class=\"line\">        String[] asStrs = <span class=\"keyword\">new</span> String[nums.length];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            asStrs[i] = String.valueOf(nums[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Arrays.sort(asStrs, <span class=\"keyword\">new</span> LargerNumberComparator());</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (asStrs[<span class=\"number\">0</span>].equals(<span class=\"string\">\"0\"</span>)) <span class=\"keyword\">return</span> <span class=\"string\">\"0\"</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        StringBuilder ans = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String str : asStrs) &#123;</span><br><span class=\"line\">            ans.append(str);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"205-Isomorphic-Strings-Easy\"><a href=\"#205-Isomorphic-Strings-Easy\" class=\"headerlink\" title=\"205. Isomorphic Strings (Easy) @\"></a>205. Isomorphic Strings (Easy) <a href=\"https://leetcode.com/problems/isomorphic-strings/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given two strings <strong><em>s\\</em></strong> and <strong><em>t\\</em></strong>, determine if they are isomorphic.</p>\n<p>Two strings are isomorphic if the characters in <strong><em>s\\</em></strong> can be replaced to get <strong><em>t\\</em></strong>.</p>\n<p>All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: s = &quot;egg&quot;, t = &quot;add&quot;</span><br><span class=\"line\">&gt; Output: true</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: s = &quot;foo&quot;, t = &quot;bar&quot;</span><br><span class=\"line\">&gt; Output: false</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: s = &quot;paper&quot;, t = &quot;title&quot;</span><br><span class=\"line\">&gt; Output: true</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Note:</strong><br>You may assume both <strong><em>s\\</em></strong> and <strong><em>t\\</em></strong> have the same length.</p>\n</blockquote>\n<p>Solution 1 HashMap</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isIsomorphic</span><span class=\"params\">(String s, String t)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.length() != t.length()) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">//map -- match char in s and t</span></span><br><span class=\"line\">        HashMap&lt;Character, Character&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">//set -- judge char in t whether has mapped</span></span><br><span class=\"line\">        Set&lt;Character&gt; set = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">char</span> sChart, tChart;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">            sChart = s.charAt(i);</span><br><span class=\"line\">            tChart = t.charAt(i);</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!map.containsKey(sChart)) &#123;<span class=\"comment\">//no mapped</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (set.contains(tChart)) &#123;<span class=\"comment\">//t has been mapped</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    map.put(sChart, tChart);</span><br><span class=\"line\">                    set.add(tChart);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;<span class=\"comment\">//mapped</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (map.get(sChart) != tChart) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 2 Array</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isIsomorphic</span><span class=\"params\">(String s, String t)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span>[] sChars = s.toCharArray();</span><br><span class=\"line\">        <span class=\"keyword\">char</span>[] tChars = t.toCharArray();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> length = sChars.length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(length != tChars.length) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">char</span>[] sm = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"number\">256</span>];</span><br><span class=\"line\">        <span class=\"keyword\">char</span>[] tm = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"number\">256</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;length; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> sc = sChars[i];</span><br><span class=\"line\">            <span class=\"keyword\">char</span> tc = tChars[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(sm[sc] == <span class=\"number\">0</span> &amp;&amp; tm[tc] == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                sm[sc] = tc;</span><br><span class=\"line\">                tm[tc] = sc;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(sm[sc] != tc || tm[tc] != sc)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"242-Valid-Anagram-Easy\"><a href=\"#242-Valid-Anagram-Easy\" class=\"headerlink\" title=\"242. Valid Anagram (Easy) @\"></a>242. Valid Anagram (Easy) <a href=\"https://leetcode.com/problems/valid-anagram/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given two strings <em>s</em> and <em>t</em> , write a function to determine if <em>t</em> is an anagram of <em>s</em>.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: s = &quot;anagram&quot;, t = &quot;nagaram&quot;</span><br><span class=\"line\">&gt; Output: true</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: s = &quot;rat&quot;, t = &quot;car&quot;</span><br><span class=\"line\">&gt; Output: false</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Note:</strong><br>You may assume the string contains only lowercase alphabets.</p>\n<p><strong>Follow up:</strong><br>What if the inputs contain unicode characters? How would you adapt your solution to such case?</p>\n</blockquote>\n<p>Solution 1 Sort</p>\n<ul>\n<li>排序，比较</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isAnagram</span><span class=\"params\">(String s, String t)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span>[] sArr = s.toCharArray();</span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span>[] tArr = t.toCharArray();</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\tArrays.sort(sArr);</span><br><span class=\"line\">\t\tArrays.sort(tArr);</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> String.valueOf(sArr).equals(String.valueOf(tArr));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 2 Array</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isAnagram</span><span class=\"params\">(String s, String t)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.length() != t.length()) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] count = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> sChar = s.charAt(i);</span><br><span class=\"line\">            <span class=\"keyword\">char</span> tChar = t.charAt(i);</span><br><span class=\"line\">            </span><br><span class=\"line\">            count[sChar-<span class=\"string\">'a'</span>] ++;</span><br><span class=\"line\">            count[tChar-<span class=\"string\">'a'</span>] --;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">       \t<span class=\"comment\">//遍历整个count数组</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (count[i] != <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"290-Word-Pattern-Easy\"><a href=\"#290-Word-Pattern-Easy\" class=\"headerlink\" title=\"290. Word Pattern (Easy) @\"></a>290. Word Pattern (Easy) <a href=\"https://leetcode.com/problems/word-pattern/submissions/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a <code>pattern</code> and a string <code>str</code>, find if <code>str</code> follows the same pattern.</p>\n<p>Here <strong>follow</strong> means a full match, such that there is a bijection between a letter in <code>pattern</code> and a <strong>non-empty</strong> word in <code>str</code>.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: pattern = &quot;abba&quot;, str = &quot;dog cat cat dog&quot;</span><br><span class=\"line\">&gt; Output: true</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input:pattern = &quot;abba&quot;, str = &quot;dog cat cat fish&quot;</span><br><span class=\"line\">&gt; Output: false</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: pattern = &quot;aaaa&quot;, str = &quot;dog cat cat dog&quot;</span><br><span class=\"line\">&gt; Output: false</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 4:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: pattern = &quot;abba&quot;, str = &quot;dog dog dog dog&quot;</span><br><span class=\"line\">&gt; Output: false</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Notes:</strong><br>You may assume <code>pattern</code> contains only lowercase letters, and <code>str</code> contains lowercase letters that may be separated by a single space.</p>\n</blockquote>\n<p>Solution–Improvement of P205 Solution 1</p>\n<ul>\n<li>由于字符串比较需要转换，所以用字符串做键，模式字符作为值</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">wordPattern</span><span class=\"params\">(String pattern, String str)</span> </span>&#123;</span><br><span class=\"line\">        String[] Strs = str.split(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">char</span>[] p = pattern.toCharArray();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Strs.length != p.length) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        HashMap&lt;String, Character&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        Set&lt;Character&gt; set = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; p.length; i++) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!map.containsKey(Strs[i])) &#123;<span class=\"comment\">//no mapped</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (set.contains(p[i])) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    map.put(Strs[i], p[i]);</span><br><span class=\"line\">                    set.add(p[i]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;<span class=\"comment\">//mapped</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (map.get(Strs[i]) != p[i]) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"316-Remove-Duplicate-Letters-Hard\"><a href=\"#316-Remove-Duplicate-Letters-Hard\" class=\"headerlink\" title=\"316. Remove Duplicate Letters (Hard) @\"></a>316. Remove Duplicate Letters (Hard) <a href=\"https://leetcode.com/problems/remove-duplicate-letters/submissions/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a string which contains only lowercase letters, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: &quot;bcabc&quot;</span><br><span class=\"line\">&gt; Output: &quot;abc&quot;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: &quot;cbacdcbc&quot;</span><br><span class=\"line\">&gt; Output: &quot;acdb&quot;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution 1 Stack</p>\n<p>思路：每个字符必须出现一次，当这个字符只有一次机会的时候必须添加到字符串结尾，反之，如果后面还有则可以把优先级高的先放进来。<br>步骤：</p>\n<ol>\n<li><p>统计s中字符最后位置</p>\n</li>\n<li><p>如果当前字符已经出现在stack中则跳过</p>\n</li>\n<li><p>如果当前字符不在栈里：</p>\n<p>a. 若当前字符char小与栈顶元素，且栈顶元素有剩余 =》栈顶出栈 并 标记栈顶元素不在栈中（重复该操作直到不满足条件或栈为空）</p>\n<p>b. 当前字符char入栈，并标记char在栈中</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">removeDuplicateLetters</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = s.length();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (len &lt; <span class=\"number\">2</span>) <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">boolean</span>[] visited = <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] lastPos = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">26</span>]; <span class=\"comment\">// 1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">            lastPos[s.charAt(i) - <span class=\"string\">'a'</span>] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Stack&lt;Character&gt; stack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> cur = s.charAt(i);</span><br><span class=\"line\">            <span class=\"comment\">// 2</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (visited[cur - <span class=\"string\">'a'</span>]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 3.a</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() &gt; cur &amp;&amp; lastPos[stack.peek() - <span class=\"string\">'a'</span>] &gt; i) &#123;</span><br><span class=\"line\">                visited[stack.pop() - <span class=\"string\">'a'</span>] = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 3.b</span></span><br><span class=\"line\">            stack.add(cur);</span><br><span class=\"line\">            visited[cur - <span class=\"string\">'a'</span>] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        StringBuilder str = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!stack.isEmpty()) &#123;</span><br><span class=\"line\">            str.insert(<span class=\"number\">0</span>, stack.pop());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> str.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 2 Array</p>\n<ul>\n<li>思路和stack一样但是不需要用到stack</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">removeDuplicateLetters</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] count = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span>[] visited = <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">        <span class=\"keyword\">char</span>[] charArr = s.toCharArray();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">char</span> c : charArr) &#123;</span><br><span class=\"line\">            count[c - <span class=\"string\">'a'</span>]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> i =<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">char</span> c : charArr) &#123;</span><br><span class=\"line\">            count[c - <span class=\"string\">'a'</span>]--;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(visited[c- <span class=\"string\">'a'</span>]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(i &gt;<span class=\"number\">0</span> &amp;&amp; charArr[i-<span class=\"number\">1</span>] &gt;= c &amp;&amp; count[charArr[i-<span class=\"number\">1</span>]-<span class=\"string\">'a'</span>]&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                visited[charArr[i-<span class=\"number\">1</span>]-<span class=\"string\">'a'</span>] = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                i--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            charArr[i] = c;</span><br><span class=\"line\">            visited[c -<span class=\"string\">'a'</span>] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> String(charArr).substring(<span class=\"number\">0</span>,i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"344-Reverse-String-Easy\"><a href=\"#344-Reverse-String-Easy\" class=\"headerlink\" title=\"344. Reverse String (Easy) @\"></a>344. Reverse String (Easy) <a href=\"https://leetcode.com/problems/reverse-string/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Write a function that reverses a string. The input string is given as an array of characters <code>char[]</code>.</p>\n<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\" rel=\"noopener\">in-place</a></strong> with O(1) extra memory.</p>\n<p>You may assume all the characters consist of <a href=\"https://en.wikipedia.org/wiki/ASCII#Printable_characters\" target=\"_blank\" rel=\"noopener\">printable ascii characters</a>.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]</span><br><span class=\"line\">&gt; Output: [&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]</span><br><span class=\"line\">&gt; Output: [&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution Swap</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">reverseString</span><span class=\"params\">(<span class=\"keyword\">char</span>[] s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.length == <span class=\"number\">0</span> || s == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length/<span class=\"number\">2</span>; i++) &#123;</span><br><span class=\"line\">            swap(s, i, s.length-i-<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">char</span>[] s, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> temp = s[i];</span><br><span class=\"line\">        s[i] = s[j];</span><br><span class=\"line\">        s[j] = temp;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"345-Reverse-Vowels-of-a-String-Easy\"><a href=\"#345-Reverse-Vowels-of-a-String-Easy\" class=\"headerlink\" title=\"345. Reverse Vowels of a String (Easy) @\"></a>345. Reverse Vowels of a String (Easy) <a href=\"https://leetcode.com/problems/reverse-vowels-of-a-string/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Write a function that takes a string as input and reverse only the vowels of a string.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: &quot;hello&quot;</span><br><span class=\"line\">&gt; Output: &quot;holle&quot;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: &quot;leetcode&quot;</span><br><span class=\"line\">&gt; Output: &quot;leotcede&quot;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Note:</strong><br>The vowels does not include the letter “y”.</p>\n</blockquote>\n<p>Solution </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">reverseVowels</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span>[] arr = s.toCharArray();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left =<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> right =arr.length-<span class=\"number\">1</span>;</span><br><span class=\"line\">         </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(left&lt;right)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(!isVowel(s.charAt(left))&amp;&amp;left&lt;right)</span><br><span class=\"line\">                left++;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(!isVowel(s.charAt(right))&amp;&amp;left&lt;right)</span><br><span class=\"line\">                right--;</span><br><span class=\"line\">            swap(left,right,arr);</span><br><span class=\"line\">            left++;</span><br><span class=\"line\">            right--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> String(arr);</span><br><span class=\"line\">         </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isVowel</span><span class=\"params\">(<span class=\"keyword\">char</span> c)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(c==<span class=\"string\">'a'</span>||c==<span class=\"string\">'e'</span>||c==<span class=\"string\">'i'</span>||c==<span class=\"string\">'o'</span>||c==<span class=\"string\">'u'</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(c==<span class=\"string\">'A'</span>||c==<span class=\"string\">'E'</span>||c==<span class=\"string\">'I'</span>||c==<span class=\"string\">'O'</span>||c==<span class=\"string\">'U'</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span> i,<span class=\"keyword\">int</span> j,<span class=\"keyword\">char</span>[] arr)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> tmp = arr[i];</span><br><span class=\"line\">        arr[i] =arr[j];</span><br><span class=\"line\">        arr[j]=tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"383-Ransom-Note-Easy\"><a href=\"#383-Ransom-Note-Easy\" class=\"headerlink\" title=\"383. Ransom Note (Easy) @\"></a>383. Ransom Note (Easy) <a href=\"https://leetcode.com/problems/ransom-note/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false.</p>\n<p>Each letter in the magazine string can only be used once in your ransom note.</p>\n<p><strong>Note:</strong><br>You may assume that both strings contain only lowercase letters.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; canConstruct(&quot;a&quot;, &quot;b&quot;) -&gt; false</span><br><span class=\"line\">&gt; canConstruct(&quot;aa&quot;, &quot;ab&quot;) -&gt; false</span><br><span class=\"line\">&gt; canConstruct(&quot;aa&quot;, &quot;aab&quot;) -&gt; true</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution 1 Hash Map</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">canConstruct</span><span class=\"params\">(String ransomNote, String magazine)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//generate hash map of magazine</span></span><br><span class=\"line\">        HashMap&lt;Character, Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; magazine.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> c = magazine.charAt(i);</span><br><span class=\"line\">            map.put(c, map.getOrDefault(c, <span class=\"number\">0</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//update the num of characters in map</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; ransomNote.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> c = ransomNote.charAt(i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!map.containsKey(c))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            map.put(c, map.get(c)-<span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (map.get(c) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 2 String to Array</p>\n<ul>\n<li>字符转化为数字对应</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">canConstruct</span><span class=\"params\">(String ransomNote, String magazine)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count[] = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">char</span> ch: magazine.toCharArray()) &#123;</span><br><span class=\"line\">            count[ch - <span class=\"string\">'a'</span>]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">char</span> ch: ransomNote.toCharArray()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(count[ch - <span class=\"string\">'a'</span>] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            count[ch - <span class=\"string\">'a'</span>]--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 3</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">canConstruct</span><span class=\"params\">(String ransomNote, String magazine)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//若magazine比ransomNote短则一定不可能</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (magazine.length() &lt; ransomNote.length()) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">char</span>[] r = ransomNote.toCharArray();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] list = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> idx = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> c : r) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//判断mag中是否还有c</span></span><br><span class=\"line\">            <span class=\"comment\">//public int indexOf(int char, int fromIndex)</span></span><br><span class=\"line\">            idx = magazine.indexOf(c, list[c - <span class=\"string\">'a'</span>]);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (idx &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//使用过之后向后移动idx</span></span><br><span class=\"line\">            list[c - <span class=\"string\">'a'</span>] = idx + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"387-First-Unique-Character-in-a-String-Easy\"><a href=\"#387-First-Unique-Character-in-a-String-Easy\" class=\"headerlink\" title=\"387. First Unique Character in a String (Easy)  @\"></a>387. First Unique Character in a String (Easy)  <a href=\"https://leetcode.com/problems/first-unique-character-in-a-string/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a string, find the first non-repeating character in it and return it’s index. If it doesn’t exist, return -1.</p>\n<p><strong>Examples:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; s = &quot;leetcode&quot;</span><br><span class=\"line\">&gt; return 0.</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; s = &quot;loveleetcode&quot;,</span><br><span class=\"line\">&gt; return 2.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Note:</strong> You may assume the string contain only lowercase letters.</p>\n</blockquote>\n<p>Solution Hash Map</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">firstUniqChar</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        HashMap&lt;Character, Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">//generate and update hashmap</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> c = s.charAt(i);</span><br><span class=\"line\">            map.put(c, map.getOrDefault(c, <span class=\"number\">0</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//traverse the map</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (map.get(s.charAt(i)) == <span class=\"number\">1</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Array\"><a href=\"#Array\" class=\"headerlink\" title=\"Array\"></a>Array</h2><h3 id=\"54-Spiral-Matrix-Medium\"><a href=\"#54-Spiral-Matrix-Medium\" class=\"headerlink\" title=\"54. Spiral Matrix (Medium) @\"></a>54. Spiral Matrix (Medium) <a href=\"https://leetcode.com/problems/spiral-matrix/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a matrix of <em>m</em> x <em>n</em> elements (<em>m</em> rows, <em>n</em> columns), return all elements of the matrix in spiral order.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input:</span><br><span class=\"line\">&gt; [</span><br><span class=\"line\">&gt; [ 1, 2, 3 ],</span><br><span class=\"line\">&gt; [ 4, 5, 6 ],</span><br><span class=\"line\">&gt; [ 7, 8, 9 ]</span><br><span class=\"line\">&gt; ]</span><br><span class=\"line\">&gt; Output: [1,2,3,6,9,8,7,4,5]</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input:</span><br><span class=\"line\">&gt; [</span><br><span class=\"line\">&gt; [1, 2, 3, 4],</span><br><span class=\"line\">&gt; [5, 6, 7, 8],</span><br><span class=\"line\">&gt; [9,10,11,12]</span><br><span class=\"line\">&gt; ]</span><br><span class=\"line\">&gt; Output: [1,2,3,4,8,12,11,10,9,5,6,7]</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution 1 Simulation<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">spiralOrder</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] matrix)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; res = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (matrix == <span class=\"keyword\">null</span> || matrix.length == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> R = matrix.length, C = matrix[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span>[][] visited = <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[R][C];</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] dr = &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, -<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] dc = &#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>, -<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> r = <span class=\"number\">0</span>, c = <span class=\"number\">0</span>, di = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; R*C; i++) &#123;</span><br><span class=\"line\">            res.add(matrix[r][c]);</span><br><span class=\"line\">            visited[r][c] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> cur_c = c + dc[di];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> cur_r = r + dr[di];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cur_c &gt;= <span class=\"number\">0</span> &amp;&amp; cur_c &lt; C &amp;&amp; cur_r &gt;= <span class=\"number\">0</span> &amp;&amp; cur_r &lt; R &amp;&amp; !visited[cur_r][cur_c]) &#123;</span><br><span class=\"line\">                c = cur_c;</span><br><span class=\"line\">                r = cur_r;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                di = (di + <span class=\"number\">1</span>) % <span class=\"number\">4</span>;</span><br><span class=\"line\">                c += dc[di];</span><br><span class=\"line\">                r += dr[di];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Solution 2 Layer by Layer</p>\n<ul>\n<li>For each outer layer, we want to iterate through its elements in clockwise order starting from the top left corner. Suppose the current outer layer has top-left coordinates (r1, c1) and bottom-right coordinates (r2, c2).</li>\n<li>top : c from c1 …… c2</li>\n<li>right : r from r1+1 …… r2</li>\n<li>bottom : c from c2-1 …… c1+1</li>\n<li>left : r from r2 …… r1-1<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">spiralOrder</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] matrix)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; res = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (matrix == <span class=\"keyword\">null</span> || matrix.length == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> r1 = <span class=\"number\">0</span>, r2 = matrix.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c1 = <span class=\"number\">0</span>, c2 = matrix[<span class=\"number\">0</span>].length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (r1 &lt;= r2 &amp;&amp; c1 &lt;= c2) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> c = c1; c &lt;= c2; c++) res.add(matrix[r1][c]);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> r = r1+<span class=\"number\">1</span>; r &lt;= r2; r++) res.add(matrix[r][c2]);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r1 &lt; r2 &amp;&amp; c1 &lt; c2) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> c = c2 - <span class=\"number\">1</span>; c &gt; c1; c--) res.add(matrix[r2][c]);</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> r = r2; r &gt; r1; r--) res.add(matrix[r][c1]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//move top-left and bottom-right point</span></span><br><span class=\"line\">            r1++;</span><br><span class=\"line\">            c1++;</span><br><span class=\"line\">            r2--;</span><br><span class=\"line\">            c2--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"56-Merge-Intervals-Medium\"><a href=\"#56-Merge-Intervals-Medium\" class=\"headerlink\" title=\"56. Merge Intervals (Medium) @\"></a>56. Merge Intervals (Medium) <a href=\"https://leetcode.com/problems/merge-intervals/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a collection of intervals, merge all overlapping intervals.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [[1,3],[2,6],[8,10],[15,18]]</span><br><span class=\"line\">&gt; Output: [[1,6],[8,10],[15,18]]</span><br><span class=\"line\">&gt; Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [[1,4],[4,5]]</span><br><span class=\"line\">&gt; Output: [[1,5]]</span><br><span class=\"line\">&gt; Explanation: Intervals [1,4] and [4,5] are considered overlapping.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>NOTE:</strong> input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.</p>\n</blockquote>\n<p>Solution Sort + Compare</p>\n<ul>\n<li>按照start排序，然后相邻之间比较</li>\n<li><a href=\"https://blog.csdn.net/wqh8522/article/details/79745350\" target=\"_blank\" rel=\"noopener\">Lambda表达式</a><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[][] merge(<span class=\"keyword\">int</span>[][] intervals) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (intervals.length &lt;= <span class=\"number\">1</span>) <span class=\"keyword\">return</span> intervals;</span><br><span class=\"line\">        <span class=\"comment\">//sorted by start</span></span><br><span class=\"line\">        Arrays.sort(intervals,(i1, i2) -&gt; Integer.compare(i1[<span class=\"number\">0</span>], i2[<span class=\"number\">0</span>]));</span><br><span class=\"line\">        </span><br><span class=\"line\">        List&lt;<span class=\"keyword\">int</span>[]&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] newInterval = intervals[<span class=\"number\">0</span>];</span><br><span class=\"line\">        res.add(newInterval);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span>[] interval : intervals) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//前一个右界大于等于后一个左界</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (newInterval[<span class=\"number\">1</span>] &gt;= interval[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">                newInterval[<span class=\"number\">1</span>] = Math.max(newInterval[<span class=\"number\">1</span>], interval[<span class=\"number\">1</span>]);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                newInterval = interval;</span><br><span class=\"line\">                res.add(newInterval);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res.toArray(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[res.size()][]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"66-Plus-One-Easy\"><a href=\"#66-Plus-One-Easy\" class=\"headerlink\" title=\"66. Plus One (Easy) @\"></a>66. Plus One (Easy) <a href=\"https://leetcode.com/problems/plus-one/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a <strong>non-empty</strong> array of digits representing a non-negative integer, plus one to the integer.</p>\n<p>The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.</p>\n<p>You may assume the integer does not contain any leading zero, except the number 0 itself.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [1,2,3]</span><br><span class=\"line\">&gt; Output: [1,2,4]</span><br><span class=\"line\">&gt; Explanation: The array represents the integer 123.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [4,3,2,1]</span><br><span class=\"line\">&gt; Output: [4,3,2,2]</span><br><span class=\"line\">&gt; Explanation: The array represents the integer 4321.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] plusOne(<span class=\"keyword\">int</span>[] digits) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = digits.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            digits[i]++;</span><br><span class=\"line\">            digits[i] %= <span class=\"number\">10</span>;</span><br><span class=\"line\">            <span class=\"comment\">//若进位则继续遍历，若不进位则直接返回</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (digits[i] != <span class=\"number\">0</span>) <span class=\"keyword\">return</span> digits;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//only 99,999...need one more digit</span></span><br><span class=\"line\">        digits = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[digits.length+<span class=\"number\">1</span>];</span><br><span class=\"line\">        digits[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> digits;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"73-Set-Matrix-Zeros-Medium\"><a href=\"#73-Set-Matrix-Zeros-Medium\" class=\"headerlink\" title=\"73. Set Matrix Zeros (Medium) @\"></a>73. Set Matrix Zeros (Medium) <a href=\"https://leetcode.com/problems/set-matrix-zeroes/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a <em>m</em> x <em>n</em> matrix, if an element is 0, set its entire row and column to 0. Do it <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\" rel=\"noopener\"><strong>in-place</strong></a>.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: </span><br><span class=\"line\">&gt; [</span><br><span class=\"line\">&gt; [1,1,1],</span><br><span class=\"line\">&gt; [1,0,1],</span><br><span class=\"line\">&gt; [1,1,1]</span><br><span class=\"line\">&gt; ]</span><br><span class=\"line\">&gt; Output: </span><br><span class=\"line\">&gt; [</span><br><span class=\"line\">&gt; [1,0,1],</span><br><span class=\"line\">&gt; [0,0,0],</span><br><span class=\"line\">&gt; [1,0,1]</span><br><span class=\"line\">&gt; ]</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: </span><br><span class=\"line\">&gt; [</span><br><span class=\"line\">&gt; [0,1,2,0],</span><br><span class=\"line\">&gt; [3,4,5,2],</span><br><span class=\"line\">&gt; [1,3,1,5]</span><br><span class=\"line\">&gt; ]</span><br><span class=\"line\">&gt; Output: </span><br><span class=\"line\">&gt; [</span><br><span class=\"line\">&gt; [0,0,0,0],</span><br><span class=\"line\">&gt; [0,4,5,0],</span><br><span class=\"line\">&gt; [0,3,1,0]</span><br><span class=\"line\">&gt; ]</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Follow up:</strong></p>\n<ul>\n<li>A straight forward solution using O(<em>m**n</em>) space is probably a bad idea.</li>\n<li>A simple improvement uses O(<em>m</em> + <em>n</em>) space, but still not the best solution.</li>\n<li>Could you devise a constant space solution?</li>\n</ul>\n</blockquote>\n<p>Solution </p>\n<ul>\n<li>Use first row and first column to mark if the row/col needs to be set to 0. (Postpone the change)<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setZeroes</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] matrix)</span> </span>&#123;</span><br><span class=\"line\">    Boolean isCol = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> R = matrix.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> C = matrix[<span class=\"number\">0</span>].length;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; R; i++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// Since first cell for both first row and first column is the same i.e. matrix[0][0]</span></span><br><span class=\"line\">      <span class=\"comment\">// We can use an additional variable for either the first row/column.</span></span><br><span class=\"line\">      <span class=\"comment\">// For this solution we are using an additional variable for the first column</span></span><br><span class=\"line\">      <span class=\"comment\">// and using matrix[0][0] for the first row.</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (matrix[i][<span class=\"number\">0</span>] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        isCol = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; C; j++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// If an element is zero, we set the first element of the corresponding row and column to 0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (matrix[i][j] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          matrix[<span class=\"number\">0</span>][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">          matrix[i][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Iterate over the array once again and using the first row and first column, update the elements.</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; R; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; C; j++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (matrix[i][<span class=\"number\">0</span>] == <span class=\"number\">0</span> || matrix[<span class=\"number\">0</span>][j] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          matrix[i][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// See if the first row needs to be set to zero as well</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (matrix[<span class=\"number\">0</span>][<span class=\"number\">0</span>] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; C; j++) &#123;</span><br><span class=\"line\">        matrix[<span class=\"number\">0</span>][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// See if the first column needs to be set to zero as well</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isCol) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; R; i++) &#123;</span><br><span class=\"line\">        matrix[i][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"75-Sort-Colors-Medium\"><a href=\"#75-Sort-Colors-Medium\" class=\"headerlink\" title=\"75. Sort Colors (Medium) @\"></a>75. Sort Colors (Medium) <a href=\"https://leetcode.com/problems/sort-colors/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given an array with <em>n</em> objects colored red, white or blue, sort them <strong><a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\" rel=\"noopener\">in-place</a></strong> so that objects of the same color are adjacent, with the colors in the order red, white and blue.</p>\n<p>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p>\n<p><strong>Note:</strong> You are not suppose to use the library’s sort function for this problem.</p>\n<p><strong>Example:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [2,0,2,1,1,0]</span><br><span class=\"line\">&gt; Output: [0,0,1,1,2,2]</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Follow up:</strong></p>\n<ul>\n<li>A rather straight forward solution is a two-pass algorithm using counting sort.<br>First, iterate the array counting number of 0’s, 1’s, and 2’s, then overwrite array with total number of 0’s, then 1’s and followed by 2’s.</li>\n<li>Could you come up with a one-pass algorithm using only constant space?</li>\n</ul>\n</blockquote>\n<p>Solution</p>\n<ul>\n<li>red replace forward, blue replace backward <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sortColors</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> red = <span class=\"number\">0</span>, blue = nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (red &lt;= blue &amp;&amp; i &lt;= blue) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[i] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                swap(nums, red, i);</span><br><span class=\"line\">                red++;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[i] == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">                swap(nums, i, blue);</span><br><span class=\"line\">                blue--;</span><br><span class=\"line\">                i--; <span class=\"comment\">//re-evaluate current element</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp = nums[i];</span><br><span class=\"line\">        nums[i] = nums[j];</span><br><span class=\"line\">        nums[j] = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"88-Merge-Sorted-Array-Easy\"><a href=\"#88-Merge-Sorted-Array-Easy\" class=\"headerlink\" title=\"88. Merge Sorted Array (Easy) @\"></a>88. Merge Sorted Array (Easy) <a href=\"https://leetcode.com/problems/merge-sorted-array/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given two sorted integer arrays <em>nums1</em> and <em>nums2</em>, merge <em>nums2</em> into <em>nums1</em> as one sorted array.</p>\n<p><strong>Note:</strong></p>\n<ul>\n<li>The number of elements initialized in <em>nums1</em> and <em>nums2</em> are <em>m</em> and <em>n</em> respectively.</li>\n<li>You may assume that <em>nums1</em> has enough space (size that is greater or equal to <em>m</em> + <em>n</em>) to hold additional elements from <em>nums2</em>.</li>\n</ul>\n<p><strong>Example:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input:</span><br><span class=\"line\">&gt; nums1 = [1,2,3,0,0,0], m = 3</span><br><span class=\"line\">&gt; nums2 = [2,5,6],       n = 3</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; Output: [1,2,2,3,5,6]</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution</p>\n<ul>\n<li>从后向前扫描，添加大的元素<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums1, <span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span>[] nums2, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//two pointer for nums1 and nums2</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> ptr1 = m - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ptr2 = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">//pointer for insert position</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> p = m + n - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">//compare back forward</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (ptr1 &gt;= <span class=\"number\">0</span> &amp;&amp; ptr2 &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums1[ptr1] &gt; nums2[ptr2]) &#123;</span><br><span class=\"line\">                nums1[p--] = nums1[ptr1--];</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                nums1[p--] = nums2[ptr2--];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//add remaining nums in nums2</span></span><br><span class=\"line\">        <span class=\"comment\">//public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</span></span><br><span class=\"line\">        System.arraycopy(nums2, <span class=\"number\">0</span>, nums1, <span class=\"number\">0</span>, ptr2 + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"118-Pascal‘s-Triangle-Easy\"><a href=\"#118-Pascal‘s-Triangle-Easy\" class=\"headerlink\" title=\"118. Pascal‘s Triangle (Easy) @\"></a>118. Pascal‘s Triangle (Easy) <a href=\"https://leetcode.com/problems/pascals-triangle/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a non-negative integer <em>numRows</em>, generate the first <em>numRows</em> of Pascal’s triangle.</p>\n<p>In Pascal’s triangle, each number is the sum of the two numbers directly above it.</p>\n<p><strong>Example:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: 5</span><br><span class=\"line\">&gt; Output:</span><br><span class=\"line\">&gt; [</span><br><span class=\"line\">&gt;   [1],</span><br><span class=\"line\">&gt;  [1,1],</span><br><span class=\"line\">&gt; [1,2,1],</span><br><span class=\"line\">&gt; [1,3,3,1],</span><br><span class=\"line\">&gt; [1,4,6,4,1]</span><br><span class=\"line\">&gt; ]</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution DP</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; generate(<span class=\"keyword\">int</span> numRows) &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; triangle = <span class=\"keyword\">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// First base case; if user requests zero rows, they get zero rows.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (numRows == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> triangle;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Second base case; first row is always [1].</span></span><br><span class=\"line\">        triangle.add(<span class=\"keyword\">new</span> ArrayList&lt;&gt;());</span><br><span class=\"line\">        triangle.get(<span class=\"number\">0</span>).add(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> rowNum = <span class=\"number\">1</span>; rowNum &lt; numRows; rowNum++) &#123;</span><br><span class=\"line\">            List&lt;Integer&gt; row = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(Integer);</span><br><span class=\"line\">            List&lt;Integer&gt; prevRow = triangle.get(rowNum-<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// The first row element is always 1.</span></span><br><span class=\"line\">            row.add(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Each triangle element (other than the first and last of each row)</span></span><br><span class=\"line\">            <span class=\"comment\">// is equal to the sum of the elements above-and-to-the-left and</span></span><br><span class=\"line\">            <span class=\"comment\">// above-and-to-the-right.</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; rowNum; j++) &#123;</span><br><span class=\"line\">                row.add(prevRow.get(j-<span class=\"number\">1</span>) + prevRow.get(j));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// The last row element is always 1.</span></span><br><span class=\"line\">            row.add(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            triangle.add(row);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> triangle;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"136-Single-Number-Easy\"><a href=\"#136-Single-Number-Easy\" class=\"headerlink\" title=\"136. Single Number (Easy) @\"></a>136. Single Number (Easy) <a href=\"https://leetcode.com/problems/single-number/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a <strong>non-empty</strong> array of integers, every element appears <em>twice</em> except for one. Find that single one.</p>\n<p><strong>Note:</strong></p>\n<p>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [2,2,1]</span><br><span class=\"line\">&gt; Output: 1</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [4,1,2,1,2]</span><br><span class=\"line\">&gt; Output: 4</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution 1 Hash Map</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">singleNumber</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        HashMap&lt;Integer, Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> num : nums) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (map.containsKey(num)) &#123;</span><br><span class=\"line\">                map.remove(num);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                map.put(num, <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> map.entrySet().iterator().next().getKey();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 2 Math</p>\n<ul>\n<li>所有不重复数字的两倍乘总和 - 原数组总和 = 出现一次的数字<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">singleNumber</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        Set&lt;Integer&gt; set = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> arrSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> num : nums) &#123;</span><br><span class=\"line\">            set.add(num);</span><br><span class=\"line\">            arrSum += num;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> doubleSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> num : set) &#123;</span><br><span class=\"line\">            doubleSum += <span class=\"number\">2</span>*num;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> doubleSum - arrSum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>Solution 3 Bit Manipulation</p>\n<ul>\n<li>异或XOR</li>\n<li>对所有数字进行异或，最后得出单个的数</li>\n<li>异或性质<ul>\n<li>交换律: A XOR B = B XOR A</li>\n<li>结合律: A XOR B XOR C = A XOR (B XOR C) = (A XOR B) XOR C</li>\n<li>自反性: A XOR B XOR B = A XOR 0 = A<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">singleNumber</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> num : nums) &#123;</span><br><span class=\"line\">            res ^= num;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"169-Majority-Element-Easy\"><a href=\"#169-Majority-Element-Easy\" class=\"headerlink\" title=\"169. Majority Element (Easy) @\"></a>169. Majority Element (Easy) <a href=\"https://leetcode.com/problems/majority-element/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given an array of size <em>n</em>, find the majority element. The majority element is the element that appears <strong>more than</strong> <code>⌊ n/2 ⌋</code> times.</p>\n<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [3,2,3]</span><br><span class=\"line\">&gt; Output: 3</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [2,2,1,1,1,2,2]</span><br><span class=\"line\">&gt; Output: 2</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution 1 HashMap</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">majorityElement</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        HashMap&lt;Integer, Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> N = nums.length;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; N; i++) &#123;</span><br><span class=\"line\">            map.put(nums[i], map.getOrDefault(nums[i], <span class=\"number\">0</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Map.Entry&lt;Integer,Integer&gt; s : map.entrySet()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s.getValue() &gt; N/<span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">                res = s.getKey();</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 2 Sort</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">majorityElement</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        Arrays.sort(nums);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums[nums.length/<span class=\"number\">2</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 3 摩尔投票法</p>\n<ul>\n<li>首先假定数组头元素即为众数，设定计数器为1，从第二个数开始遍历，如果和头元素相同则计数器加1，如果不相同则减1，之后判断计数器是否为0，如果不为0则继续下一步循环，如果为0则将众数指针指向当前元素，以此类推，最后众数指针指向的元素即为众数，时间复杂度～O(n)，空间复杂度～O(1)</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">majorityElement</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[i] == res) count++;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                count--;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (count == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    res = nums[i];</span><br><span class=\"line\">                    count = <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"189-Rotate-Array-Easy\"><a href=\"#189-Rotate-Array-Easy\" class=\"headerlink\" title=\"189. Rotate Array (Easy) @\"></a>189. Rotate Array (Easy) <a href=\"https://leetcode.com/problems/rotate-array/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given an array, rotate the array to the right by <em>k</em> steps, where <em>k</em> is non-negative.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [1,2,3,4,5,6,7] and k = 3</span><br><span class=\"line\">&gt; Output: [5,6,7,1,2,3,4]</span><br><span class=\"line\">&gt; Explanation:</span><br><span class=\"line\">&gt; rotate 1 steps to the right: [7,1,2,3,4,5,6]</span><br><span class=\"line\">&gt; rotate 2 steps to the right: [6,7,1,2,3,4,5]</span><br><span class=\"line\">&gt; rotate 3 steps to the right: [5,6,7,1,2,3,4]</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [-1,-100,3,99] and k = 2</span><br><span class=\"line\">&gt; Output: [3,99,-1,-100]</span><br><span class=\"line\">&gt; Explanation: </span><br><span class=\"line\">&gt; rotate 1 steps to the right: [99,-1,-100,3]</span><br><span class=\"line\">&gt; rotate 2 steps to the right: [3,99,-1,-100]</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Note:</strong></p>\n<ul>\n<li>Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.</li>\n<li>Could you do it in-place with O(1) extra space?</li>\n</ul>\n</blockquote>\n<p>Solution 1 Extra Array</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rotate</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> N = nums.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] temp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[N];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; N; i++) &#123;</span><br><span class=\"line\">            temp[(i+k) % N] = nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; N; i++) &#123;</span><br><span class=\"line\">            nums[i] = temp[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 2 Cyclic Replacements</p>\n<ul>\n<li><a href=\"https://leetcode-cn.com/problems/rotate-array/solution/xuan-zhuan-shu-zu-by-leetcode/\" target=\"_blank\" rel=\"noopener\">Leetcode CN</a></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rotate</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> start = <span class=\"number\">0</span>; count &lt; nums.length; start++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> cur = start;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> prev = nums[cur];</span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> next = (cur + k) % nums.length;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> temp = nums[next];</span><br><span class=\"line\">                nums[next] = prev;</span><br><span class=\"line\">                prev = temp;</span><br><span class=\"line\">                cur = next;</span><br><span class=\"line\">                count++;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">while</span> (start != cur);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 3 Reverse</p>\n<ul>\n<li>先反转所有，再分别反转前k个位置和后面所有<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rotate</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        k %= nums.length;</span><br><span class=\"line\">        reverse(nums, <span class=\"number\">0</span>, nums.length - <span class=\"number\">1</span>);</span><br><span class=\"line\">        reverse(nums, <span class=\"number\">0</span>, k - <span class=\"number\">1</span>);</span><br><span class=\"line\">        reverse(nums, k, nums.length - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">reverse</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> end)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (start &lt; end) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> temp = nums[start];</span><br><span class=\"line\">            nums[start] = nums[end];</span><br><span class=\"line\">            nums[end] = temp;</span><br><span class=\"line\">            start++;</span><br><span class=\"line\">            end--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"Linked-List\"><a href=\"#Linked-List\" class=\"headerlink\" title=\"Linked List\"></a>Linked List</h2><h3 id=\"138-Copy-List-with-Random-Pointer-Medium\"><a href=\"#138-Copy-List-with-Random-Pointer-Medium\" class=\"headerlink\" title=\"138. Copy List with Random Pointer (Medium) @\"></a>138. Copy List with Random Pointer (Medium) <a href=\"https://leetcode.com/problems/copy-list-with-random-pointer/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p>\n<p>Return a <a href=\"https://en.wikipedia.org/wiki/Object_copying#Deep_copy\" target=\"_blank\" rel=\"noopener\"><strong>deep copy</strong></a> of the list.</p>\n<p>The Linked List is represented in the input/output as a list of <code>n</code> nodes. Each node is represented as a pair of <code>[val, random_index]</code> where:</p>\n<ul>\n<li><code>val</code>: an integer representing <code>Node.val</code></li>\n<li><code>random_index</code>: the index of the node (range from <code>0</code> to <code>n-1</code>) where random pointer points to, or <code>null</code> if it does not point to any node.</li>\n</ul>\n<p><strong>Example 1:</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2019/12/18/e1.png\" alt=\"img\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class=\"line\">&gt; Output: [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2019/12/18/e2.png\" alt=\"img\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: head = [[1,1],[2,1]]</span><br><span class=\"line\">&gt; Output: [[1,1],[2,1]]</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 3:</strong></p>\n<p><strong><img src=\"https://assets.leetcode.com/uploads/2019/12/18/e3.png\" alt=\"img\"></strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: head = [[3,null],[3,0],[3,null]]</span><br><span class=\"line\">&gt; Output: [[3,null],[3,0],[3,null]]</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 4:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: head = []</span><br><span class=\"line\">&gt; Output: []</span><br><span class=\"line\">&gt; Explanation: Given linked list is empty (null pointer), so return null.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution 1 HashMap + 2 iterations </p>\n<p>第一种方法，就是使用HashMap来坐，HashMap的key存原始pointer，value存新的pointer。</p>\n<ul>\n<li>第一遍，先不copy random的值，只copy数值建立好新的链表。并把新旧pointer存在HashMap中。</li>\n<li>第二遍，遍历旧表，复制random的值，因为第一遍已经把链表复制好了并且也存在HashMap里了，所以只需从HashMap中，把当前旧的node.random作为key值，得到新的value的值，并把其赋给新node.random就好。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">// Definition for a Node.</span></span><br><span class=\"line\"><span class=\"comment\">class Node &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    int val;</span></span><br><span class=\"line\"><span class=\"comment\">    Node next;</span></span><br><span class=\"line\"><span class=\"comment\">    Node random;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    public Node(int val) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        this.val = val;</span></span><br><span class=\"line\"><span class=\"comment\">        this.next = null;</span></span><br><span class=\"line\"><span class=\"comment\">        this.random = null;</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Node <span class=\"title\">copyRandomList</span><span class=\"params\">(Node head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        HashMap&lt;Node, Node&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        Node newHead = <span class=\"keyword\">new</span> Node(head.val);</span><br><span class=\"line\">        map.put(head, newHead);</span><br><span class=\"line\">        Node oldPtr = head.next;</span><br><span class=\"line\">        Node newPtr = newHead;</span><br><span class=\"line\">        <span class=\"comment\">//first iterate the linked list</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (oldPtr != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//link next node</span></span><br><span class=\"line\">            Node newNode = <span class=\"keyword\">new</span> Node(oldPtr.val);</span><br><span class=\"line\">            newPtr.next = newNode;</span><br><span class=\"line\">            <span class=\"comment\">//update hashmap</span></span><br><span class=\"line\">            map.put(oldPtr, newNode);</span><br><span class=\"line\">            </span><br><span class=\"line\">            oldPtr = oldPtr.next;</span><br><span class=\"line\">            newPtr = newPtr.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        oldPtr = head;</span><br><span class=\"line\">        newPtr = newHead;</span><br><span class=\"line\">        <span class=\"comment\">//second iterate the linked list -&gt; update random ptr</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(oldPtr != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//update random ptr of new list</span></span><br><span class=\"line\">            newPtr.random = map.get(oldPtr.random);</span><br><span class=\"line\">            </span><br><span class=\"line\">            oldPtr = oldPtr.next;</span><br><span class=\"line\">            newPtr = newPtr.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> newHead;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 2 3-iteration</p>\n<p>第二种方法不使用HashMap来做，使空间复杂度降为O(1)，不过需要3次遍历list，时间复杂度为O(3n)=O(n)。</p>\n<ul>\n<li>第一遍，对每个node进行复制，并插入其原始node的后面，新旧交替，变成重复链表。如：原始：1-&gt;2-&gt;3-&gt;null，复制后：1-&gt;1-&gt;2-&gt;2-&gt;3-&gt;3-&gt;null</li>\n<li>第二遍，遍历每个旧node，把旧node的random的复制给新node的random，因为链表已经是新旧交替的。所以复制方法为：<strong>node.next.random = node.random.next</strong> 前面是说旧node的next的random，就是新node的random，后面是旧node的random的next，正好是新node，是从旧random复制来的。</li>\n<li>第三遍，则是把新旧两个表拆开，返回新的表即可。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">// Definition for a Node.</span></span><br><span class=\"line\"><span class=\"comment\">class Node &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    int val;</span></span><br><span class=\"line\"><span class=\"comment\">    Node next;</span></span><br><span class=\"line\"><span class=\"comment\">    Node random;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    public Node(int val) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        this.val = val;</span></span><br><span class=\"line\"><span class=\"comment\">        this.next = null;</span></span><br><span class=\"line\"><span class=\"comment\">        this.random = null;</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Node <span class=\"title\">copyRandomList</span><span class=\"params\">(Node head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        Node cur = head;</span><br><span class=\"line\">        <span class=\"comment\">//1st iteration: copy current node and link it to next</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            Node newNode = <span class=\"keyword\">new</span> Node(cur.val);</span><br><span class=\"line\">            newNode.next = cur.next;</span><br><span class=\"line\">            cur.next = newNode;</span><br><span class=\"line\">            </span><br><span class=\"line\">            cur = newNode.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//2ed iteration: update random node</span></span><br><span class=\"line\">        cur = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cur.random != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                cur.next.random = cur.random.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cur = cur.next.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//3rd iteration: </span></span><br><span class=\"line\">        cur = head; <span class=\"comment\">//point to old node</span></span><br><span class=\"line\">        Node newHead = head.next;<span class=\"comment\">//initialize new head</span></span><br><span class=\"line\">        Node copy = newHead;<span class=\"comment\">//point to new node</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// method 1</span></span><br><span class=\"line\"><span class=\"comment\">//         while (copy.next != null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//             //old</span></span><br><span class=\"line\"><span class=\"comment\">//             cur.next = cur.next.next;</span></span><br><span class=\"line\"><span class=\"comment\">//             cur = cur.next;</span></span><br><span class=\"line\">            </span><br><span class=\"line\"><span class=\"comment\">//             //new</span></span><br><span class=\"line\"><span class=\"comment\">//             copy.next = copy.next.next;</span></span><br><span class=\"line\"><span class=\"comment\">//             copy = copy.next;</span></span><br><span class=\"line\"><span class=\"comment\">//         &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//         cur.next = cur.next.next;</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//method 2</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            copy = cur.next;</span><br><span class=\"line\">            cur.next = copy.next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (copy.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                copy.next = copy.next.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cur = cur.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> newHead;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"141-Linked-List-Cycle-Easy\"><a href=\"#141-Linked-List-Cycle-Easy\" class=\"headerlink\" title=\"141. Linked List Cycle (Easy) @\"></a>141. Linked List Cycle (Easy) <a href=\"https://leetcode.com/problems/linked-list-cycle/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a linked list, determine if it has a cycle in it.</p>\n<p>To represent a cycle in the given linked list, we use an integer <code>pos</code> which represents the position (0-indexed) in the linked list where tail connects to. If <code>pos</code> is <code>-1</code>, then there is no cycle in the linked list.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: head = [3,2,0,-4], pos = 1</span><br><span class=\"line\">&gt; Output: true</span><br><span class=\"line\">&gt; Explanation: There is a cycle in the linked list, where tail connects to the second node.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><img src=\"https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png\" alt=\"img\"></p>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: head = [1,2], pos = 0</span><br><span class=\"line\">&gt; Output: true</span><br><span class=\"line\">&gt; Explanation: There is a cycle in the linked list, where tail connects to the first node.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><img src=\"https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png\" alt=\"img\"></p>\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: head = [1], pos = -1</span><br><span class=\"line\">&gt; Output: false</span><br><span class=\"line\">&gt; Explanation: There is no cycle in the linked list.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><img src=\"https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png\" alt=\"img\"></p>\n<p><strong>Follow up:</strong></p>\n<p>Can you solve it using <em>O(1)</em> (i.e. constant) memory?</p>\n</blockquote>\n<p>Solution 1 HashSet</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasCycle</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">    Set&lt;ListNode&gt; nodesSeen = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (head != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nodesSeen.contains(head)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            nodesSeen.add(head);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        head = head.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 2 Two ptrs</p>\n<ul>\n<li>if slow and fast ptr meet then it much contains a cycle.<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         val = x;</span></span><br><span class=\"line\"><span class=\"comment\"> *         next = null;</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasCycle</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span> || head.next == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        ListNode slow = head;</span><br><span class=\"line\">        ListNode fast = head.next;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (slow != fast) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (fast == <span class=\"keyword\">null</span> || fast.next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            fast = fast.next.next;</span><br><span class=\"line\">            slow = slow.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"146-LRU-Cache-Medium\"><a href=\"#146-LRU-Cache-Medium\" class=\"headerlink\" title=\"146. LRU Cache (Medium) @\"></a>146. LRU Cache (Medium) <a href=\"https://leetcode.com/problems/lru-cache/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Design and implement a data structure for <a href=\"https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU\" target=\"_blank\" rel=\"noopener\">Least Recently Used (LRU) cache</a>. It should support the following operations: <code>get</code> and <code>put</code>.</p>\n<p><code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br><code>put(key, value)</code> - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</p>\n<p>The cache is initialized with a <strong>positive</strong> capacity.</p>\n<p><strong>Follow up:</strong><br>Could you do both operations in <strong>O(1)</strong> time complexity?</p>\n<p><strong>Example:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; LRUCache cache = new LRUCache( 2 /* capacity */ );</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; cache.put(1, 1);</span><br><span class=\"line\">&gt; cache.put(2, 2);</span><br><span class=\"line\">&gt; cache.get(1);       // returns 1</span><br><span class=\"line\">&gt; cache.put(3, 3);    // evicts key 2</span><br><span class=\"line\">&gt; cache.get(2);       // returns -1 (not found)</span><br><span class=\"line\">&gt; cache.put(4, 4);    // evicts key 1</span><br><span class=\"line\">&gt; cache.get(1);       // returns -1 (not found)</span><br><span class=\"line\">&gt; cache.get(3);       // returns 3</span><br><span class=\"line\">&gt; cache.get(4);       // returns 4</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution 1 LinkedHashMap</p>\n<ul>\n<li><a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html\" target=\"_blank\" rel=\"noopener\">LinkedHashMap</a></li>\n<li>LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder)</li>\n<li>作为一般规则，默认负载因子（0.75）在时间和空间成本上提供了很好的折衷。较高的值会降低空间开销，但提高查找成本（体现在大多数的HashMap类的操作，包括get和put）。设置初始大小时，应该考虑预计的entry数在map及其负载系数，并且尽量减少rehash操作的次数。如果初始容量大于最大条目数除以负载因子，rehash操作将不会发生。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LRUCache</span> <span class=\"keyword\">extends</span> <span class=\"title\">LinkedHashMap</span>&lt;<span class=\"title\">Integer</span>, <span class=\"title\">Integer</span>&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> capacity;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LRUCache</span><span class=\"params\">(<span class=\"keyword\">int</span> capacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(capacity, <span class=\"number\">0.75F</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.capacity = capacity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.getOrDefault(key, -<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(<span class=\"keyword\">int</span> key, <span class=\"keyword\">int</span> value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.put(key, value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">removeEldestEntry</span><span class=\"params\">(Map.Entry&lt;Integer, Integer&gt; eldest)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> size() &gt; capacity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * LRUCache obj = new LRUCache(capacity);</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_1 = obj.get(key);</span></span><br><span class=\"line\"><span class=\"comment\"> * obj.put(key,value);</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n<p>Solution 2 Linked List + HashMap (implementation of sol 1)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LRUCache</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DLinkedNode</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> key;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> val;</span><br><span class=\"line\">        DLinkedNode prev;</span><br><span class=\"line\">        DLinkedNode next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">addNode</span><span class=\"params\">(DLinkedNode node)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//always add node right after head</span></span><br><span class=\"line\">        node.next = head.next;</span><br><span class=\"line\">        node.prev = head;</span><br><span class=\"line\">        </span><br><span class=\"line\">        head.next.prev = node;</span><br><span class=\"line\">        head.next = node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">removeNode</span><span class=\"params\">(DLinkedNode node)</span> </span>&#123;</span><br><span class=\"line\">        node.prev.next = node.next;</span><br><span class=\"line\">        node.next.prev = node.prev;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">moveToHead</span><span class=\"params\">(DLinkedNode node)</span> </span>&#123;</span><br><span class=\"line\">        removeNode(node);</span><br><span class=\"line\">        addNode(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> DLinkedNode <span class=\"title\">popTail</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        DLinkedNode res = tail.prev;</span><br><span class=\"line\">        removeNode(res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> HashMap&lt;Integer, DLinkedNode&gt; cache = <span class=\"keyword\">new</span> HashMap&lt;Integer, DLinkedNode&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> capacity;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> DLinkedNode head, tail;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LRUCache</span><span class=\"params\">(<span class=\"keyword\">int</span> capacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.size = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.capacity = capacity;</span><br><span class=\"line\">        </span><br><span class=\"line\">        head = <span class=\"keyword\">new</span> DLinkedNode();</span><br><span class=\"line\">        tail = <span class=\"keyword\">new</span> DLinkedNode();</span><br><span class=\"line\">        </span><br><span class=\"line\">        head.next = tail;</span><br><span class=\"line\">        tail.prev = head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> key)</span> </span>&#123;</span><br><span class=\"line\">        DLinkedNode node = cache.get(key);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node == <span class=\"keyword\">null</span>) </span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//used =&gt; move to head</span></span><br><span class=\"line\">            moveToHead(node);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> node.val;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(<span class=\"keyword\">int</span> key, <span class=\"keyword\">int</span> value)</span> </span>&#123;</span><br><span class=\"line\">        DLinkedNode node = cache.get(key);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            DLinkedNode newNode = <span class=\"keyword\">new</span> DLinkedNode();</span><br><span class=\"line\">            newNode.key = key;</span><br><span class=\"line\">            newNode.val = value;</span><br><span class=\"line\">            </span><br><span class=\"line\">            cache.put(key, newNode);<span class=\"comment\">//update cache(HashMap)</span></span><br><span class=\"line\">            addNode(newNode); <span class=\"comment\">//update Linked List</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            size++;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (size &gt; capacity) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//pop tail</span></span><br><span class=\"line\">                DLinkedNode tail = popTail();</span><br><span class=\"line\">                cache.remove(tail.key);</span><br><span class=\"line\">                size--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//update val</span></span><br><span class=\"line\">            node.val = value;</span><br><span class=\"line\">            moveToHead(node);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * LRUCache obj = new LRUCache(capacity);</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_1 = obj.get(key);</span></span><br><span class=\"line\"><span class=\"comment\"> * obj.put(key,value);</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"148-Sort-List-Medium\"><a href=\"#148-Sort-List-Medium\" class=\"headerlink\" title=\"148. Sort List (Medium) @\"></a>148. Sort List (Medium) <a href=\"https://leetcode.com/problems/sort-list/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Sort a linked list in <em>O</em>(<em>n</em> log <em>n</em>) time using constant space complexity.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: 4-&gt;2-&gt;1-&gt;3</span><br><span class=\"line\">&gt; Output: 1-&gt;2-&gt;3-&gt;4</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: -1-&gt;5-&gt;3-&gt;4-&gt;0</span><br><span class=\"line\">&gt; Output: -1-&gt;0-&gt;3-&gt;4-&gt;5</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution 1 Merge sort</p>\n<ul>\n<li>空间复杂度O(logn)， 不符合要求<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">sortList</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span> || head.next == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//find the mid point</span></span><br><span class=\"line\">        ListNode slow = head, fast = head.next;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (fast != <span class=\"keyword\">null</span> &amp;&amp; fast.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            slow = slow.next;</span><br><span class=\"line\">            fast = fast.next.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//mid = slow</span></span><br><span class=\"line\">        ListNode tmp = slow.next;</span><br><span class=\"line\">        slow.next = <span class=\"keyword\">null</span>; <span class=\"comment\">//cut</span></span><br><span class=\"line\">        <span class=\"comment\">//divide</span></span><br><span class=\"line\">        ListNode left = sortList(head);</span><br><span class=\"line\">        ListNode right = sortList(tmp);</span><br><span class=\"line\">        <span class=\"comment\">//merge</span></span><br><span class=\"line\">        ListNode cur = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">        ListNode res = cur;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left != <span class=\"keyword\">null</span> &amp;&amp; right != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (left.val &lt; right.val) &#123;</span><br><span class=\"line\">                cur.next = left;</span><br><span class=\"line\">                left = left.next;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                cur.next = right;</span><br><span class=\"line\">                right = right.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cur = cur.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//add the rest of left or right part</span></span><br><span class=\"line\">        cur.next = left != <span class=\"keyword\">null</span> ? left : right;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>Solution 2 Iteration<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">sortList</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span> || head.next == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        </span><br><span class=\"line\">        ListNode dummy = <span class=\"keyword\">new</span> ListNode(-<span class=\"number\">1</span>);</span><br><span class=\"line\">        dummy.next = head;</span><br><span class=\"line\">        <span class=\"comment\">//len of list</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> length = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (head != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            length++;</span><br><span class=\"line\">            head = head.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        head = dummy.next;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//loop logn times</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; length; i+= i) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//list was divided into 4 parts:</span></span><br><span class=\"line\">            <span class=\"comment\">//1. already sorted; 2. left part of list to be sorted;</span></span><br><span class=\"line\">            <span class=\"comment\">//3. right part of list to be sorted; 4. unsorted part of list</span></span><br><span class=\"line\">            ListNode success = dummy;</span><br><span class=\"line\">            ListNode left = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            ListNode right = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (head != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                left = head;</span><br><span class=\"line\">                head = cutFromHead(head, i);</span><br><span class=\"line\">                right = head;</span><br><span class=\"line\">                head = cutFromHead(head, i);</span><br><span class=\"line\">                <span class=\"comment\">//merge sort left and right, put them after success, and update success</span></span><br><span class=\"line\">                success.next = mergeLists(left, right);</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (success.next != <span class=\"keyword\">null</span>) success = success.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            head = dummy.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dummy.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//cut the list from head with n-len and return (n+1)th node</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> ListNode <span class=\"title\">cutFromHead</span><span class=\"params\">(ListNode head, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (head != <span class=\"keyword\">null</span> &amp;&amp; --n &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            head = head.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        ListNode next = head.next;</span><br><span class=\"line\">        head.next = <span class=\"keyword\">null</span>; <span class=\"comment\">//cut</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//merge sort 2 lists</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> ListNode <span class=\"title\">mergeLists</span><span class=\"params\">(ListNode left, ListNode right)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> right;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (right == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">        </span><br><span class=\"line\">        ListNode dummy = <span class=\"keyword\">new</span> ListNode(-<span class=\"number\">1</span>);</span><br><span class=\"line\">        ListNode cur = dummy;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left != <span class=\"keyword\">null</span> &amp;&amp; right != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (left.val &lt; right.val) &#123;</span><br><span class=\"line\">                cur.next = left;</span><br><span class=\"line\">                left = left.next;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                cur.next = right;</span><br><span class=\"line\">                right = right.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cur = cur.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cur.next = left != <span class=\"keyword\">null</span> ? left : right;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dummy.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"160-Intersection-of-Two-Linked-Lists-Easy\"><a href=\"#160-Intersection-of-Two-Linked-Lists-Easy\" class=\"headerlink\" title=\"160. Intersection of Two Linked Lists (Easy) @\"></a>160. Intersection of Two Linked Lists (Easy) <a href=\"https://leetcode.com/problems/intersection-of-two-linked-lists/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Write a program to find the node at which the intersection of two singly linked lists begins.</p>\n<p>For example, the following two linked lists:</p>\n<p><a href=\"https://assets.leetcode.com/uploads/2018/12/13/160_statement.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://assets.leetcode.com/uploads/2018/12/13/160_statement.png\" alt=\"img\"></a></p>\n<p>begin to intersect at node c1.</p>\n<p><strong>Example 1:</strong></p>\n<p><a href=\"https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png\" alt=\"img\"></a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3</span><br><span class=\"line\">&gt; Output: Reference of the node with value = 8</span><br><span class=\"line\">&gt; Input Explanation: The intersected node&apos;s value is 8 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,0,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<p><a href=\"https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png\" alt=\"img\"></a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</span><br><span class=\"line\">&gt; Output: Reference of the node with value = 2</span><br><span class=\"line\">&gt; Input Explanation: The intersected node&apos;s value is 2 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [0,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 3:</strong></p>\n<p><a href=\"https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png\" alt=\"img\"></a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2</span><br><span class=\"line\">&gt; Output: null</span><br><span class=\"line\">&gt; Input Explanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.</span><br><span class=\"line\">&gt; Explanation: The two lists do not intersect, so return null.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Notes:</strong></p>\n<ul>\n<li>If the two linked lists have no intersection at all, return <code>null</code>.</li>\n<li>The linked lists must retain their original structure after the function returns.</li>\n<li>You may assume there are no cycles anywhere in the entire linked structure.</li>\n<li>Your code should preferably run in O(n) time and use only O(1) memory.</li>\n</ul>\n</blockquote>\n<p>Solution 1 Two round iteration</p>\n<ul>\n<li>尾部对齐，找出长度差，长的先走<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         val = x;</span></span><br><span class=\"line\"><span class=\"comment\"> *         next = null;</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">getIntersectionNode</span><span class=\"params\">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> lenA=<span class=\"number\">0</span>, lenB=<span class=\"number\">0</span>;</span><br><span class=\"line\">        ListNode A=headA, B=headB;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(A != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            lenA ++;</span><br><span class=\"line\">            A = A.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(B != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            lenB++;</span><br><span class=\"line\">            B = B.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        A = headA;</span><br><span class=\"line\">        B = headB;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(lenA &gt; lenB)&#123;</span><br><span class=\"line\">            A = A.next;</span><br><span class=\"line\">            lenA --;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(lenA &lt; lenB)&#123;</span><br><span class=\"line\">            B = B.next;</span><br><span class=\"line\">            lenB --;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(A != B)&#123;</span><br><span class=\"line\">            A = A.next;</span><br><span class=\"line\">            B = B.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> A;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>Solution 2 Two pointer + 环</p>\n<ul>\n<li>转化成判断环的问题<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         val = x;</span></span><br><span class=\"line\"><span class=\"comment\"> *         next = null;</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">getIntersectionNode</span><span class=\"params\">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (headA == <span class=\"keyword\">null</span> || headB == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        ListNode curA = headA;</span><br><span class=\"line\">        ListNode curB = headB;</span><br><span class=\"line\">        <span class=\"comment\">//将自身最后连接到另一个链表头，若存在intersection则形成环</span></span><br><span class=\"line\">        <span class=\"comment\">//如果形成环，则curA和curB一定在环的入口相交</span></span><br><span class=\"line\">        <span class=\"comment\">//若没有形成环，则都到达null</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (curA != curB) &#123;</span><br><span class=\"line\">            curA = curA == <span class=\"keyword\">null</span> ? headB : curA.next;</span><br><span class=\"line\">            curB = curB == <span class=\"keyword\">null</span> ? headA : curB.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> curA;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"Stack\"><a href=\"#Stack\" class=\"headerlink\" title=\"Stack\"></a>Stack</h2><h3 id=\"150-Evaluate-Reverse-Polish-Notation-Medium\"><a href=\"#150-Evaluate-Reverse-Polish-Notation-Medium\" class=\"headerlink\" title=\"150. Evaluate Reverse Polish Notation (Medium) @\"></a>150. Evaluate Reverse Polish Notation (Medium) <a href=\"https://leetcode.com/problems/evaluate-reverse-polish-notation/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Evaluate the value of an arithmetic expression in <a href=\"http://en.wikipedia.org/wiki/Reverse_Polish_notation\" target=\"_blank\" rel=\"noopener\">Reverse Polish Notation</a>.</p>\n<p>Valid operators are <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>. Each operand may be an integer or another expression.</p>\n<p><strong>Note:</strong></p>\n<ul>\n<li>Division between two integers should truncate toward zero.</li>\n<li>The given RPN expression is always valid. That means the expression would always evaluate to a result and there won’t be any divide by zero operation.</li>\n</ul>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]</span><br><span class=\"line\">&gt; Output: 9</span><br><span class=\"line\">&gt; Explanation: ((2 + 1) * 3) = 9</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]</span><br><span class=\"line\">&gt; Output: 6</span><br><span class=\"line\">&gt; Explanation: (4 + (13 / 5)) = 6</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]</span><br><span class=\"line\">&gt; Output: 22</span><br><span class=\"line\">&gt; Explanation: </span><br><span class=\"line\">&gt;   ((10 * (6 / ((9 + 3) * -11))) + 17) + 5</span><br><span class=\"line\">&gt; = ((10 * (6 / (12 * -11))) + 17) + 5</span><br><span class=\"line\">&gt; = ((10 * (6 / -132)) + 17) + 5</span><br><span class=\"line\">&gt; = ((10 * 0) + 17) + 5</span><br><span class=\"line\">&gt; = (0 + 17) + 5</span><br><span class=\"line\">&gt; = 17 + 5</span><br><span class=\"line\">&gt; = 22</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution 1 Stack<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">evalRPN</span><span class=\"params\">(String[] tokens)</span> </span>&#123;</span><br><span class=\"line\">        Stack&lt;Integer&gt; stack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String s : tokens) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s.equals(<span class=\"string\">\"+\"</span>)) &#123;</span><br><span class=\"line\">                stack.push(stack.pop() + stack.pop());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s.equals(<span class=\"string\">\"-\"</span>)) &#123;</span><br><span class=\"line\">                stack.push(- stack.pop() + stack.pop());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s.equals(<span class=\"string\">\"*\"</span>)) &#123;</span><br><span class=\"line\">                stack.push(stack.pop() * stack.pop());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s.equals(<span class=\"string\">\"/\"</span>)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> dividend = stack.pop();</span><br><span class=\"line\">                stack.push(stack.pop() / dividend);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">//normal numbers</span></span><br><span class=\"line\">                stack.push(Integer.parseInt(s));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> stack.pop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"155-Min-Stack-Medium\"><a href=\"#155-Min-Stack-Medium\" class=\"headerlink\" title=\"155. Min Stack (Medium) @\"></a>155. Min Stack (Medium) <a href=\"https://leetcode.com/problems/min-stack/submissions/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p>\n<ul>\n<li>push(x) – Push element x onto stack.</li>\n<li>pop() – Removes the element on top of the stack.</li>\n<li>top() – Get the top element.</li>\n<li>getMin() – Retrieve the minimum element in the stack.</li>\n</ul>\n<p><strong>Example:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; MinStack minStack = new MinStack();</span><br><span class=\"line\">&gt; minStack.push(-2);</span><br><span class=\"line\">&gt; minStack.push(0);</span><br><span class=\"line\">&gt; minStack.push(-3);</span><br><span class=\"line\">&gt; minStack.getMin();   --&gt; Returns -3.</span><br><span class=\"line\">&gt; minStack.pop();</span><br><span class=\"line\">&gt; minStack.top();      --&gt; Returns 0.</span><br><span class=\"line\">&gt; minStack.getMin();   --&gt; Returns -2.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution 1 synchronous data stack and helper stack<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MinStack</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> Stack&lt;Integer&gt; data;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Stack&lt;Integer&gt; minElement;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** initialize your data structure here. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MinStack</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        data = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">        minElement = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        data.add(x);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (minElement.isEmpty() || minElement.peek() &gt;= x) &#123;</span><br><span class=\"line\">            minElement.add(x);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            minElement.add(minElement.peek());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!data.isEmpty()) &#123;</span><br><span class=\"line\">            data.pop();</span><br><span class=\"line\">            minElement.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">top</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!data.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> data.peek();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"stack is empty\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getMin</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!minElement.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> minElement.peek();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"stack is empty\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * MinStack obj = new MinStack();</span></span><br><span class=\"line\"><span class=\"comment\"> * obj.push(x);</span></span><br><span class=\"line\"><span class=\"comment\"> * obj.pop();</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_3 = obj.top();</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_4 = obj.getMin();</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure></p>\n<p>Solution 2 asynchronous </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MinStack</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> Stack&lt;Integer&gt; data;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Stack&lt;Integer&gt; minElement;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** initialize your data structure here. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MinStack</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        data = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">        minElement = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 思路 2：辅助栈和数据栈不同步</span></span><br><span class=\"line\">    <span class=\"comment\">// 关键 1：辅助栈的元素空的时候，必须放入新进来的数</span></span><br><span class=\"line\">    <span class=\"comment\">// 关键 2：新来的数小于或者等于辅助栈栈顶元素的时候，才放入（特别注意这里等于要考虑进去）</span></span><br><span class=\"line\">    <span class=\"comment\">// 关键 3：出栈的时候，辅助栈的栈顶元素等于数据栈的栈顶元素，才出栈，即\"出栈保持同步\"就可以了</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        data.add(x);</span><br><span class=\"line\">        <span class=\"comment\">// 辅助栈在必要的时候才增加</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (minElement.isEmpty() || minElement.peek() &gt;= x) &#123;</span><br><span class=\"line\">            minElement.add(x);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//关键3: 数据栈一定pop</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!data.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 注意：声明成 int 类型，这里完成了自动拆箱，从 Integer 转成了 int，因此下面的比较可以使用 \"==\" 运算符</span></span><br><span class=\"line\">            <span class=\"comment\">// 参考资料：https://www.cnblogs.com/GuoYaxiang/p/6931264.html</span></span><br><span class=\"line\">            <span class=\"comment\">// 如果把 top 变量声明成 Integer 类型，下面的比较就得使用 equals 方法</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> top = data.pop();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (top == minElement.peek()) &#123;</span><br><span class=\"line\">                minElement.pop();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">top</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!data.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> data.peek();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"stack is empty\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getMin</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!minElement.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> minElement.peek();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"stack is empty\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * MinStack obj = new MinStack();</span></span><br><span class=\"line\"><span class=\"comment\"> * obj.push(x);</span></span><br><span class=\"line\"><span class=\"comment\"> * obj.pop();</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_3 = obj.top();</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_4 = obj.getMin();</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n<p>Solution 3 Linked List</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MinStack</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> Node head;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> val;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> min;</span><br><span class=\"line\">        Node next;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Node(<span class=\"keyword\">int</span> val, <span class=\"keyword\">int</span> min, Node next) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.val = val;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.min = min;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.next = next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            head = <span class=\"keyword\">new</span> Node(x, x, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            head = <span class=\"keyword\">new</span> Node(x, Math.min(head.min, x), head);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        head = head.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">top</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head.val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getMin</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head.min;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * MinStack obj = new MinStack();</span></span><br><span class=\"line\"><span class=\"comment\"> * obj.push(x);</span></span><br><span class=\"line\"><span class=\"comment\"> * obj.pop();</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_3 = obj.top();</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_4 = obj.getMin();</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Math\"><a href=\"#Math\" class=\"headerlink\" title=\"Math\"></a>Math</h2><h3 id=\"172-Factorial-Trailing-Zeroes-Easy\"><a href=\"#172-Factorial-Trailing-Zeroes-Easy\" class=\"headerlink\" title=\"172. Factorial Trailing Zeroes (Easy) @\"></a>172. Factorial Trailing Zeroes (Easy) <a href=\"https://leetcode.com/problems/factorial-trailing-zeroes/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given an integer <em>n</em>, return the number of trailing zeroes in <em>n</em>!.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: 3</span><br><span class=\"line\">&gt; Output: 0</span><br><span class=\"line\">&gt; Explanation: 3! = 6, no trailing zero.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: 5</span><br><span class=\"line\">&gt; Output: 1</span><br><span class=\"line\">&gt; Explanation: 5! = 120, one trailing zero.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Note:</strong> Your solution should be in logarithmic time complexity.</p>\n</blockquote>\n<p>Solution </p>\n<ul>\n<li>判断n!中有多少个5</li>\n<li><a href=\"https://leetcode-cn.com/problems/factorial-trailing-zeroes/solution/xiang-xi-tong-su-de-si-lu-fen-xi-by-windliang-3/\" target=\"_blank\" rel=\"noopener\">Detail</a></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">trailingZeroes</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (n &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        count += n / <span class=\"number\">5</span>;</span><br><span class=\"line\">        n = n / <span class=\"number\">5</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"190-Reverse-Bits-Easy\"><a href=\"#190-Reverse-Bits-Easy\" class=\"headerlink\" title=\"190. Reverse Bits (Easy) @\"></a>190. Reverse Bits (Easy) <a href=\"https://leetcode.com/problems/reverse-bits/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Reverse bits of a given 32 bits unsigned integer.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: 00000010100101000001111010011100</span><br><span class=\"line\">&gt; Output: 00111001011110000010100101000000</span><br><span class=\"line\">&gt; Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: 11111111111111111111111111111101</span><br><span class=\"line\">&gt; Output: 10111111111111111111111111111111</span><br><span class=\"line\">&gt; Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Note:</strong></p>\n<ul>\n<li>Note that in some languages such as Java, there is no unsigned integer type. In this case, both input and output will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned.</li>\n<li>In Java, the compiler represents the signed integers using <a href=\"https://en.wikipedia.org/wiki/Two&#39;s_complement\" target=\"_blank\" rel=\"noopener\">2’s complement notation</a>. Therefore, in <strong>Example 2</strong> above the input represents the signed integer <code>-3</code> and the output represents the signed integer <code>-1073741825</code>.</li>\n</ul>\n<p><strong>Follow up</strong>:</p>\n<p>If this function is called many times, how would you optimize it?</p>\n</blockquote>\n<p>Solution 1 shift</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// you need treat n as an unsigned value</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">reverseBits</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (count &lt; <span class=\"number\">32</span>) &#123;</span><br><span class=\"line\">            res &lt;&lt;= <span class=\"number\">1</span>; <span class=\"comment\">//res is shifted by 1 position to left</span></span><br><span class=\"line\">            res |= (n &amp; <span class=\"number\">1</span>); <span class=\"comment\">//just pick the last pos of n to OR res</span></span><br><span class=\"line\">            n &gt;&gt;= <span class=\"number\">1</span>; <span class=\"comment\">//n is shifted by 1 pos to right =&gt; get rid of the last pos</span></span><br><span class=\"line\">            count++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"191-Number-of-1-Bits-Easy\"><a href=\"#191-Number-of-1-Bits-Easy\" class=\"headerlink\" title=\"191. Number of 1 Bits (Easy) @\"></a>191. Number of 1 Bits (Easy) <a href=\"https://leetcode.com/problems/number-of-1-bits/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Write a function that takes an unsigned integer and return the number of ‘1’ bits it has (also known as the <a href=\"http://en.wikipedia.org/wiki/Hamming_weight\" target=\"_blank\" rel=\"noopener\">Hamming weight</a>).</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: 00000000000000000000000000001011</span><br><span class=\"line\">&gt; Output: 3</span><br><span class=\"line\">&gt; Explanation: The input binary string 00000000000000000000000000001011 has a total of three &apos;1&apos; bits.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: 00000000000000000000000010000000</span><br><span class=\"line\">&gt; Output: 1</span><br><span class=\"line\">&gt; Explanation: The input binary string 00000000000000000000000010000000 has a total of one &apos;1&apos; bit.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: 11111111111111111111111111111101</span><br><span class=\"line\">&gt; Output: 31</span><br><span class=\"line\">&gt; Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one &apos;1&apos; bits.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Note:</strong></p>\n<ul>\n<li>Note that in some languages such as Java, there is no unsigned integer type. In this case, the input will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned.</li>\n<li>In Java, the compiler represents the signed integers using <a href=\"https://en.wikipedia.org/wiki/Two&#39;s_complement\" target=\"_blank\" rel=\"noopener\">2’s complement notation</a>. Therefore, in <strong>Example 3</strong> above the input represents the signed integer <code>-3</code>.</li>\n</ul>\n<p><strong>Follow up</strong>:</p>\n<p>If this function is called many times, how would you optimize it?</p>\n</blockquote>\n<p>Solution 1</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// you need to treat n as an unsigned value</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hammingWeight</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">32</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((n &amp; <span class=\"number\">1</span>) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                res++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            n &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 2 Flip<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// you need to treat n as an unsigned value</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hammingWeight</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (n != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            res++;</span><br><span class=\"line\">            <span class=\"comment\">//always flip the least-significant 1-bit to 0</span></span><br><span class=\"line\">            n &amp;= (n - <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Graph\"><a href=\"#Graph\" class=\"headerlink\" title=\"Graph\"></a>Graph</h2><h2 id=\"Sliding-Window\"><a href=\"#Sliding-Window\" class=\"headerlink\" title=\"Sliding Window\"></a>Sliding Window</h2><h2 id=\"Partition\"><a href=\"#Partition\" class=\"headerlink\" title=\"Partition\"></a>Partition</h2>","site":{"data":{}},"excerpt":"","more":"<p>Sources:</p>\n<ol>\n<li>summer</li>\n<li>1-50</li>\n<li>Top Interview Questions (before 200)</li>\n</ol>\n<h2 id=\"DFS-memo\"><a href=\"#DFS-memo\" class=\"headerlink\" title=\"DFS + memo\"></a>DFS + memo</h2><h3 id=\"98-Validate-Binary-Search-Tree-Medium\"><a href=\"#98-Validate-Binary-Search-Tree-Medium\" class=\"headerlink\" title=\"98. Validate Binary Search Tree (Medium) @\"></a>98. Validate Binary Search Tree (Medium) <a href=\"https://leetcode.com/problems/validate-binary-search-tree/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a binary tree, determine if it is a valid binary search tree (BST).</p>\n<p>Assume a BST is defined as follows:</p>\n<ul>\n<li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node’s key.</li>\n<li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node’s key.</li>\n<li>Both the left and right subtrees must also be binary search trees.</li>\n</ul>\n</blockquote>\n<p><strong>Solution 1 Recursion</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">helper</span><span class=\"params\">(TreeNode node, Integer lower, Integer upper)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> val = node.val;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lower != <span class=\"keyword\">null</span> &amp;&amp; val &lt;= lower) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (upper != <span class=\"keyword\">null</span> &amp;&amp; val &gt;= upper) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!helper(node.left, lower, val)) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!helper(node.right, val, upper)) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isValidBST</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> helper(root, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>Solution 2 Iteration</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LinkedList&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> LinkedList();</span><br><span class=\"line\">LinkedList&lt;Integer&gt; uppers = <span class=\"keyword\">new</span> LinkedList(), lowers = <span class=\"keyword\">new</span> LinkedList();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(TreeNode root, Integer lower, Integer upper)</span> </span>&#123;</span><br><span class=\"line\">    stack.add(root);</span><br><span class=\"line\">    uppers.add(upper);</span><br><span class=\"line\">    lowers.add(lower);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isValidBST</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">    Integer lower = <span class=\"keyword\">null</span>, upper = <span class=\"keyword\">null</span>, val;</span><br><span class=\"line\">    update(root, lower, upper);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!stack.isEmpty()) &#123;</span><br><span class=\"line\">        root = stack.poll();</span><br><span class=\"line\">        lower = lowers.poll();</span><br><span class=\"line\">        upper = uppers.poll();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        val = root.val;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lower != <span class=\"keyword\">null</span> &amp;&amp; val &lt;= lower) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (upper != <span class=\"keyword\">null</span> &amp;&amp; val &gt;= upper) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        update(root.left, lower, val);</span><br><span class=\"line\">        update(root.right, val, upper);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>Solution 3 Inorder Traversal</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isValidBST</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">    Stack&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> Stack();</span><br><span class=\"line\">    <span class=\"keyword\">double</span> inorder = - Double.MAX_VALUE;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!stack.isEmpty() || root != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (root != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            stack.push(root);</span><br><span class=\"line\">            root = root.left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        root = stack.pop();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.val &lt;= inorder) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        inorder = root.val;</span><br><span class=\"line\">        root = root.right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"101-Symmetric-Tree-Easy\"><a href=\"#101-Symmetric-Tree-Easy\" class=\"headerlink\" title=\"101. Symmetric Tree (Easy) @\"></a>101. Symmetric Tree (Easy) <a href=\"https://leetcode.com/problems/symmetric-tree/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>\n<p>For example, this binary tree <code>[1,2,2,3,4,4,3]</code> is symmetric:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;  1</span><br><span class=\"line\">&gt; / \\</span><br><span class=\"line\">&gt; 2   2</span><br><span class=\"line\">&gt; / \\ / \\</span><br><span class=\"line\">&gt; 3  4 4  3</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p>But the following <code>[1,2,2,null,3,null,3]</code> is not:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;  1</span><br><span class=\"line\">&gt; / \\</span><br><span class=\"line\">&gt; 2   2</span><br><span class=\"line\">&gt; \\   \\</span><br><span class=\"line\">&gt; 3    3</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p><strong>Solution 1 Recursion</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isMirror</span><span class=\"params\">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t1 == <span class=\"keyword\">null</span> &amp;&amp; t2 == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t1 == <span class=\"keyword\">null</span> || t2 == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (t1.val == t2.val) &amp;&amp; isMirror(t1.right, t2.left) &amp;&amp; isMirror(t1.left, t2.right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isSymmetric</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> isMirror(root.left, root.right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>Solution 2 Iteration</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isSymmetric</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    Queue&lt;TreeNode&gt; q = <span class=\"keyword\">new</span> LinkedList();</span><br><span class=\"line\">    q.add(root.left);</span><br><span class=\"line\">    q.add(root.right);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!q.isEmpty()) &#123;</span><br><span class=\"line\">        TreeNode t1 = q.poll();</span><br><span class=\"line\">        TreeNode t2 = q.poll();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t1 == <span class=\"keyword\">null</span> &amp;&amp; t2 == <span class=\"keyword\">null</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t1 == <span class=\"keyword\">null</span> || t2 == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t1.val != t2.val) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        q.add(t1.left);</span><br><span class=\"line\">        q.add(t2.right);</span><br><span class=\"line\">        q.add(t1.right);</span><br><span class=\"line\">        q.add(t2.left);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"104-Maximum-Depth-of-Binary-Tree-Easy\"><a href=\"#104-Maximum-Depth-of-Binary-Tree-Easy\" class=\"headerlink\" title=\"104. Maximum Depth of Binary Tree (Easy) @\"></a>104. Maximum Depth of Binary Tree (Easy) <a href=\"https://leetcode.com/problems/maximum-depth-of-binary-tree/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a binary tree, find its maximum depth.</p>\n<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>\n<p><strong>Note:</strong> A leaf is a node with no children.</p>\n<p><strong>Example:</strong></p>\n<p>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;  3</span><br><span class=\"line\">&gt; / \\</span><br><span class=\"line\">&gt; 9  20</span><br><span class=\"line\">&gt;  /  \\</span><br><span class=\"line\">&gt; 15   7</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p>return its depth = 3.</p>\n</blockquote>\n<p><strong>Solution 1 Recursion</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxDepth</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>Solution 2 Iteration (BFS)</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxDepth</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        LinkedList&lt;TreeNode&gt; queue = <span class=\"keyword\">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> level = <span class=\"number\">0</span>;</span><br><span class=\"line\">        queue.add(root);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> curNum = <span class=\"number\">1</span>, nextNum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">            TreeNode node = queue.poll();</span><br><span class=\"line\">            curNum--;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node.left != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                nextNum++;</span><br><span class=\"line\">                queue.add(node.left);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node.right != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                nextNum++;</span><br><span class=\"line\">                queue.add(node.right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (curNum == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                curNum = nextNum;</span><br><span class=\"line\">                nextNum = <span class=\"number\">0</span>;</span><br><span class=\"line\">                level++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> level;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal-Medium\"><a href=\"#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal-Medium\" class=\"headerlink\" title=\"105.  Construct Binary Tree from Preorder and Inorder Traversal (Medium) @\"></a>105.  Construct Binary Tree from Preorder and Inorder Traversal (Medium) <a href=\"https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given preorder and inorder traversal of a tree, construct the binary tree.</p>\n<p><strong>Note:</strong><br>You may assume that duplicates do not exist in the tree.</p>\n<p>For example, given</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; preorder = [3,9,20,15,7]</span><br><span class=\"line\">&gt; inorder = [9,3,15,20,7]</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p>Return the following binary tree:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;  3</span><br><span class=\"line\">&gt; / \\</span><br><span class=\"line\">&gt; 9  20</span><br><span class=\"line\">&gt;  /  \\</span><br><span class=\"line\">&gt; 15   7</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p><strong>Solution Divide and Conquer + Recursion</strong> </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">buildTree</span><span class=\"params\">(<span class=\"keyword\">int</span>[] preorder, <span class=\"keyword\">int</span>[] inorder)</span> </span>&#123;</span><br><span class=\"line\">        TreeNode root = createTree(preorder, <span class=\"number\">0</span>, preorder.length-<span class=\"number\">1</span>, inorder, <span class=\"number\">0</span>, inorder.length-<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> TreeNode <span class=\"title\">createTree</span><span class=\"params\">(<span class=\"keyword\">int</span>[] preorder, <span class=\"keyword\">int</span> startPre, <span class=\"keyword\">int</span> endPre, <span class=\"keyword\">int</span>[] inorder, <span class=\"keyword\">int</span> startIn, <span class=\"keyword\">int</span> endIn)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (startPre &gt; endPre || startIn &gt; endIn) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        TreeNode root = <span class=\"keyword\">new</span> TreeNode(preorder[startPre]);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = startIn; i &lt;= endIn; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (inorder[i] == preorder[startPre]) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//i-startIn是左子树长度</span></span><br><span class=\"line\">                root.left = createTree(preorder, startPre + <span class=\"number\">1</span>, startPre + i - startIn, inorder, startIn, i-<span class=\"number\">1</span>);</span><br><span class=\"line\">                <span class=\"comment\">//右子树开始节点是从左子树开始节点加上左子树的长度</span></span><br><span class=\"line\">                root.right = createTree(preorder, startPre + <span class=\"number\">1</span> + i - startIn, endPre, inorder, i + <span class=\"number\">1</span>, endIn);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"108-Convert-Sorted-Array-to-Binary-Search-Tree-Easy\"><a href=\"#108-Convert-Sorted-Array-to-Binary-Search-Tree-Easy\" class=\"headerlink\" title=\"108. Convert Sorted Array to Binary Search Tree (Easy) @\"></a>108. Convert Sorted Array to Binary Search Tree (Easy) <a href=\"https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p>\n<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of <em>every</em> node never differ by more than 1.</p>\n<p><strong>Example:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Given the sorted array: [-10,-3,0,5,9],</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt;    0</span><br><span class=\"line\">&gt;   / \\</span><br><span class=\"line\">&gt; -3   9</span><br><span class=\"line\">&gt; /   /</span><br><span class=\"line\">&gt; -10  5</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p><strong>Solution 1 Recursion</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">sortedArrayToBST</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dfs(nums, <span class=\"number\">0</span>, nums.length-<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> TreeNode <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> end)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (start &gt; end) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = (start + end) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        TreeNode root = <span class=\"keyword\">new</span> TreeNode(nums[mid]);</span><br><span class=\"line\">        root.left = dfs(nums, start, mid - <span class=\"number\">1</span>);</span><br><span class=\"line\">        root.right = dfs(nums, mid + <span class=\"number\">1</span>, end);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"116-Populating-Next-Right-Pointers-in-Each-Node-Medium\"><a href=\"#116-Populating-Next-Right-Pointers-in-Each-Node-Medium\" class=\"headerlink\" title=\"116. Populating Next Right Pointers in Each Node (Medium) @\"></a>116. Populating Next Right Pointers in Each Node (Medium) <a href=\"https://leetcode.com/problems/populating-next-right-pointers-in-each-node/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>You are given a <strong>perfect binary tree</strong> where all leaves are on the same level, and every parent has two children.</p>\n<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p>\n<p>Initially, all next pointers are set to <code>NULL</code>.</p>\n<p><strong>Follow up:</strong></p>\n<ul>\n<li>You may only use constant extra space.</li>\n<li>Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem.</li>\n</ul>\n</blockquote>\n<p><strong>Solution 1 Recursion</strong></p>\n<p>这道题解法还是挺直白的，如果当前节点有左孩子，那么左孩子的next就指向右孩子。如果当前节点有右孩子，那么判断，如果当前节点的next是null，说明当前节点已经到了最右边，那么右孩子也是最右边的，所以右孩子指向null。如果当前节点的next不是null，那么当前节点的右孩子的next就需要指向当前节点next的左孩子。递归求解就好。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">// Definition for a Node.</span></span><br><span class=\"line\"><span class=\"comment\">class Node &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    public int val;</span></span><br><span class=\"line\"><span class=\"comment\">    public Node left;</span></span><br><span class=\"line\"><span class=\"comment\">    public Node right;</span></span><br><span class=\"line\"><span class=\"comment\">    public Node next;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    public Node() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">    </span></span><br><span class=\"line\"><span class=\"comment\">    public Node(int _val) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        val = _val;</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    public Node(int _val, Node _left, Node _right, Node _next) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        val = _val;</span></span><br><span class=\"line\"><span class=\"comment\">        left = _left;</span></span><br><span class=\"line\"><span class=\"comment\">        right = _right;</span></span><br><span class=\"line\"><span class=\"comment\">        next = _next;</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Node <span class=\"title\">connect</span><span class=\"params\">(Node root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.left != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            root.left.next = root.right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.right != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                root.right.next = root.next.left;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                root.right.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        connect(root.left);</span><br><span class=\"line\">        connect(root.right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"124-Binary-Tree-Maximum-Path-Sum-Hard\"><a href=\"#124-Binary-Tree-Maximum-Path-Sum-Hard\" class=\"headerlink\" title=\"124. Binary Tree Maximum Path Sum (Hard) @\"></a>124. Binary Tree Maximum Path Sum (Hard) <a href=\"https://leetcode.com/problems/binary-tree-maximum-path-sum/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a <strong>non-empty</strong> binary tree, find the maximum path sum.</p>\n<p>For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain <strong>at least one node</strong> and does not need to go through the root.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [1,2,3]</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt;     1</span><br><span class=\"line\">&gt;    / \\</span><br><span class=\"line\">&gt;   2   3</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; Output: 6</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [-10,9,20,null,null,15,7]</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; -10</span><br><span class=\"line\">&gt; / \\</span><br><span class=\"line\">&gt; 9  20</span><br><span class=\"line\">&gt;  /  \\</span><br><span class=\"line\">&gt; 15   7</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; Output: 42</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<ul>\n<li>递归的思想，DFS，从下到上</li>\n<li>每个节点可以与其左右节点结合，但每个节点作为子节点返回时，只能选去该节点的值和其较大子节点的值的和返回<br>Solution<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = Integer.MIN_VALUE;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxPathSum</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        helper(root);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">helper</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = Math.max(helper(root.left), <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> right = Math.max(helper(root.right), <span class=\"number\">0</span>);</span><br><span class=\"line\">        res = Math.max(res, left + right + root.val);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.max(left, right) + root.val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"130-Surrounded-Regions-Medium\"><a href=\"#130-Surrounded-Regions-Medium\" class=\"headerlink\" title=\"130. Surrounded Regions (Medium) @\"></a>130. Surrounded Regions (Medium) <a href=\"https://leetcode.com/problems/surrounded-regions/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a 2D board containing <code>&#39;X&#39;</code> and <code>&#39;O&#39;</code> (<strong>the letter O</strong>), capture all regions surrounded by <code>&#39;X&#39;</code>.</p>\n<p>A region is captured by flipping all <code>&#39;O&#39;</code>s into <code>&#39;X&#39;</code>s in that surrounded region.</p>\n<p><strong>Example:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; X X X X</span><br><span class=\"line\">&gt; X O O X</span><br><span class=\"line\">&gt; X X O X</span><br><span class=\"line\">&gt; X O X X</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p>After running your function, the board should be:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; X X X X</span><br><span class=\"line\">&gt; X X X X</span><br><span class=\"line\">&gt; X X X X</span><br><span class=\"line\">&gt; X O X X</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Explanation:</strong></p>\n<p>Surrounded regions shouldn’t be on the border, which means that any <code>&#39;O&#39;</code> on the border of the board are not flipped to <code>&#39;X&#39;</code>. Any <code>&#39;O&#39;</code> that is not on the border and it is not connected to an <code>&#39;O&#39;</code> on the border will be flipped to <code>&#39;X&#39;</code>. Two cells are connected if they are adjacent cells connected horizontally or vertically.</p>\n</blockquote>\n<p><strong>Solution Recursion</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">(<span class=\"keyword\">char</span>[][] board)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (board == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rows = board.length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rows &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> cols = board[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cols &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 找到边缘‘O’</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; rows; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (board[i][<span class=\"number\">0</span>] == <span class=\"string\">'O'</span>)</span><br><span class=\"line\">                dfs(board, i, <span class=\"number\">0</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (board[i][cols-<span class=\"number\">1</span>] == <span class=\"string\">'O'</span>)</span><br><span class=\"line\">                dfs(board, i, cols-<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; cols; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (board[<span class=\"number\">0</span>][i] == <span class=\"string\">'O'</span>)</span><br><span class=\"line\">                dfs(board, <span class=\"number\">0</span>, i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (board[rows-<span class=\"number\">1</span>][i] == <span class=\"string\">'O'</span>)</span><br><span class=\"line\">                dfs(board, rows-<span class=\"number\">1</span>, i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; rows; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; cols; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (board[i][j] == <span class=\"string\">'#'</span>)</span><br><span class=\"line\">                    board[i][j] = <span class=\"string\">'O'</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (board[i][j] == <span class=\"string\">'O'</span>)</span><br><span class=\"line\">                    board[i][j] = <span class=\"string\">'X'</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//每遇到‘O’后，向四个方向递归搜索，所有相邻‘O’变为‘#’</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">char</span>[][] board, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (board[i][j] == <span class=\"string\">'O'</span>) &#123;</span><br><span class=\"line\">            board[i][j] = <span class=\"string\">'#'</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 跳过四周边缘</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &lt; board.length - <span class=\"number\">2</span>)</span><br><span class=\"line\">                dfs(board, i + <span class=\"number\">1</span>, j);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">                dfs(board, i - <span class=\"number\">1</span>, j);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (j &lt; board[<span class=\"number\">0</span>].length - <span class=\"number\">2</span>)</span><br><span class=\"line\">                dfs(board, i, j + <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (j &gt; <span class=\"number\">1</span>) </span><br><span class=\"line\">                dfs(board, i, j - <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"200-Number-of-Islands-Medium\"><a href=\"#200-Number-of-Islands-Medium\" class=\"headerlink\" title=\"200. Number of Islands (Medium) @\"></a>200. Number of Islands (Medium) <a href=\"https://leetcode.com/problems/number-of-islands/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a 2d grid map of <code>&#39;1&#39;</code>s (land) and <code>&#39;0&#39;</code>s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input:</span><br><span class=\"line\">&gt; 11110</span><br><span class=\"line\">&gt; 11010</span><br><span class=\"line\">&gt; 11000</span><br><span class=\"line\">&gt; 00000</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; Output: 1</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input:</span><br><span class=\"line\">&gt; 11000</span><br><span class=\"line\">&gt; 11000</span><br><span class=\"line\">&gt; 00100</span><br><span class=\"line\">&gt; 00011</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; Output: 3</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p><strong>Solution DFS + Recursion</strong></p>\n<ul>\n<li>采用DFS，访问过的‘1’转为‘0’，继续遍历<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">numIslands</span><span class=\"params\">(<span class=\"keyword\">char</span>[][] grid)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (grid == <span class=\"keyword\">null</span> || grid.length == <span class=\"number\">0</span> || grid[<span class=\"number\">0</span>].length == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rows = grid.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> cols = grid[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; rows; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; cols; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (grid[i][j] == <span class=\"string\">'1'</span>)&#123;</span><br><span class=\"line\">                    count++;</span><br><span class=\"line\">                    dfs(grid, i, j);    </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">char</span>[][] grid, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &lt; <span class=\"number\">0</span> || i &gt; grid.length-<span class=\"number\">1</span> || j &lt; <span class=\"number\">0</span> || j &gt; grid[<span class=\"number\">0</span>].length-<span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (grid[i][j] == <span class=\"string\">'0'</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (grid[i][j] == <span class=\"string\">'1'</span>) &#123;</span><br><span class=\"line\">            grid[i][j] = <span class=\"string\">'0'</span>;</span><br><span class=\"line\">            dfs(grid, i-<span class=\"number\">1</span>, j);</span><br><span class=\"line\">            dfs(grid, i+<span class=\"number\">1</span>, j);</span><br><span class=\"line\">            dfs(grid, i, j-<span class=\"number\">1</span>);</span><br><span class=\"line\">            dfs(grid, i, j+<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"207-Course-Schedule-Medium\"><a href=\"#207-Course-Schedule-Medium\" class=\"headerlink\" title=\"207. Course Schedule (Medium) @\"></a>207. Course Schedule (Medium) <a href=\"https://leetcode.com/problems/course-schedule/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>There are a total of <em>n</em> courses you have to take, labeled from <code>0</code> to <code>n-1</code>.</p>\n<p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: <code>[0,1]</code></p>\n<p>Given the total number of courses and a list of prerequisite <strong>pairs</strong>, is it possible for you to finish all courses?</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: 2, [[1,0]] </span><br><span class=\"line\">&gt; Output: true</span><br><span class=\"line\">&gt; Explanation: There are a total of 2 courses to take. </span><br><span class=\"line\">&gt;           To take course 1 you should have finished course 0. So it is possible.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: 2, [[1,0],[0,1]]</span><br><span class=\"line\">&gt; Output: false</span><br><span class=\"line\">&gt; Explanation: There are a total of 2 courses to take. </span><br><span class=\"line\">&gt;           To take course 1 you should have finished course 0, and to take course 0 you should</span><br><span class=\"line\">&gt;           also have finished course 1. So it is impossible.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Note:</strong></p>\n<ol>\n<li>The input prerequisites is a graph represented by <strong>a list of edges</strong>, not adjacency matrices. Read more about <a href=\"https://www.khanacademy.org/computing/computer-science/algorithms/graph-representation/a/representing-graphs\" target=\"_blank\" rel=\"noopener\">how a graph is represented</a>.</li>\n<li>You may assume that there are no duplicate edges in the input prerequisites.</li>\n</ol>\n</blockquote>\n<p><strong>Solution Topology</strong></p>\n<ul>\n<li>此问题等价于图中是否有无环的存在（拓扑排序解决问题）<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">canFinish</span><span class=\"params\">(<span class=\"keyword\">int</span> numCourses, <span class=\"keyword\">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;Integer, List&lt;Integer&gt;&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] indegree = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[numCourses]; </span><br><span class=\"line\">        <span class=\"comment\">//初始化图，利用hashmap</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; prerequisites.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> s_node = prerequisites[i][<span class=\"number\">0</span>];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> e_node = prerequisites[i][<span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!map.containsKey(s_node))</span><br><span class=\"line\">                map.put(s_node, <span class=\"keyword\">new</span> ArrayList&lt;&gt;());</span><br><span class=\"line\">            map.get(s_node).add(e_node);</span><br><span class=\"line\">            indegree[e_node]++;<span class=\"comment\">//更新每个点的入度</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//储存所有入度为0的节点-&gt;拓扑排序起始点</span></span><br><span class=\"line\">        Queue&lt;Integer&gt; q = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (indegree[i] == <span class=\"number\">0</span>)</span><br><span class=\"line\">                q.offer(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//计算可拓扑排序的节点个数</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!q.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> val = q.poll();</span><br><span class=\"line\">            count++;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (map.containsKey(val)) &#123;</span><br><span class=\"line\">                List&lt;Integer&gt; tmp = map.get(val);</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; tmp.size(); i++) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> idx = tmp.get(i);</span><br><span class=\"line\">                    indegree[idx]--;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (indegree[idx] == <span class=\"number\">0</span>)</span><br><span class=\"line\">                        q.offer(idx);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> count == numCourses;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"210-Course-Schedule-II-Medium\"><a href=\"#210-Course-Schedule-II-Medium\" class=\"headerlink\" title=\"210. Course Schedule II (Medium) @\"></a>210. Course Schedule II (Medium) <a href=\"https://leetcode.com/problems/course-schedule-ii/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>There are a total of <em>n</em> courses you have to take, labeled from <code>0</code> to <code>n-1</code>.</p>\n<p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: <code>[0,1]</code></p>\n<p>Given the total number of courses and a list of prerequisite <strong>pairs</strong>, return the ordering of courses you should take to finish all courses.</p>\n<p>There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: 2, [[1,0]] </span><br><span class=\"line\">&gt; Output: [0,1]</span><br><span class=\"line\">&gt; Explanation: There are a total of 2 courses to take. To take course 1 you should have finished   </span><br><span class=\"line\">&gt;           course 0. So the correct course order is [0,1] .</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: 4, [[1,0],[2,0],[3,1],[3,2]]</span><br><span class=\"line\">&gt; Output: [0,1,2,3] or [0,2,1,3]</span><br><span class=\"line\">&gt; Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both     </span><br><span class=\"line\">&gt;           courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. </span><br><span class=\"line\">&gt;           So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3] .</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Note:</strong></p>\n<ol>\n<li>The input prerequisites is a graph represented by <strong>a list of edges</strong>, not adjacency matrices. Read more about <a href=\"https://www.khanacademy.org/computing/computer-science/algorithms/graph-representation/a/representing-graphs\" target=\"_blank\" rel=\"noopener\">how a graph is represented</a>.</li>\n<li>You may assume that there are no duplicate edges in the input prerequisites.</li>\n</ol>\n</blockquote>\n<p><strong>Solution Topology</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] findOrder(<span class=\"keyword\">int</span> numCourses, <span class=\"keyword\">int</span>[][] prerequisites) &#123;</span><br><span class=\"line\">        Map&lt;Integer, List&lt;Integer&gt;&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] indegree = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[numCourses]; </span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] res = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[numCourses];</span><br><span class=\"line\">        <span class=\"comment\">//初始化图，利用hashmap</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; prerequisites.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> s_node = prerequisites[i][<span class=\"number\">0</span>];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> e_node = prerequisites[i][<span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!map.containsKey(s_node))</span><br><span class=\"line\">                map.put(s_node, <span class=\"keyword\">new</span> ArrayList&lt;&gt;());</span><br><span class=\"line\">            map.get(s_node).add(e_node);</span><br><span class=\"line\">            indegree[e_node]++;<span class=\"comment\">//更新每个点的入度</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//储存所有入度为0的节点-&gt;拓扑排序起始点</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = numCourses - <span class=\"number\">1</span>;</span><br><span class=\"line\">        Queue&lt;Integer&gt; q = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (indegree[i] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                q.offer(i);</span><br><span class=\"line\">                res[index--] = i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//拓扑排序</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!q.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> val = q.poll();</span><br><span class=\"line\">            <span class=\"comment\">//获取val指向的节点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (map.containsKey(val)) &#123;</span><br><span class=\"line\">                List&lt;Integer&gt; tmp = map.get(val);</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; tmp.size(); i++) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> idx = tmp.get(i);</span><br><span class=\"line\">                    indegree[idx]--;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (indegree[idx] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        q.offer(idx);</span><br><span class=\"line\">                        res[index--] = idx;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index != -<span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"BFS\"><a href=\"#BFS\" class=\"headerlink\" title=\"BFS\"></a>BFS</h2><h3 id=\"102-Binary-Tree-Level-Order-Traversal-Medium\"><a href=\"#102-Binary-Tree-Level-Order-Traversal-Medium\" class=\"headerlink\" title=\"102. Binary Tree Level Order Traversal (Medium) @\"></a>102. Binary Tree Level Order Traversal (Medium) <a href=\"https://leetcode.com/problems/binary-tree-level-order-traversal/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a binary tree, return the <em>level order</em> traversal of its nodes’ values. (ie, from left to right, level by level).</p>\n<p>For example:<br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;  3</span><br><span class=\"line\">&gt; / \\</span><br><span class=\"line\">&gt; 9  20</span><br><span class=\"line\">&gt;  /  \\</span><br><span class=\"line\">&gt; 15   7</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p>return its level order traversal as:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; [</span><br><span class=\"line\">&gt; [3],</span><br><span class=\"line\">&gt; [9,20],</span><br><span class=\"line\">&gt; [15,7]</span><br><span class=\"line\">&gt; ]</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p><strong>Solution 1 Recursion</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class=\"line\">        helper(root, res, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">helper</span><span class=\"params\">(TreeNode root, List&lt;List&lt;Integer&gt;&gt; res, <span class=\"keyword\">int</span> level)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (res.size() &lt; level+<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            res.add(<span class=\"keyword\">new</span> ArrayList&lt;Integer&gt; ());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        res.get(level).add(root.val);</span><br><span class=\"line\">        </span><br><span class=\"line\">        helper(root.left, res, level+<span class=\"number\">1</span>);</span><br><span class=\"line\">        helper(root.right, res, level+<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>Solution 2 Iteration (Queue)</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Queue&lt;TreeNode&gt; queue = <span class=\"keyword\">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class=\"line\">        queue.offer(root);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> level = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//start current level</span></span><br><span class=\"line\">            res.add(<span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;());</span><br><span class=\"line\">            <span class=\"comment\">//num of elements in current level</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> len = queue.size();</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">                TreeNode node = queue.poll();</span><br><span class=\"line\">                <span class=\"comment\">//get the val in each level</span></span><br><span class=\"line\">                res.get(level).add(node.val);</span><br><span class=\"line\">                <span class=\"comment\">//add child nodes to queue</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node.left != <span class=\"keyword\">null</span>) queue.offer(node.left);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node.right != <span class=\"keyword\">null</span>) queue.offer(node.right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//go to next level</span></span><br><span class=\"line\">            level++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"103-Binary-Tree-Zigzag-Level-Order-Traversal-Medium\"><a href=\"#103-Binary-Tree-Zigzag-Level-Order-Traversal-Medium\" class=\"headerlink\" title=\"103. Binary Tree Zigzag Level Order Traversal (Medium) @\"></a>103. Binary Tree Zigzag Level Order Traversal (Medium) <a href=\"https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a binary tree, return the <em>zigzag level order</em> traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).</p>\n<p>For example:<br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;  3</span><br><span class=\"line\">&gt; / \\</span><br><span class=\"line\">&gt; 9  20</span><br><span class=\"line\">&gt;  /  \\</span><br><span class=\"line\">&gt; 15   7</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p>return its zigzag level order traversal as:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; [</span><br><span class=\"line\">&gt; [3],</span><br><span class=\"line\">&gt; [20,9],</span><br><span class=\"line\">&gt; [15,7]</span><br><span class=\"line\">&gt; ]</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p><strong>Solution Recursion</strong></p>\n<ul>\n<li>based on 102, add a flag to identify reverse<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class=\"line\">        helper(root, res, <span class=\"number\">0</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">helper</span><span class=\"params\">(TreeNode root, List&lt;List&lt;Integer&gt;&gt; res, <span class=\"keyword\">int</span> level, <span class=\"keyword\">boolean</span> flag)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (res.size() &lt; level+<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            res.add(<span class=\"keyword\">new</span> LinkedList&lt;Integer&gt; ());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (flag) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//convert to LinkedList</span></span><br><span class=\"line\">            ((LinkedList&lt;Integer&gt;)res.get(level)).addFirst(root.val);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            res.get(level).add(root.val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        helper(root.left, res, level+<span class=\"number\">1</span>, !flag);</span><br><span class=\"line\">        helper(root.right, res, level+<span class=\"number\">1</span>, !flag);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"127-Word-Ladder-Medium\"><a href=\"#127-Word-Ladder-Medium\" class=\"headerlink\" title=\"127. Word Ladder (Medium) @\"></a>127. Word Ladder (Medium) <a href=\"https://leetcode.com/problems/word-ladder/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary’s word list, find the length of shortest transformation sequence from <em>beginWord</em> to <em>endWord</em>, such that:</p>\n<ol>\n<li>Only one letter can be changed at a time.</li>\n<li>Each transformed word must exist in the word list. Note that <em>beginWord</em> is <em>not</em> a transformed word.</li>\n</ol>\n<p><strong>Note:</strong></p>\n<ul>\n<li>Return 0 if there is no such transformation sequence.</li>\n<li>All words have the same length.</li>\n<li>All words contain only lowercase alphabetic characters.</li>\n<li>You may assume no duplicates in the word list.</li>\n<li>You may assume <em>beginWord</em> and <em>endWord</em> are non-empty and are not the same.</li>\n</ul>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input:</span><br><span class=\"line\">&gt; beginWord = &quot;hit&quot;,</span><br><span class=\"line\">&gt; endWord = &quot;cog&quot;,</span><br><span class=\"line\">&gt; wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; Output: 5</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; Explanation: As one shortest transformation is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,</span><br><span class=\"line\">&gt; return its length 5.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input:</span><br><span class=\"line\">&gt; beginWord = &quot;hit&quot;</span><br><span class=\"line\">&gt; endWord = &quot;cog&quot;</span><br><span class=\"line\">&gt; wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; Output: 0</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; Explanation: The endWord &quot;cog&quot; is not in wordList, therefore no </span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p><strong>Solution 1 BFS (Time Limit Exceeded)</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">ladderLength</span><span class=\"params\">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!wordList.contains(endWord)) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        Queue&lt;String&gt; queue = <span class=\"keyword\">new</span> LinkedList&lt;String&gt;();</span><br><span class=\"line\">        queue.offer(beginWord);</span><br><span class=\"line\">        HashMap&lt;String, Integer&gt; maps = <span class=\"keyword\">new</span> HashMap&lt;String, Integer&gt;(); <span class=\"comment\">//store the level of each string</span></span><br><span class=\"line\">        maps.put(beginWord, <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (wordList.contains(beginWord)) wordList.remove(beginWord);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">            String top = queue.poll();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> len = top.length();</span><br><span class=\"line\">            StringBuilder builder;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">int</span> level = maps.get(top);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//find the strings which is one char diff with top</span></span><br><span class=\"line\">                builder = <span class=\"keyword\">new</span> StringBuilder(top);</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> c = <span class=\"string\">'a'</span>; c &lt;= <span class=\"string\">'z'</span>; c++) &#123;</span><br><span class=\"line\">                    builder.setCharAt(i, c);</span><br><span class=\"line\">                    String tmpStr = builder.toString();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (tmpStr.equals(top))<span class=\"comment\">//match top</span></span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    <span class=\"comment\">//add to next level</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (wordList.contains(tmpStr)) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (tmpStr.equals(endWord))<span class=\"comment\">//match endWord-&gt;return </span></span><br><span class=\"line\">                            <span class=\"keyword\">return</span> level+<span class=\"number\">1</span>;</span><br><span class=\"line\">                        queue.offer(tmpStr);</span><br><span class=\"line\">                        wordList.remove(tmpStr);</span><br><span class=\"line\">                        maps.put(tmpStr, level+<span class=\"number\">1</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 2 Bidirectional Breadth First Search<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">ladderLength</span><span class=\"params\">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!wordList.contains(endWord)) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//top-&gt;down</span></span><br><span class=\"line\">        Queue&lt;String&gt; queue1 = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        queue1.add(beginWord);</span><br><span class=\"line\">        <span class=\"comment\">//down-&gt;top</span></span><br><span class=\"line\">        Queue&lt;String&gt; queue2 = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        queue2.add(endWord);</span><br><span class=\"line\">        </span><br><span class=\"line\">        Set&lt;String&gt; visited = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        visited.add(endWord);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> step = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(queue1.size() &gt; <span class=\"number\">0</span> &amp;&amp; queue2.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// always start from smaller number of queue </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(queue1.size() &gt; queue2.size()) &#123;</span><br><span class=\"line\">                Queue&lt;String&gt; temp = queue1;</span><br><span class=\"line\">                queue1 = queue2;</span><br><span class=\"line\">                queue2 = temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            Queue&lt;String&gt; nextQueue = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(!queue1.isEmpty()) &#123;</span><br><span class=\"line\">                String cur = queue1.poll();</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(String word: wordList) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(valid(cur, word)) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(queue2.contains(word)) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">return</span> step+<span class=\"number\">1</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        </span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(!visited.contains(word)) &#123;</span><br><span class=\"line\">                            nextQueue.add(word);</span><br><span class=\"line\">                            visited.add(word);                            </span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            queue1 = nextQueue;</span><br><span class=\"line\">            step++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//whether step==1</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">valid</span><span class=\"params\">(String a, String b)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> diff = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; a.length(); ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(a.charAt(i) != b.charAt(i)) &#123;</span><br><span class=\"line\">                diff++;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(diff &gt;= <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"DP-DP-lt-–-gt-DFS-memo\"><a href=\"#DP-DP-lt-–-gt-DFS-memo\" class=\"headerlink\" title=\"DP (DP&lt;–&gt;DFS + memo)\"></a>DP (DP&lt;–&gt;DFS + memo)</h2><h3 id=\"53-Maximum-Subarray-Easy\"><a href=\"#53-Maximum-Subarray-Easy\" class=\"headerlink\" title=\"53.Maximum Subarray (Easy) @\"></a>53.Maximum Subarray (Easy) <a href=\"https://leetcode.com/problems/maximum-subarray/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given an integer array <code>nums</code>, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p>\n<p><strong>Example:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class=\"line\">&gt; Output: 6</span><br><span class=\"line\">&gt; Explanation: [4,-1,2,1] has the largest sum = 6.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Follow up:</strong></p>\n<p>If you have figured out the O(<em>n</em>) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p>\n</blockquote>\n<p><strong>Solution 1</strong></p>\n<ul>\n<li>遍历所有子序列O(n^3) -&gt; 住需要遍历从起始位置开始的子序列 O(n^2) -&gt;</li>\n<li>起始位置为负时，显然不是最大子序列和起始点。所以从负数部位最大子序列和的起点出发 O(n)<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxSubArray</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nSize = nums.length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nSize == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxSum = Integer.MIN_VALUE;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nSize; i++) &#123;</span><br><span class=\"line\">            nSum += nums[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nSum &gt; maxSum)</span><br><span class=\"line\">                maxSum = nSum;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nSum &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                nSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxSum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"62-Unique-Paths-Medium\"><a href=\"#62-Unique-Paths-Medium\" class=\"headerlink\" title=\"62. Unique Paths (Medium) @\"></a>62. Unique Paths (Medium) <a href=\"https://leetcode.com/problems/unique-paths/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>A robot is located at the top-left corner of a <em>m</em> x <em>n</em> grid (marked ‘Start’ in the diagram below).</p>\n<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>\n<p>How many possible unique paths are there?</p>\n<p><strong>Note:</strong> <em>m</em> and <em>n</em> will be at most 100.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: m = 3, n = 2</span><br><span class=\"line\">&gt; Output: 3</span><br><span class=\"line\">&gt; Explanation:</span><br><span class=\"line\">&gt; From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:</span><br><span class=\"line\">&gt; 1. Right -&gt; Right -&gt; Down</span><br><span class=\"line\">&gt; 2. Right -&gt; Down -&gt; Right</span><br><span class=\"line\">&gt; 3. Down -&gt; Right -&gt; Right</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p><strong>Solution 1</strong> </p>\n<ul>\n<li>dp[i] [j] = dp[i-1] [j] + dp[i] [j-1]</li>\n<li>O(m*n)<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">uniquePaths</span><span class=\"params\">(<span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//dp[i][j] = dp[i-1][j] + dp[i][j-1];</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[m][n];</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                    dp[i][j] += dp[i-<span class=\"number\">1</span>][j];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                    dp[i][j] += dp[i][j-<span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[m-<span class=\"number\">1</span>][n-<span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>Solution 2</strong></p>\n<ul>\n<li>空间复杂度 O(m*n) -&gt; O(n)</li>\n<li>dp[j]: (0,0) -&gt; (i,j)</li>\n<li>dp[j-1]表示dp[j]上方的值</li>\n<li>dp[j] = dp[j] + dp[j-1]</li>\n<li>一列一列更新，只保存一列的数据<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">uniquePaths</span><span class=\"params\">(<span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//dp[j]: num of paths from (0,0) to (i-1,j)</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">                dp[j] += dp[j-<span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n-<span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"70-Climbing-Stairs-Easy\"><a href=\"#70-Climbing-Stairs-Easy\" class=\"headerlink\" title=\"70. Climbing Stairs (Easy) @\"></a>70. Climbing Stairs (Easy) <a href=\"https://leetcode.com/problems/climbing-stairs/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>You are climbing a stair case. It takes <em>n</em> steps to reach to the top.</p>\n<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>\n<p><strong>Note:</strong> Given <em>n</em> will be a positive integer.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: 2</span><br><span class=\"line\">&gt; Output: 2</span><br><span class=\"line\">&gt; Explanation: There are two ways to climb to the top.</span><br><span class=\"line\">&gt; 1. 1 step + 1 step</span><br><span class=\"line\">&gt; 2. 2 steps</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: 3</span><br><span class=\"line\">&gt; Output: 3</span><br><span class=\"line\">&gt; Explanation: There are three ways to climb to the top.</span><br><span class=\"line\">&gt; 1. 1 step + 1 step + 1 step</span><br><span class=\"line\">&gt; 2. 1 step + 2 steps</span><br><span class=\"line\">&gt; 3. 2 steps + 1 step</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution 1 DP</p>\n<ul>\n<li>假设梯子有n层，那么如何爬到第n层呢，因为每次只能怕1或2步，那么爬到第n层的方法要么是从第n-1层一步上来的，要不就是从n-2层2步上来的，所以递推公式非常容易的就得出了<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">climbStairs</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//dp[i] = dp[i-1] + dp[i-2];</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n+<span class=\"number\">1</span>];</span><br><span class=\"line\">        dp[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        dp[<span class=\"number\">2</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">3</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            dp[i] = dp[i - <span class=\"number\">1</span>] + dp[i - <span class=\"number\">2</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>Solution 2 Fibonacci Number<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">climbStairs</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> first = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> second = <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">3</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> third = first + second;</span><br><span class=\"line\">            first = second;</span><br><span class=\"line\">            second = third;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> second;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"91-Decode-Ways-Medium\"><a href=\"#91-Decode-Ways-Medium\" class=\"headerlink\" title=\"91. Decode Ways (Medium) @\"></a>91. Decode Ways (Medium) <a href=\"https://leetcode.com/problems/decode-ways/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>A message containing letters from <code>A-Z</code> is being encoded to numbers using the following mapping:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; &apos;A&apos; -&gt; 1</span><br><span class=\"line\">&gt; &apos;B&apos; -&gt; 2</span><br><span class=\"line\">&gt; ...</span><br><span class=\"line\">&gt; &apos;Z&apos; -&gt; 26</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p>Given a <strong>non-empty</strong> string containing only digits, determine the total number of ways to decode it.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: &quot;12&quot;</span><br><span class=\"line\">&gt; Output: 2</span><br><span class=\"line\">&gt; Explanation: It could be decoded as &quot;AB&quot; (1 2) or &quot;L&quot; (12).</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: &quot;226&quot;</span><br><span class=\"line\">&gt; Output: 3</span><br><span class=\"line\">&gt; Explanation: It could be decoded as &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), or &quot;BBF&quot; (2 2 6).</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p><strong>Solution</strong></p>\n<ul>\n<li><p>设定状态为：<code>dp[i]</code>表示<code>s</code>从<code>0</code>开始，长度为<code>i</code>的子串的解码方式数量，于是我们最终要求的答案便是<code>dp[n]</code>。</p>\n<p>那么如何求解<code>dp[i]</code>呢？这个很简单，枚举最后一个字母对应1位还是2位，将f转化为规模更小的子问题。</p>\n<ul>\n<li>设<code>dp[i] = 0</code></li>\n<li>枚举最后一个字母对应1位（要求<code>s[i - 1] != &#39;0&#39;</code>)，那么有<code>dp[i] += dp[i-1]</code>；</li>\n<li>枚举最后一个字母对应2位（要求<code>i &gt; 1</code>且<code>s[i - 2]</code>和<code>s[i - 1]</code>组成的字符串在<code>&quot;10&quot;~&quot;26&quot;</code>的范围内），那么有<code>dp[i] += dp[i - 2]</code>；</li>\n</ul>\n</li>\n<li><p>也就是说，我们可以通过dp[i - 1]和dp[i - 2]计算出dp[i]来，这就是我们的状态和转移方程。</p>\n</li>\n<li><p>在具体实现中，我们可以按照i从1到n的顺序，依次计算出所有的dp[i]。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">numDecodings</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.length() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[s.length()+<span class=\"number\">1</span>];</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">//dp[i] 表示s从0开始，长度为i的字串的解码方式数量</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; s.length()+<span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s.charAt(i-<span class=\"number\">1</span>) != <span class=\"string\">'0'</span>) </span><br><span class=\"line\">                dp[i] += dp[i-<span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">2</span> &amp;&amp; (s.substring(i-<span class=\"number\">2</span>, i).compareTo(<span class=\"string\">\"10\"</span>) &gt;= <span class=\"number\">0</span> &amp;&amp; s.substring(i-<span class=\"number\">2</span>, i).compareTo(<span class=\"string\">\"26\"</span>) &lt;= <span class=\"number\">0</span>))</span><br><span class=\"line\">                dp[i] += dp[i - <span class=\"number\">2</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[s.length()];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"121-Best-Time-to-Buy-and-Sell-Stock-Easy\"><a href=\"#121-Best-Time-to-Buy-and-Sell-Stock-Easy\" class=\"headerlink\" title=\"121. Best Time to Buy and Sell Stock (Easy) @\"></a>121. Best Time to Buy and Sell Stock (Easy) <a href=\"https://leetcode.com/problems/best-time-to-buy-and-sell-stock/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n</blockquote>\n<p><strong>Solution</strong></p>\n<p>如果是动态规划的思路， 基本上我们要定义状态dp[i]， 然后看dp[i]和dp[i-1]或者dp[i-k]之间的关系。<br>假设我们定义dp[i]是在i天的最大利润， 那么和前面的重叠子问题的关系是什么呢？</p>\n<ul>\n<li>一种情况当然是前面子问题里面的最大利润已经是整体的最大利润， 那么dp[i]=dp[i-1]<br>还有一种情况是， 前面虽然取得了利润， 但是第i天卖出（对应到前面某一天买入)会产生更大的利润<br>这时候，dp[i] = prices[i] - prices[j]<br>也就是说, 整个递推公式是: dp[i] = Math.max(dp[i-1], prices[i]-prices[j]), 其中, j&lt;i<br>这样， 对于每个dp[i], 都只和之前的状态和数据有关， 和后面的选择已经无关了。<br>然后这时候要考虑， prices[j]是哪个值会产生最大利润？ 当然是目前为止的最小值。<br>也就是说， dp[j] = min prices so far， 而且这个值的好处是， 在一次遍历的过程中，可以直接随着遍历更新这个值。那么， 可以保存一个min值， 这样整体一次遍历就可以了。</li>\n<li>有一个错误的思路， 就是一次遍历求出最小价格和最大价格， 然后得出利润。<br>这个解法的错误的地方在于， 最大价格可能是最小价格的前面， 不能直接使用。<br>反例比如[3,1,2]</li>\n<li>前面的错误在于把顺序不符合要求的情况包括进去了，<br>当然， 这个过程可以更简化。 甚至可以不需要用这么复杂的动态规划的思路, 直接对问题进行分析。<br>对于最大利润的买入和卖出位置， 虽然买入和卖出可能出现在任意位置， 但是我们考虑如果固定其中一个价格会怎么样？<br>实际上， 如果买入的位置已经选中， 那么卖出的位置也确定了。 反过来也成立， 如果卖出的位置已经选择， 那么买入的位置也确定了。</li>\n</ul>\n<p>这里假设卖出的位置是i, 那么， 买入的位置就是在i前面的价格里面的最小价格。<br>那么，如果我们从左向右遍历， 每次保存目前已经遇到过的最小价格， 那么，prices[i]-min就是在i这个位置卖出的最大利润，这样就可以在一次遍历的过程中求解整体的最大利润。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public int maxProfit(int[] prices) &#123;</span><br><span class=\"line\">        if (prices.length == 0) return 0;</span><br><span class=\"line\">        int[] dp = new int[prices.length];</span><br><span class=\"line\">        int min = prices[0];</span><br><span class=\"line\">        </span><br><span class=\"line\">        for (int i = 1; i &lt; prices.length; i++) &#123;</span><br><span class=\"line\">            min = Math.min(prices[i], min);</span><br><span class=\"line\">            dp[i] = Math.max(dp[i-1], prices[i] - min);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return dp[prices.length - 1];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>可将dp[]换为max，降低空间复杂度</li>\n</ul>\n<h3 id=\"139-Word-Break-Medium\"><a href=\"#139-Word-Break-Medium\" class=\"headerlink\" title=\"139. Word Break (Medium) @\"></a>139. Word Break (Medium) <a href=\"https://leetcode.com/problems/word-break/\" target=\"_blank\" rel=\"noopener\">@</a></h3><p>Solution 1</p>\n<ol>\n<li>一个直观的思路是暴力解，首先从头开始，看看每个单词能不能成为成为字符串的开头， 如果匹配上了， 可以对后面的继续这个过程</li>\n<li>但是这个过程有一点重复， 其实每次计算都是计算的时候，问题是判断某一个子字符串是不是满足要求， 而某一个子字符串，在这个问题里面其实就是原始字符串的index， 那么， 这个子问题可能是重叠的。<br>比如， 针对”abcdef”和[“ab”, “cd”, “abcd”]<br>那么， 针对index=4 （从1开始计数， 可以有ab+cd 或者abcd两种方式， 那么，一个计算过了，后面的就不需要再计算了。</li>\n<li>这样，就可以应用动态规划的思想， 设置dp[i]表示在i位已经满足要求的， 然后从前向后遍历，看看每一位是否可以走到更多的位；</li>\n<li>动态规划的常用套路，就是看prefix， 因为计算prefix的时候，问题已经求解过了，固定了； 当然要从postfix去理解也可以， 但是那样通常会是解问题的自然思路，但是从动态规划bottom up的方式，往往不是那么好理解。<br>而当然，如果用记忆化递归的方式去理解，也是可以的。 但是同样要抽象出需要记忆的状态。 对于每个substring， 其实也是要用index来定义状态。 当然，完全用string做key也可能可以， 但是那样会浪费很多空间。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">wordBreak</span><span class=\"params\">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class=\"line\">        Set&lt;String&gt; wordSet = <span class=\"keyword\">new</span> HashSet&lt;&gt;(wordDict);</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span>[] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[s.length() + <span class=\"number\">1</span>];</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"comment\">//i--开始位置</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!dp[i]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"comment\">//j--结束位置</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i+<span class=\"number\">1</span>; j &lt;= s.length(); j++) &#123;</span><br><span class=\"line\">                String subStr = s.substring(i, j);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (wordSet.contains(subStr)) &#123;</span><br><span class=\"line\">                    dp[j] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[s.length()];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"140-Word-Break-II-Hard\"><a href=\"#140-Word-Break-II-Hard\" class=\"headerlink\" title=\"140. Word Break II (Hard) @\"></a>140. Word Break II (Hard) <a href=\"https://leetcode.com/problems/word-break-ii/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a <strong>non-empty</strong> string <em>s</em> and a dictionary <em>wordDict</em> containing a list of <strong>non-empty</strong> words, add spaces in <em>s</em> to construct a sentence where each word is a valid dictionary word. Return all such possible sentences.</p>\n<p><strong>Note:</strong></p>\n<ul>\n<li>The same word in the dictionary may be reused multiple times in the segmentation.</li>\n<li>You may assume the dictionary does not contain duplicate words.</li>\n</ul>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input:</span><br><span class=\"line\">&gt; s = &quot;catsanddog&quot;</span><br><span class=\"line\">&gt; wordDict = [&quot;cat&quot;, &quot;cats&quot;, &quot;and&quot;, &quot;sand&quot;, &quot;dog&quot;]</span><br><span class=\"line\">&gt; Output:</span><br><span class=\"line\">&gt; [</span><br><span class=\"line\">&gt;   &quot;cats and dog&quot;,</span><br><span class=\"line\">&gt;   &quot;cat sand dog&quot;</span><br><span class=\"line\">&gt; ]</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input:</span><br><span class=\"line\">&gt; s = &quot;pineapplepenapple&quot;</span><br><span class=\"line\">&gt; wordDict = [&quot;apple&quot;, &quot;pen&quot;, &quot;applepen&quot;, &quot;pine&quot;, &quot;pineapple&quot;]</span><br><span class=\"line\">&gt; Output:</span><br><span class=\"line\">&gt; [</span><br><span class=\"line\">&gt;   &quot;pine apple pen apple&quot;,</span><br><span class=\"line\">&gt;   &quot;pineapple pen apple&quot;,</span><br><span class=\"line\">&gt;   &quot;pine applepen apple&quot;</span><br><span class=\"line\">&gt; ]</span><br><span class=\"line\">&gt; Explanation: Note that you are allowed to reuse a dictionary word.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input:</span><br><span class=\"line\">&gt; s = &quot;catsandog&quot;</span><br><span class=\"line\">&gt; wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]</span><br><span class=\"line\">&gt; Output:</span><br><span class=\"line\">&gt; []</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution Recursion</p>\n<ul>\n<li>Python</li>\n<li>递归调用wordBerak()</li>\n<li><a href=\"https://www.youtube.com/watch?v=JqOIRBC0_9c\" target=\"_blank\" rel=\"noopener\">Youtube 题解</a></li>\n<li><img src=\":/ce516b8d2d2e441d9d46426147b9d38c\" alt=\"leetcode_140.png\"></li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wordBreak</span><span class=\"params\">(self, s: str, wordDict: List[str])</span> -&gt; List[str]:</span></span><br><span class=\"line\">        words = set(wordDict)</span><br><span class=\"line\">        memo = &#123;&#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wordBreak</span><span class=\"params\">(s)</span>:</span></span><br><span class=\"line\">            <span class=\"comment\"># already in memory, return directly</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> s <span class=\"keyword\">in</span> memo: </span><br><span class=\"line\">                <span class=\"keyword\">return</span> memo[s]</span><br><span class=\"line\">            <span class=\"comment\"># answer for s</span></span><br><span class=\"line\">            ans = []</span><br><span class=\"line\">            <span class=\"keyword\">if</span> s <span class=\"keyword\">in</span> words:</span><br><span class=\"line\">                ans.append(s)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(s)):</span><br><span class=\"line\">                <span class=\"comment\"># check whether right part is a word</span></span><br><span class=\"line\">                right = s[i:]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> right <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> words:</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span></span><br><span class=\"line\">                <span class=\"comment\"># append to the answer for left part</span></span><br><span class=\"line\">                ans += [w + <span class=\"string\">\" \"</span> + right <span class=\"keyword\">for</span> w <span class=\"keyword\">in</span> wordBreak(s[<span class=\"number\">0</span>:i])]</span><br><span class=\"line\">            memo[s] = ans</span><br><span class=\"line\">            <span class=\"keyword\">return</span> memo[s]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> wordBreak(s)</span><br></pre></td></tr></table></figure>\n<h3 id=\"152-Maximum-Product-Subarray-Medium\"><a href=\"#152-Maximum-Product-Subarray-Medium\" class=\"headerlink\" title=\"152. Maximum Product Subarray (Medium) @\"></a>152. Maximum Product Subarray (Medium) <a href=\"https://leetcode.com/problems/maximum-product-subarray/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given an integer array <code>nums</code>, find the contiguous subarray within an array (containing at least one number) which has the largest product.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [2,3,-2,4]</span><br><span class=\"line\">&gt; Output: 6</span><br><span class=\"line\">&gt; Explanation: [2,3] has the largest product 6.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [-2,0,-1]</span><br><span class=\"line\">&gt; Output: 0</span><br><span class=\"line\">&gt; Explanation: The result cannot be 2, because [-2,-1] is not a subarray.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution DP</p>\n<ul>\n<li>同时记录最大积和最小积，dp[i][0]表示以nums[i]结尾的子序列的最小积，dp[i][1]表示以nums[i]结尾的子序列的最大积。初始状态：<br>dp[0] [0] = nums[0];<br>dp[0] [1] = nums[0];</li>\n<li>由于可能存在负数，所以有三个数参与判断，状态转移方程：<br>dp[i] [0] = min( min(dp[i - 1] [0] <em> nums[i], dp[i - 1] [1] </em> nums[i]), nums[i])<br>dp[i] [1] = max( max(dp[i - 1] [0] <em> nums[i], dp[i - 1] [1] </em> nums[i]), nums[i])</li>\n<li>可以在用一个变量result记录结果，每次计算出最大积时就更新一下result，最后返回result就行，见下面我的代码1，时间复杂度是O(n)O(n)，空间复杂度是O(n)O(n)</li>\n<li>通过状态转移方程可以看出计算dp[i] []时只需要用到dp[i - 1] []，与dp[i - 2] []及前面的结果没有关系，因此空间复杂度可以进一步优化，只用两个变量localMin和localMax存储前一个位置的最大积和最小积</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxProduct</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums == <span class=\"keyword\">null</span> || nums.length == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> localMin = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> localMax = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> globalMax = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp = localMin;</span><br><span class=\"line\">            localMin = Math.min(Math.min(tmp * nums[i], localMax * nums[i]), nums[i]);</span><br><span class=\"line\">            localMax = Math.max(Math.max(localMax * nums[i], tmp * nums[i]), nums[i]);</span><br><span class=\"line\">            globalMax = Math.max(localMax, globalMax);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> globalMax;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"198-House-Robber-Easy\"><a href=\"#198-House-Robber-Easy\" class=\"headerlink\" title=\"198.House Robber (Easy) @\"></a>198.House Robber (Easy) <a href=\"https://leetcode.com/problems/house-robber/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and <strong>it will automatically contact the police if two adjacent houses were broken into on the same night</strong>.</p>\n<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight <strong>without alerting the police</strong>.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [1,2,3,1]</span><br><span class=\"line\">&gt; Output: 4</span><br><span class=\"line\">&gt; Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).</span><br><span class=\"line\">&gt;           Total amount you can rob = 1 + 3 = 4.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [2,7,9,3,1]</span><br><span class=\"line\">&gt; Output: 12</span><br><span class=\"line\">&gt; Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).</span><br><span class=\"line\">&gt;           Total amount you can rob = 2 + 9 + 1 = 12.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution 1 DP</p>\n<ul>\n<li>递推公式</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dp[0] = num[0] （当i=0时）</span><br><span class=\"line\">dp[1] = max(num[0], num[1]) （当i=1时）</span><br><span class=\"line\">dp[i] = max(num[i] + dp[i - 2], dp[i - 1])   （当i !=0 and i != 1时）</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">rob</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums == <span class=\"keyword\">null</span> || nums.length == <span class=\"number\">0</span>) </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[nums.length+<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span>)</span><br><span class=\"line\">                dp[i] = nums[i];</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i == <span class=\"number\">1</span>)</span><br><span class=\"line\">                dp[i] = Math.max(nums[i], nums[i-<span class=\"number\">1</span>]);</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                dp[i] = Math.max(dp[i-<span class=\"number\">2</span>]+nums[i], dp[i-<span class=\"number\">1</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[nums.length-<span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 2</p>\n<ul>\n<li>优化空间复杂度 O(1)</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">rob</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> rob = <span class=\"number\">0</span>, notrob = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp = rob;</span><br><span class=\"line\">        rob = notrob + nums[i];</span><br><span class=\"line\">        notrob = Math.max(temp, notrob);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Math.max(rob, notrob);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Binary-Search\"><a href=\"#Binary-Search\" class=\"headerlink\" title=\"Binary Search\"></a>Binary Search</h2><h3 id=\"69-Sqrt-x-Easy\"><a href=\"#69-Sqrt-x-Easy\" class=\"headerlink\" title=\"69. Sqrt(x) (Easy) @\"></a>69. Sqrt(x) (Easy) <a href=\"https://leetcode.com/problems/sqrtx/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Implement <code>int sqrt(int x)</code>.</p>\n<p>Compute and return the square root of <em>x</em>, where <em>x</em> is guaranteed to be a non-negative integer.</p>\n<p>Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: 4</span><br><span class=\"line\">&gt; Output: 2</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: 8</span><br><span class=\"line\">&gt; Output: 2</span><br><span class=\"line\">&gt; Explanation: The square root of 8 is 2.82842..., and since </span><br><span class=\"line\">&gt;           the decimal part is truncated, 2 is returned.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public int mySqrt(int x) &#123;</span><br><span class=\"line\">        if (x &lt; 2) return x;</span><br><span class=\"line\">        int left = 0;</span><br><span class=\"line\">        int right = x/2+1;</span><br><span class=\"line\">        long mid = 0;</span><br><span class=\"line\">        while (left &lt;= right) &#123;</span><br><span class=\"line\">            mid = (left + right) / 2;</span><br><span class=\"line\">            if (mid * mid == x) &#123;</span><br><span class=\"line\">                return (int)mid;</span><br><span class=\"line\">            &#125;else if (mid * mid &gt; x) &#123;</span><br><span class=\"line\">                right = (int)mid -1;</span><br><span class=\"line\">            &#125;else &#123;</span><br><span class=\"line\">                left = (int)mid + 1;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"162-Find-Peak-Element-Medium\"><a href=\"#162-Find-Peak-Element-Medium\" class=\"headerlink\" title=\"162. Find Peak Element (Medium) @\"></a>162. Find Peak Element (Medium) <a href=\"https://leetcode.com/problems/find-peak-element/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>A peak element is an element that is greater than its neighbors.</p>\n<p>Given an input array <code>nums</code>, where <code>nums[i] ≠ nums[i+1]</code>, find a peak element and return its index.</p>\n<p>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.</p>\n<p>You may imagine that <code>nums[-1] = nums[n] = -∞</code>.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: nums = [1,2,3,1]</span><br><span class=\"line\">&gt; Output: 2</span><br><span class=\"line\">&gt; Explanation: 3 is a peak element and your function should return the index number 2.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: nums = [1,2,1,3,5,6,4]</span><br><span class=\"line\">&gt; Output: 1 or 5 </span><br><span class=\"line\">&gt; Explanation: Your function can return either index number 1 where the peak element is 2, </span><br><span class=\"line\">&gt;           or index number 5 where the peak element is 6.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution</p>\n<ul>\n<li>因为nums[-1] = nums[n] = -∞, 所以当nums[mid] &lt; nums[mid+1] 时，mid右侧必定有peak，同理点那个nums[mid] &gt;= nums[mid+1]时，mid及其左侧必有peak<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public int findPeakElement(int[] nums) &#123;</span><br><span class=\"line\">        int n = nums.length;</span><br><span class=\"line\">        int left = 0, right = n-1;</span><br><span class=\"line\">        while (left &lt; right) &#123;</span><br><span class=\"line\">            int mid = (left + right) / 2;</span><br><span class=\"line\">            if (nums[mid] &lt; nums[mid+1]) &#123;</span><br><span class=\"line\">                //mid右侧必定有peak</span><br><span class=\"line\">                left = mid + 1;</span><br><span class=\"line\">            &#125;else &#123;</span><br><span class=\"line\">                //包括mid在内左侧必有peak</span><br><span class=\"line\">                right = mid;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return left;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"Greedy\"><a href=\"#Greedy\" class=\"headerlink\" title=\"Greedy\"></a>Greedy</h2><h3 id=\"55-Jump-Game-Medium\"><a href=\"#55-Jump-Game-Medium\" class=\"headerlink\" title=\"55. Jump Game (Medium) @\"></a>55. Jump Game (Medium) <a href=\"https://leetcode.com/problems/jump-game/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>\n<p>Each element in the array represents your maximum jump length at that position.</p>\n<p>Determine if you are able to reach the last index.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [2,3,1,1,4]</span><br><span class=\"line\">&gt; Output: true</span><br><span class=\"line\">&gt; Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [3,2,1,0,4]</span><br><span class=\"line\">&gt; Output: false</span><br><span class=\"line\">&gt; Explanation: You will always arrive at index 3 no matter what. Its maximum</span><br><span class=\"line\">&gt;           jump length is 0, which makes it impossible to reach the last index.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution 1 Greedy</p>\n<ul>\n<li>维护一个reach（最远可达距离），每次前进一步，如果i一直在reach范围内，则可达<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public boolean canJump(int[] nums) &#123;</span><br><span class=\"line\">        int reach = 0;</span><br><span class=\"line\">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            if (i &gt; reach)</span><br><span class=\"line\">                return false;</span><br><span class=\"line\">            reach = Math.max(reach, i + nums[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>Solution 2 Zero Point</p>\n<ul>\n<li>若无0点则一定可达任一点</li>\n<li>故只需考虑0点，判断可否跳过此0点即此0点向前数第k个位置的元素大于k即可跳过<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public boolean canJump(int[] nums) &#123;</span><br><span class=\"line\">        int i = nums.length - 2; //0点</span><br><span class=\"line\">        while(i &gt;= 0) &#123;</span><br><span class=\"line\">            if (nums[i] == 0) &#123;</span><br><span class=\"line\">                int j = i - 1;//向前找可以跳过0点的位置</span><br><span class=\"line\">                while (j &gt;= 0) &#123;</span><br><span class=\"line\">                    if (j + nums[j] &gt; i) &#123;</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    j--;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if (j == -1)</span><br><span class=\"line\">                    return false;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            i--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"122-Best-Time-to-Buy-and-Sell-Stock-II-Easy\"><a href=\"#122-Best-Time-to-Buy-and-Sell-Stock-II-Easy\" class=\"headerlink\" title=\"122. Best Time to Buy and Sell Stock II (Easy) @\"></a>122. Best Time to Buy and Sell Stock II (Easy) <a href=\"https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p>\n<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).</p>\n<p><strong>Note:</strong> You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [7,1,5,3,6,4]</span><br><span class=\"line\">&gt; Output: 7</span><br><span class=\"line\">&gt; Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.</span><br><span class=\"line\">&gt;           Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [1,2,3,4,5]</span><br><span class=\"line\">&gt; Output: 4</span><br><span class=\"line\">&gt; Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.</span><br><span class=\"line\">&gt;           Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are</span><br><span class=\"line\">&gt;           engaging multiple transactions at the same time. You must sell before buying again.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [7,6,4,3,1]</span><br><span class=\"line\">&gt; Output: 0</span><br><span class=\"line\">&gt; Explanation: In this case, no transaction is done, i.e. max profit = 0.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution Greedy</p>\n<ul>\n<li>累计所有前低后高的差值<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public int maxProfit(int[] prices) &#123;</span><br><span class=\"line\">        int profit = 0;</span><br><span class=\"line\">        for (int i = 1; i &lt; prices.length; i++) &#123;</span><br><span class=\"line\">            if (prices[i] - prices[i-1] &gt; 0)</span><br><span class=\"line\">                profit += prices[i] - prices[i-1];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return profit;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"134-Gas-Station-Medium\"><a href=\"#134-Gas-Station-Medium\" class=\"headerlink\" title=\"134. Gas Station (Medium) @\"></a>134. Gas Station (Medium) <a href=\"https://leetcode.com/problems/gas-station/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>There are <em>N</em> gas stations along a circular route, where the amount of gas at station <em>i</em> is <code>gas[i]</code>.</p>\n<p>You have a car with an unlimited gas tank and it costs <code>cost[i]</code> of gas to travel from station <em>i</em> to its next station (<em>i</em>+1). You begin the journey with an empty tank at one of the gas stations.</p>\n<p>Return the starting gas station’s index if you can travel around the circuit once in the clockwise direction, otherwise return -1.</p>\n<p><strong>Note:</strong></p>\n<ul>\n<li>If there exists a solution, it is guaranteed to be unique.</li>\n<li>Both input arrays are non-empty and have the same length.</li>\n<li>Each element in the input arrays is a non-negative integer.</li>\n</ul>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: </span><br><span class=\"line\">&gt; gas  = [1,2,3,4,5]</span><br><span class=\"line\">&gt; cost = [3,4,5,1,2]</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; Output: 3</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; Explanation:</span><br><span class=\"line\">&gt; Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4</span><br><span class=\"line\">&gt; Travel to station 4. Your tank = 4 - 1 + 5 = 8</span><br><span class=\"line\">&gt; Travel to station 0. Your tank = 8 - 2 + 1 = 7</span><br><span class=\"line\">&gt; Travel to station 1. Your tank = 7 - 3 + 2 = 6</span><br><span class=\"line\">&gt; Travel to station 2. Your tank = 6 - 4 + 3 = 5</span><br><span class=\"line\">&gt; Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.</span><br><span class=\"line\">&gt; Therefore, return 3 as the starting index.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: </span><br><span class=\"line\">&gt; gas  = [2,3,4]</span><br><span class=\"line\">&gt; cost = [3,4,3]</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; Output: -1</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; Explanation:</span><br><span class=\"line\">&gt; You can&apos;t start at station 0 or 1, as there is not enough gas to travel to the next station.</span><br><span class=\"line\">&gt; Let&apos;s start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4</span><br><span class=\"line\">&gt; Travel to station 0. Your tank = 4 - 3 + 2 = 3</span><br><span class=\"line\">&gt; Travel to station 1. Your tank = 3 - 3 + 3 = 3</span><br><span class=\"line\">&gt; You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.</span><br><span class=\"line\">&gt; Therefore, you can&apos;t travel around the circuit once no matter where you start.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution Greedy</p>\n<ul>\n<li>sum(gas) &gt;= sum(cost) =&gt; 有解</li>\n<li>只要找到一个起点i，从这个点出发的所有gas的和总比cost和打即可<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public int canCompleteCircuit(int[] gas, int[] cost) &#123;</span><br><span class=\"line\">        int sum = 0, subsum = 0, begin = 0;</span><br><span class=\"line\">        for (int i = 0; i &lt; gas.length; i++) &#123;</span><br><span class=\"line\">            sum += gas[i] - cost[i];</span><br><span class=\"line\">            subsum += gas[i] - cost[i];</span><br><span class=\"line\">            if (subsum &lt; 0) &#123;</span><br><span class=\"line\">                subsum = 0;</span><br><span class=\"line\">                begin = i + 1;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (sum &lt; 0) return -1;</span><br><span class=\"line\">        return begin;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"Tree\"><a href=\"#Tree\" class=\"headerlink\" title=\"Tree\"></a>Tree</h2><h3 id=\"94-Binary-Tree-Inorder-Traversal-Medium\"><a href=\"#94-Binary-Tree-Inorder-Traversal-Medium\" class=\"headerlink\" title=\"94. Binary Tree Inorder Traversal (Medium)  @\"></a>94. Binary Tree Inorder Traversal (Medium)  <a href=\"https://leetcode.com/problems/binary-tree-inorder-traversal/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a binary tree, return the <em>inorder</em> traversal of its nodes’ values.</p>\n<p><strong>Example:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [1,null,2,3]</span><br><span class=\"line\">&gt; 1</span><br><span class=\"line\">&gt;  \\</span><br><span class=\"line\">&gt;   2</span><br><span class=\"line\">&gt;  /</span><br><span class=\"line\">&gt; 3</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; Output: [1,3,2]</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</p>\n</blockquote>\n<p>Solution 1 Recursion</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">inorderTraversal</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        helper(root, res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">helper</span><span class=\"params\">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root.left != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                helper(root.left, res);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res.add(root.val);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root.right != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                helper(root.right, res);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 2 Stack</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">inorderTraversal</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        Stack&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">        TreeNode cur = root;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur != <span class=\"keyword\">null</span> || !stack.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (cur != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                stack.push(cur);</span><br><span class=\"line\">                cur = cur.left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cur = stack.pop();</span><br><span class=\"line\">            res.add(cur.val);</span><br><span class=\"line\">            cur = cur.right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Backtracking\"><a href=\"#Backtracking\" class=\"headerlink\" title=\"Backtracking\"></a>Backtracking</h2><h3 id=\"78-Subsets-Medium\"><a href=\"#78-Subsets-Medium\" class=\"headerlink\" title=\"78. Subsets (Medium) @\"></a>78. Subsets (Medium) <a href=\"https://leetcode.com/problems/subsets/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a set of <strong>distinct</strong> integers, <em>nums</em>, return all possible subsets (the power set).</p>\n<p><strong>Note:</strong> The solution set must not contain duplicate subsets.</p>\n<p><strong>Example:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: nums = [1,2,3]</span><br><span class=\"line\">&gt; Output:</span><br><span class=\"line\">&gt; [</span><br><span class=\"line\">&gt; [3],</span><br><span class=\"line\">&gt; [1],</span><br><span class=\"line\">&gt; [2],</span><br><span class=\"line\">&gt; [1,2,3],</span><br><span class=\"line\">&gt; [1,3],</span><br><span class=\"line\">&gt; [2,3],</span><br><span class=\"line\">&gt; [1,2],</span><br><span class=\"line\">&gt; []</span><br><span class=\"line\">&gt; ]</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution 1 Recursion<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class=\"keyword\">int</span>[] nums) &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class=\"line\">        List&lt;Integer&gt; cur = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</span><br><span class=\"line\">        backtrack(res, cur, nums, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">backtrack</span><span class=\"params\">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; cur, <span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">        res.add(<span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;(cur));</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = j; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            cur.add(nums[i]);<span class=\"comment\">//add nums[i]</span></span><br><span class=\"line\">            backtrack(res, cur, nums, i+<span class=\"number\">1</span>);<span class=\"comment\">// Recursion</span></span><br><span class=\"line\">            cur.remove(cur.size()-<span class=\"number\">1</span>);<span class=\"comment\">//remove nums[i]</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Solution 2 Iteration<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class=\"keyword\">int</span>[] nums) &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class=\"line\">        res.add(<span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;());</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> num : nums) &#123; <span class=\"comment\">//pick up each element from nums</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> size = res.size();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//pick up each element in current res</span></span><br><span class=\"line\">                List&lt;Integer&gt; temp = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;(res.get(i));</span><br><span class=\"line\">                temp.add(num);<span class=\"comment\">//put num into temp</span></span><br><span class=\"line\">                res.add(temp);<span class=\"comment\">//add temp into res</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"79-Word-Search-Medium\"><a href=\"#79-Word-Search-Medium\" class=\"headerlink\" title=\"79. Word Search (Medium) @\"></a>79. Word Search (Medium) <a href=\"https://leetcode.com/problems/word-search/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a 2D board and a word, find if the word exists in the grid.</p>\n<p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>\n<p><strong>Example:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; board =</span><br><span class=\"line\">&gt; [</span><br><span class=\"line\">&gt; [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;],</span><br><span class=\"line\">&gt; [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;],</span><br><span class=\"line\">&gt; [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]</span><br><span class=\"line\">&gt; ]</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; Given word = &quot;ABCCED&quot;, return true.</span><br><span class=\"line\">&gt; Given word = &quot;SEE&quot;, return true.</span><br><span class=\"line\">&gt; Given word = &quot;ABCB&quot;, return false.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution dfs + backtrack<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//direction: right, down, left, up</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] drow = &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, -<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] dcol = &#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>, -<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">exist</span><span class=\"params\">(<span class=\"keyword\">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span>[][] isVisited = <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[board.length][board[<span class=\"number\">0</span>].length];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; board.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; board[<span class=\"number\">0</span>].length; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (isThisWay(board, word, i, j, <span class=\"number\">0</span>, isVisited))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isThisWay</span><span class=\"params\">(<span class=\"keyword\">char</span>[][] board, String word, <span class=\"keyword\">int</span> row, <span class=\"keyword\">int</span> col, <span class=\"keyword\">int</span> index, <span class=\"keyword\">boolean</span>[][] isVisited)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (row &lt; <span class=\"number\">0</span> || row &gt;= board.length || col &lt; <span class=\"number\">0</span> || col &gt;= board[<span class=\"number\">0</span>].length || isVisited[row][col] || board[row][col] != word.charAt(index))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (++index == word.length())</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>; <span class=\"comment\">// complete matching</span></span><br><span class=\"line\">        isVisited[row][col] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isThisWay(board, word, row + drow[i], col + dcol[i], index, isVisited))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        isVisited[row][col] = <span class=\"keyword\">false</span>;<span class=\"comment\">//backtrack if false</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"131-Palindrome-Partitioning-Medium\"><a href=\"#131-Palindrome-Partitioning-Medium\" class=\"headerlink\" title=\"131. Palindrome Partitioning (Medium) @\"></a>131. Palindrome Partitioning (Medium) <a href=\"https://leetcode.com/problems/palindrome-partitioning/\" target=\"_blank\" rel=\"noopener\">@</a></h3><p>Solution DFS + backtracking</p>\n<ul>\n<li>递归寻找子问题，如果子串回文，则加入res<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class=\"line\">        List&lt;List&lt;String&gt;&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;List&lt;String&gt;&gt;();</span><br><span class=\"line\">        List&lt;String&gt; cur = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.length() == <span class=\"number\">0</span> || s == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        </span><br><span class=\"line\">        backtrack(s, <span class=\"number\">0</span>, cur, res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">backtrack</span><span class=\"params\">(String s, <span class=\"keyword\">int</span> start, List&lt;String&gt; cur, List&lt;List&lt;String&gt;&gt; res)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//recursion complete condition</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (start == s.length()) &#123;</span><br><span class=\"line\">            res.add(<span class=\"keyword\">new</span> ArrayList&lt;String&gt;(cur));</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = start; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">            String str = s.substring(start, i + <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isPalindrome(str)) &#123;</span><br><span class=\"line\">                cur.add(str);</span><br><span class=\"line\">                backtrack(s, i+<span class=\"number\">1</span>, cur, res);</span><br><span class=\"line\">                cur.remove(cur.size()-<span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(String str)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>, right = str.length() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (str.charAt(left) != str.charAt(right)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            left++;</span><br><span class=\"line\">            right--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"212-Word-Search-II-Hard\"><a href=\"#212-Word-Search-II-Hard\" class=\"headerlink\" title=\"212. Word Search II (Hard) @\"></a>212. Word Search II (Hard) <a href=\"https://leetcode.com/problems/word-search-ii/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a 2D board and a list of words from the dictionary, find all words in the board.</p>\n<p>Each word must be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.</p>\n<p><strong>Example:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: </span><br><span class=\"line\">&gt; board = [</span><br><span class=\"line\">&gt; [&apos;o&apos;,&apos;a&apos;,&apos;a&apos;,&apos;n&apos;],</span><br><span class=\"line\">&gt; [&apos;e&apos;,&apos;t&apos;,&apos;a&apos;,&apos;e&apos;],</span><br><span class=\"line\">&gt; [&apos;i&apos;,&apos;h&apos;,&apos;k&apos;,&apos;r&apos;],</span><br><span class=\"line\">&gt; [&apos;i&apos;,&apos;f&apos;,&apos;l&apos;,&apos;v&apos;]</span><br><span class=\"line\">&gt; ]</span><br><span class=\"line\">&gt; words = [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;]</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; Output: [&quot;eat&quot;,&quot;oath&quot;]</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Note:</strong></p>\n<ol>\n<li>All inputs are consist of lowercase letters <code>a-z</code>.</li>\n<li>The values of <code>words</code> are distinct.</li>\n</ol>\n</blockquote>\n<p><a href=\"https://www.cnblogs.com/Dylan-Java-NYC/p/4944555.html\" target=\"_blank\" rel=\"noopener\">Solution</a> Tire + DFS</p>\n<blockquote>\n<p><a href=\"http://www.cnblogs.com/Dylan-Java-NYC/p/4944270.html\" target=\"_blank\" rel=\"noopener\">Word Search</a>的进阶版题目，同时可以利用<a href=\"http://www.cnblogs.com/Dylan-Java-NYC/p/4888830.html\" target=\"_blank\" rel=\"noopener\">Implement Trie (Prefix Tree)</a>.</p>\n<p>生成Trie树，把所有的词都insert进去。</p>\n<p>然后从board上的每一个char开始dfs查找。</p>\n<p>终止条件有两个， 一个 i 和 j 出界，或者board[i][j]已经用过了. 另一个是把board[i][j]加到当前item后，若没有以更新过item为prefix的时候就可以返回了.</p>\n<p>search 更新过的item, 若是有就加到res中, <strong>并且继续，这里不能return,</strong> 因为有可能有 “aabc” “aabcb”两个词同时存在的情况，只检查了”aabc”就return会漏掉”aabcb”.</p>\n<p>标记当前used为true, 然后board四个方向都做recursion. used再改回来.</p>\n<p>Note: 如果board 是[a a], words 只有一个[a], 此时小心重复加了，所以要用HashSet生成res, 最后再用res生成的List返回。</p>\n<p>m = board.length, n = board[0].length, k = words.length, l 是 word的平均长度.</p>\n<p>Time Complexity: O(k<em>l + m</em>n<em>l</em>4^l). k<em>l是简历Trie用时间. m</em>n是外部循环, l是search Trie时间, 4^l是recursion + backtracking的时间.</p>\n<p>Space: O(k<em>l + l). k</em>l是Trie数的大小. 用了l层stack.</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;String&gt; <span class=\"title\">findWords</span><span class=\"params\">(<span class=\"keyword\">char</span>[][] board, String[] words)</span> </span>&#123;</span><br><span class=\"line\">        HashSet&lt;String&gt; res = <span class=\"keyword\">new</span> HashSet&lt;String&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(words == <span class=\"keyword\">null</span> || words.length == <span class=\"number\">0</span> || board == <span class=\"keyword\">null</span> || board.length == <span class=\"number\">0</span> || board[<span class=\"number\">0</span>].length == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList(res);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Trie trie = <span class=\"keyword\">new</span> Trie();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i&lt;words.length; i++)&#123;</span><br><span class=\"line\">            trie.insert(words[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> [][] used = <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[board.length][board[<span class=\"number\">0</span>].length];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i&lt;board.length; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j&lt;board[<span class=\"number\">0</span>].length; j++)&#123;</span><br><span class=\"line\">                findHelper(board,trie,used,<span class=\"string\">\"\"</span>,i,j,res);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList(res);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">findHelper</span><span class=\"params\">(<span class=\"keyword\">char</span>[][] board, Trie trie, <span class=\"keyword\">boolean</span> [][] used, String item, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j, HashSet&lt;String&gt; res)</span></span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i&lt;<span class=\"number\">0</span> || j&lt;<span class=\"number\">0</span> || i&gt;= board.length || j&gt;=board[<span class=\"number\">0</span>].length || used[i][j])&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        item = item+board[i][j];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!trie.startsWith(item))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(trie.search(item))&#123;</span><br><span class=\"line\">            res.add(item);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        used[i][j] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        findHelper(board,trie,used,item,i+<span class=\"number\">1</span>,j,res);</span><br><span class=\"line\">        findHelper(board,trie,used,item,i-<span class=\"number\">1</span>,j,res);</span><br><span class=\"line\">        findHelper(board,trie,used,item,i,j+<span class=\"number\">1</span>,res);</span><br><span class=\"line\">        findHelper(board,trie,used,item,i,j-<span class=\"number\">1</span>,res);</span><br><span class=\"line\">        used[i][j] = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TrieNode</span></span>&#123;</span><br><span class=\"line\">    String val = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">    TrieNode [] nexts;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TrieNode</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        nexts = <span class=\"keyword\">new</span> TrieNode[<span class=\"number\">26</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Trie</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> TrieNode root;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Trie</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        root = <span class=\"keyword\">new</span> TrieNode();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(String word)</span></span>&#123;</span><br><span class=\"line\">        TrieNode p = root;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">char</span> c : word.toCharArray())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(p.nexts[c-<span class=\"string\">'a'</span>] == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                p.nexts[c-<span class=\"string\">'a'</span>] = <span class=\"keyword\">new</span> TrieNode();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            p = p.nexts[c-<span class=\"string\">'a'</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        p.val = word;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">search</span><span class=\"params\">(String word)</span></span>&#123;</span><br><span class=\"line\">        TrieNode p = root;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">char</span> c : word.toCharArray())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(p.nexts[c-<span class=\"string\">'a'</span>] == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            p = p.nexts[c-<span class=\"string\">'a'</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p.val.equals(word);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">startsWith</span><span class=\"params\">(String prefix)</span></span>&#123;</span><br><span class=\"line\">        TrieNode p = root;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">char</span> c : prefix.toCharArray())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(p.nexts[c-<span class=\"string\">'a'</span>] == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            p = p.nexts[c-<span class=\"string\">'a'</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h2><h3 id=\"12-Integer-to-Roman-Easy\"><a href=\"#12-Integer-to-Roman-Easy\" class=\"headerlink\" title=\"12. Integer to Roman (Easy) @\"></a>12. Integer to Roman (Easy) <a href=\"https://leetcode.com/problems/integer-to-roman/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Roman numerals are represented by seven different symbols: <code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Symbol       Value</span><br><span class=\"line\">&gt; I             1</span><br><span class=\"line\">&gt; V             5</span><br><span class=\"line\">&gt; X             10</span><br><span class=\"line\">&gt; L             50</span><br><span class=\"line\">&gt; C             100</span><br><span class=\"line\">&gt; D             500</span><br><span class=\"line\">&gt; M             1000</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p>For example, two is written as <code>II</code> in Roman numeral, just two one’s added together. Twelve is written as, <code>XII</code>, which is simply <code>X</code> + <code>II</code>. The number twenty seven is written as <code>XXVII</code>, which is <code>XX</code> + <code>V</code> + <code>II</code>.</p>\n<p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not <code>IIII</code>. Instead, the number four is written as <code>IV</code>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as <code>IX</code>. There are six instances where subtraction is used:</p>\n<ul>\n<li><code>I</code> can be placed before <code>V</code> (5) and <code>X</code> (10) to make 4 and 9. </li>\n<li><code>X</code> can be placed before <code>L</code> (50) and <code>C</code> (100) to make 40 and 90. </li>\n<li><code>C</code> can be placed before <code>D</code> (500) and <code>M</code> (1000) to make 400 and 900.</li>\n</ul>\n<p>Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: 3</span><br><span class=\"line\">&gt; Output: &quot;III&quot;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: 4</span><br><span class=\"line\">&gt; Output: &quot;IV&quot;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: 9</span><br><span class=\"line\">&gt; Output: &quot;IX&quot;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 4:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: 58</span><br><span class=\"line\">&gt; Output: &quot;LVIII&quot;</span><br><span class=\"line\">&gt; Explanation: L = 50, V = 5, III = 3.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution</p>\n<ul>\n<li>计算每个位的值，并用对应字符串表示</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">intToRoman</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">        String[] M = &#123;<span class=\"string\">\"\"</span>, <span class=\"string\">\"M\"</span>, <span class=\"string\">\"MM\"</span>, <span class=\"string\">\"MMM\"</span>&#125;;</span><br><span class=\"line\">        String[] C = &#123;<span class=\"string\">\"\"</span>, <span class=\"string\">\"C\"</span>, <span class=\"string\">\"CC\"</span>, <span class=\"string\">\"CCC\"</span>, <span class=\"string\">\"CD\"</span>, <span class=\"string\">\"D\"</span>, <span class=\"string\">\"DC\"</span>, <span class=\"string\">\"DCC\"</span>, <span class=\"string\">\"DCCC\"</span>, <span class=\"string\">\"CM\"</span>&#125;;</span><br><span class=\"line\">        String[] X = &#123;<span class=\"string\">\"\"</span>, <span class=\"string\">\"X\"</span>, <span class=\"string\">\"XX\"</span>, <span class=\"string\">\"XXX\"</span>, <span class=\"string\">\"XL\"</span>, <span class=\"string\">\"L\"</span>, <span class=\"string\">\"LX\"</span>, <span class=\"string\">\"LXX\"</span>, <span class=\"string\">\"LXXX\"</span>, <span class=\"string\">\"XC\"</span>&#125;;</span><br><span class=\"line\">        String[] I = &#123;<span class=\"string\">\"\"</span>, <span class=\"string\">\"I\"</span>, <span class=\"string\">\"II\"</span>, <span class=\"string\">\"III\"</span>, <span class=\"string\">\"IV\"</span>, <span class=\"string\">\"V\"</span>, <span class=\"string\">\"VI\"</span>, <span class=\"string\">\"VII\"</span>, <span class=\"string\">\"VIII\"</span>, <span class=\"string\">\"IX\"</span>&#125;;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> M[(num/<span class=\"number\">1000</span>)]+C[(num%<span class=\"number\">1000</span>)/<span class=\"number\">100</span>]+X[(num%<span class=\"number\">100</span>)/<span class=\"number\">10</span>]+I[(num%<span class=\"number\">10</span>)];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"13-Roman-to-Integer-Easy\"><a href=\"#13-Roman-to-Integer-Easy\" class=\"headerlink\" title=\"13. Roman to Integer (Easy) @\"></a>13. Roman to Integer (Easy) <a href=\"https://leetcode.com/problems/roman-to-integer/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Roman numerals are represented by seven different symbols: <code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Symbol       Value</span><br><span class=\"line\">&gt; I             1</span><br><span class=\"line\">&gt; V             5</span><br><span class=\"line\">&gt; X             10</span><br><span class=\"line\">&gt; L             50</span><br><span class=\"line\">&gt; C             100</span><br><span class=\"line\">&gt; D             500</span><br><span class=\"line\">&gt; M             1000</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p>For example, two is written as <code>II</code> in Roman numeral, just two one’s added together. Twelve is written as, <code>XII</code>, which is simply <code>X</code> + <code>II</code>. The number twenty seven is written as <code>XXVII</code>, which is <code>XX</code> + <code>V</code> + <code>II</code>.</p>\n<p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not <code>IIII</code>. Instead, the number four is written as <code>IV</code>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as <code>IX</code>. There are six instances where subtraction is used:</p>\n<ul>\n<li><code>I</code> can be placed before <code>V</code> (5) and <code>X</code> (10) to make 4 and 9. </li>\n<li><code>X</code> can be placed before <code>L</code> (50) and <code>C</code> (100) to make 40 and 90. </li>\n<li><code>C</code> can be placed before <code>D</code> (500) and <code>M</code> (1000) to make 400 and 900.</li>\n</ul>\n<p>Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: &quot;III&quot;</span><br><span class=\"line\">&gt; Output: 3</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: &quot;IV&quot;</span><br><span class=\"line\">&gt; Output: 4</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: &quot;IX&quot;</span><br><span class=\"line\">&gt; Output: 9</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 4:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: &quot;LVIII&quot;</span><br><span class=\"line\">&gt; Output: 58</span><br><span class=\"line\">&gt; Explanation: L = 50, V= 5, III = 3.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 5:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: &quot;MCMXCIV&quot;</span><br><span class=\"line\">&gt; Output: 1994</span><br><span class=\"line\">&gt; Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution 1</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">romanToInt</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        HashMap&lt;Character, Integer&gt; hm = <span class=\"keyword\">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class=\"line\">        hm.put(<span class=\"string\">'I'</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        hm.put(<span class=\"string\">'V'</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">        hm.put(<span class=\"string\">'X'</span>, <span class=\"number\">10</span>);</span><br><span class=\"line\">        hm.put(<span class=\"string\">'L'</span>, <span class=\"number\">50</span>);</span><br><span class=\"line\">        hm.put(<span class=\"string\">'C'</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">        hm.put(<span class=\"string\">'D'</span>, <span class=\"number\">500</span>);</span><br><span class=\"line\">        hm.put(<span class=\"string\">'M'</span>, <span class=\"number\">1000</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxDigit = <span class=\"number\">0</span>, val = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = s.length() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> cur = hm.get(s.charAt(i));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cur &gt;= maxDigit) &#123;</span><br><span class=\"line\">                val += cur;</span><br><span class=\"line\">                maxDigit = cur;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                val -= cur;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 2</p>\n<ul>\n<li>仅有 I X C 可能成为前缀，所以遇到需要考虑是否更新前缀</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">romanToInt</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> x = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> prev = <span class=\"string\">' '</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// if (prev == ' ') prev = s.charAt(i);</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">switch</span> (s.charAt(i)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"string\">'M'</span>:</span><br><span class=\"line\">                    x += prev == <span class=\"string\">'C'</span> ? <span class=\"number\">900</span> : <span class=\"number\">1000</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"string\">'D'</span>:</span><br><span class=\"line\">                    x += prev == <span class=\"string\">'C'</span> ? <span class=\"number\">400</span> : <span class=\"number\">500</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"string\">'C'</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (i &lt; s.length() - <span class=\"number\">1</span> &amp;&amp; (s.charAt(i + <span class=\"number\">1</span>) == <span class=\"string\">'D'</span> || s.charAt(i + <span class=\"number\">1</span>) == <span class=\"string\">'M'</span>)) &#123;</span><br><span class=\"line\">                        prev = <span class=\"string\">'C'</span>;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        x += prev == <span class=\"string\">'X'</span> ? <span class=\"number\">90</span> : <span class=\"number\">100</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"string\">'L'</span>:</span><br><span class=\"line\">                    x += prev == <span class=\"string\">'X'</span> ? <span class=\"number\">40</span> : <span class=\"number\">50</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"string\">'X'</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (i &lt; s.length() - <span class=\"number\">1</span> &amp;&amp; (s.charAt(i + <span class=\"number\">1</span>) == <span class=\"string\">'L'</span> || s.charAt(i + <span class=\"number\">1</span>) == <span class=\"string\">'C'</span>)) &#123;</span><br><span class=\"line\">                        prev = <span class=\"string\">'X'</span>;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        x += prev == <span class=\"string\">'I'</span> ? <span class=\"number\">9</span> : <span class=\"number\">10</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"string\">'V'</span>:</span><br><span class=\"line\">                    x += prev == <span class=\"string\">'I'</span> ? <span class=\"number\">4</span> : <span class=\"number\">5</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"string\">'I'</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (i &lt; s.length() - <span class=\"number\">1</span> &amp;&amp; (s.charAt(i + <span class=\"number\">1</span>) == <span class=\"string\">'V'</span> || s.charAt(i + <span class=\"number\">1</span>) == <span class=\"string\">'X'</span>)) &#123;</span><br><span class=\"line\">                        prev = <span class=\"string\">'I'</span>;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        x += <span class=\"number\">1</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"14-Longest-Common-Prefix-Easy\"><a href=\"#14-Longest-Common-Prefix-Easy\" class=\"headerlink\" title=\"14. Longest Common Prefix (Easy) @\"></a>14. Longest Common Prefix (Easy) <a href=\"https://leetcode.com/problems/longest-common-prefix/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Write a function to find the longest common prefix string amongst an array of strings.</p>\n<p>If there is no common prefix, return an empty string <code>&quot;&quot;</code>.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class=\"line\">&gt; Output: &quot;fl&quot;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class=\"line\">&gt; Output: &quot;&quot;</span><br><span class=\"line\">&gt; Explanation: There is no common prefix among the input strings.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Note:</strong></p>\n<p>All given inputs are in lowercase letters <code>a-z</code>.</p>\n</blockquote>\n<p>Solution 1 Recursion + Divide and Conquer</p>\n<ul>\n<li>二分所有串，一半一半考虑找出commonPrefix</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">longestCommonPrefix</span><span class=\"params\">(String[] strs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (strs.length == <span class=\"number\">0</span> || strs == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>; <span class=\"comment\">//特殊情况</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> longestCommonPrefix(strs, <span class=\"number\">0</span>, strs.length-<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">longestCommonPrefix</span><span class=\"params\">(String[] strs, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l == r) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> strs[l];</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> mid = (l+r)/<span class=\"number\">2</span>;</span><br><span class=\"line\">            String lcpLeft = longestCommonPrefix(strs, l, mid);<span class=\"comment\">//左区间</span></span><br><span class=\"line\">            String lcpRight = longestCommonPrefix(strs, mid+<span class=\"number\">1</span>, r);<span class=\"comment\">//右区间</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> commonPrefix(lcpLeft, lcpRight);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">commonPrefix</span><span class=\"params\">(String ls, String rs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> min = Math.min(ls.length(), rs.length());</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i&lt;min; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ls.charAt(i) != rs.charAt(i)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ls.substring(<span class=\"number\">0</span>,i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ls.substring(<span class=\"number\">0</span>,min);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 2 Divide and Conquer</p>\n<ul>\n<li>假设commonPrefix长度，二分最短串长度</li>\n<li>如果存在，则l和r最后汇聚在commonPrefix的尾部</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">longestCommonPrefix</span><span class=\"params\">(String[] strs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (strs.length == <span class=\"number\">0</span> || strs == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> minLen = Integer.MAX_VALUE;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class=\"line\">            minLen = Math.min(strs[i].length(), minLen);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = <span class=\"number\">0</span>, r = minLen;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l &lt;= r) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> mid = (l + r) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isCommonPrefix(strs, mid)) &#123;</span><br><span class=\"line\">                l = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                r= mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> strs[<span class=\"number\">0</span>].substring(<span class=\"number\">0</span>, (l+r)/<span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isCommonPrefix</span><span class=\"params\">(String[] strs, <span class=\"keyword\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\">        String s = strs[<span class=\"number\">0</span>].substring(<span class=\"number\">0</span>, len);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; strs.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!strs[i].startsWith(s)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"28-Implement-strStr-Easy\"><a href=\"#28-Implement-strStr-Easy\" class=\"headerlink\" title=\"28. Implement strStr()  (Easy)  @\"></a>28. Implement strStr()  (Easy)  <a href=\"https://leetcode.com/problems/implement-strstr/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Implement <a href=\"http://www.cplusplus.com/reference/cstring/strstr/\" target=\"_blank\" rel=\"noopener\">strStr()</a>.</p>\n<p>Return the index of the first occurrence of needle in haystack, or <strong>-1</strong> if needle is not part of haystack.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: haystack = &quot;hello&quot;, needle = &quot;ll&quot;</span><br><span class=\"line\">&gt; Output: 2</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;</span><br><span class=\"line\">&gt; Output: -1</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution 1 Iteration</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">strStr</span><span class=\"params\">(String haystack, String needle)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (needle.length() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; haystack.length() - needle.length() + <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (haystack.charAt(i) == needle.charAt(<span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (j &lt; needle.length() &amp;&amp; haystack.charAt(i+j) == needle.charAt(j)) &#123;</span><br><span class=\"line\">                    j++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j == needle.length())</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 2 KMP (Knuth–Morris–Pratt <a href=\"https://en.wikipedia.org/wiki/String-searching_algorithm\" target=\"_blank\" rel=\"noopener\">string-searching algorithm</a>)</p>\n<ul>\n<li>核心是PMT(Partial Match Table)数组：前缀B – A=BS (S为非空字符串)；PMT 中的值是字符串的前缀集合与后缀集合的交集中最长元素的长度</li>\n<li><img src=\":/67dad347bcda4fb7998271ac90779b10\" alt=\"IMG_0923.JPG\"></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">strStr</span><span class=\"params\">(String haystack, String needle)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (needle.length() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = -<span class=\"number\">1</span>, N = needle.length(), M = haystack.length();</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] next = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[N];</span><br><span class=\"line\">        next[<span class=\"number\">0</span>] = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; N-<span class=\"number\">1</span>) &#123;<span class=\"comment\">// generate next array</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (j == -<span class=\"number\">1</span> || needle.charAt(i) == needle.charAt(j)) &#123;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">                next[i] = j;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                j = next[j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        i = <span class=\"number\">0</span>; j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; M &amp;&amp; j &lt; N) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (j == -<span class=\"number\">1</span> || haystack.charAt(i) == needle.charAt(j)) &#123;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                j = next[j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (j == N) </span><br><span class=\"line\">            <span class=\"keyword\">return</span> i-j;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 3 HashMap</p>\n<ul>\n<li>直接containsKey匹配子串</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">strStr</span><span class=\"params\">(String haystack, String needle)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (needle.length() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (needle.length() &gt; haystack.length()) <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        HashMap&lt;String, Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        map.put(haystack, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"comment\">//put each needle-len substring of haystack into the hashmap</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= haystack.length() - needle.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (map.containsKey(needle)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> map.get(needle);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            map.put(haystack.substring(i, i+needle.length()), i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> map.getOrDefault(needle, -<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"38-Count-and-Say-Easy\"><a href=\"#38-Count-and-Say-Easy\" class=\"headerlink\" title=\"38. Count and Say (Easy) @\"></a>38. Count and Say (Easy) <a href=\"https://leetcode.com/problems/count-and-say/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>The count-and-say sequence is the sequence of integers with the first five terms as following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; 1.     1</span><br><span class=\"line\">&gt; 2.     11</span><br><span class=\"line\">&gt; 3.     21</span><br><span class=\"line\">&gt; 4.     1211</span><br><span class=\"line\">&gt; 5.     111221</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><code>1</code> is read off as <code>&quot;one 1&quot;</code> or <code>11</code>.<br><code>11</code> is read off as <code>&quot;two 1s&quot;</code> or <code>21</code>.<br><code>21</code> is read off as <code>&quot;one 2</code>, then <code>one 1&quot;</code> or <code>1211</code>.</p>\n<p>Given an integer <em>n</em> where 1 ≤ <em>n</em> ≤ 30, generate the <em>n</em>th term of the count-and-say sequence. You can do so recursively, in other words from the previous member read off the digits, counting the number of digits in groups of the same digit.</p>\n<p>Note: Each term of the sequence of integers will be represented as a string.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: 1</span><br><span class=\"line\">&gt; Output: &quot;1&quot;</span><br><span class=\"line\">&gt; Explanation: This is the base case.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: 4</span><br><span class=\"line\">&gt; Output: &quot;1211&quot;</span><br><span class=\"line\">&gt; Explanation: For n = 3 the term was &quot;21&quot; in which we have two groups &quot;2&quot; and &quot;1&quot;, &quot;2&quot; can be read as &quot;12&quot; which means frequency = 1 and value = 2, the same way &quot;1&quot; is read as &quot;11&quot;, so the answer is the concatenation of &quot;12&quot; and &quot;11&quot; which is &quot;1211&quot;.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution 1 Recursion</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">countAndSay</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"1\"</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            String preStr = countAndSay(n-<span class=\"number\">1</span>);</span><br><span class=\"line\">            String res = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> len = <span class=\"number\">1</span>; <span class=\"comment\">//len of same char</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; <span class=\"comment\">//idx of preStr</span></span><br><span class=\"line\">            <span class=\"comment\">//scan preStr to determine the following string</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (i &lt; preStr.length()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (preStr.charAt(i) == preStr.charAt(i-<span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                    len++;</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    res += String.valueOf(len) + String.valueOf(preStr.charAt(i-<span class=\"number\">1</span>));</span><br><span class=\"line\">                    len = <span class=\"number\">1</span>; <span class=\"comment\">//reset len of same char</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res += String.valueOf(len) + String.valueOf(preStr.charAt(i-<span class=\"number\">1</span>));</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res.toString();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 1 Improvement </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">countAndSay</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"1\"</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            String preStr = countAndSay(n-<span class=\"number\">1</span>);</span><br><span class=\"line\">            StringBuilder res = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> len = <span class=\"number\">1</span>; <span class=\"comment\">//len of same char</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; <span class=\"comment\">//idx of preStr</span></span><br><span class=\"line\">            <span class=\"comment\">//scan preStr to determine the following string</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (i &lt; preStr.length()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (preStr.charAt(i) == preStr.charAt(i-<span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                    len++;</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// res += String.valueOf(len) + String.valueOf(preStr.charAt(i-1));</span></span><br><span class=\"line\">                    res.append(len).append(preStr.charAt(i-<span class=\"number\">1</span>));</span><br><span class=\"line\">                    len = <span class=\"number\">1</span>; <span class=\"comment\">//reset len of same char</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// res += String.valueOf(len) + String.valueOf(preStr.charAt(i-1));</span></span><br><span class=\"line\">            res.append(len).append(preStr.charAt(i-<span class=\"number\">1</span>));</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res.toString();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 2 Recursion</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">countAndSay</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"1\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> read(countAndSay(n-<span class=\"number\">1</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">read</span><span class=\"params\">(String preStr)</span> </span>&#123;</span><br><span class=\"line\">        StringBuilder res = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; preStr.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> c = preStr.charAt(i); <span class=\"comment\">//current char</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> len = <span class=\"number\">1</span>; <span class=\"comment\">//len of same char</span></span><br><span class=\"line\">            <span class=\"comment\">//find and append next \"len+c\"</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> ((i+<span class=\"number\">1</span>) &lt; preStr.length()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (preStr.charAt(i+<span class=\"number\">1</span>) != c) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    i++;</span><br><span class=\"line\">                    len++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res.append(len).append(c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"49-Group-Anagrams-Medium\"><a href=\"#49-Group-Anagrams-Medium\" class=\"headerlink\" title=\"49. Group Anagrams (Medium) @\"></a>49. Group Anagrams (Medium) <a href=\"https://leetcode.com/problems/group-anagrams/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given an array of strings, group anagrams together.</p>\n<p><strong>Example:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],</span><br><span class=\"line\">&gt; Output:</span><br><span class=\"line\">&gt; [</span><br><span class=\"line\">&gt; [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],</span><br><span class=\"line\">&gt; [&quot;nat&quot;,&quot;tan&quot;],</span><br><span class=\"line\">&gt; [&quot;bat&quot;]</span><br><span class=\"line\">&gt; ]</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Note:</strong></p>\n<ul>\n<li>All inputs will be in lowercase.</li>\n<li>The order of your output does not matter.</li>\n</ul>\n</blockquote>\n<p>Solution 1 Hash Map</p>\n<ul>\n<li>sort(str) 找到同字母的串</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(strs == <span class=\"keyword\">null</span> || strs.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            List&lt;List&lt;String&gt;&gt; ans = <span class=\"keyword\">new</span> ArrayList&lt;List&lt;String&gt;&gt;();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        HashMap&lt;String, List&lt;String&gt;&gt; hash = <span class=\"keyword\">new</span> HashMap&lt;String, List&lt;String&gt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String str:strs) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span>[] c = str.toCharArray();</span><br><span class=\"line\">            Arrays.sort(c);</span><br><span class=\"line\">            String temp = String.valueOf(c);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!hash.containsKey(temp)) &#123;</span><br><span class=\"line\">                List&lt;String&gt; vals = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();</span><br><span class=\"line\">                vals.add(str);</span><br><span class=\"line\">                hash.put(temp, vals);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                hash.get(temp).add(str);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        List&lt;List&lt;String&gt;&gt; ans = <span class=\"keyword\">new</span> ArrayList&lt;List&lt;String&gt;&gt;();</span><br><span class=\"line\">        ans.addAll(hash.values());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 2 Hash Map + Prime Number</p>\n<ul>\n<li>每个字母对应一个质数，计算所有字符串的积</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//26个质数对应26个字母</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] primes = &#123;<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">11</span>, <span class=\"number\">13</span>, <span class=\"number\">17</span>, <span class=\"number\">19</span>, <span class=\"number\">23</span>, <span class=\"number\">29</span>, <span class=\"number\">31</span>, <span class=\"number\">41</span>, <span class=\"number\">43</span>, <span class=\"number\">47</span>, <span class=\"number\">53</span>, <span class=\"number\">59</span>, <span class=\"number\">61</span>, <span class=\"number\">67</span>, <span class=\"number\">71</span>, <span class=\"number\">73</span>, <span class=\"number\">79</span>, <span class=\"number\">83</span>, <span class=\"number\">89</span>, <span class=\"number\">97</span>, <span class=\"number\">101</span>, <span class=\"number\">103</span>&#125;;</span><br><span class=\"line\">        List&lt;List&lt;String&gt;&gt; ans = <span class=\"keyword\">new</span> ArrayList&lt;List&lt;String&gt;&gt;();</span><br><span class=\"line\">        HashMap&lt;Integer, List&lt;String&gt;&gt; hash = <span class=\"keyword\">new</span> HashMap&lt;Integer, List&lt;String&gt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String str:strs) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> key = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> c : str.toCharArray()) &#123;</span><br><span class=\"line\">                key *= primes[c-<span class=\"string\">'a'</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!hash.containsKey(key)) &#123;</span><br><span class=\"line\">                List&lt;String&gt; vals = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();</span><br><span class=\"line\">                vals.add(str);</span><br><span class=\"line\">                hash.put(key, vals);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                hash.get(key).add(str);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans.addAll(hash.values());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"58-Length-of-Last-Word-Easy\"><a href=\"#58-Length-of-Last-Word-Easy\" class=\"headerlink\" title=\"58. Length of Last Word (Easy) @\"></a>58. Length of Last Word (Easy) <a href=\"https://leetcode.com/problems/length-of-last-word/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a string <em>s</em> consists of upper/lower-case alphabets and empty space characters <code>&#39; &#39;</code>, return the length of last word (last word means the last appearing word if we loop from left to right) in the string.</p>\n<p>If the last word does not exist, return 0.</p>\n<p><strong>Note:</strong> A word is defined as a <strong>maximal substring</strong> consisting of non-space characters only.</p>\n<p><strong>Example:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: &quot;Hello World&quot;</span><br><span class=\"line\">&gt; Output: 5</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution </p>\n<ul>\n<li>Start = 第一个非’ ‘字符</li>\n<li>End = 下一个‘ ’</li>\n<li>注意while条件顺序，首先判断是否越界</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">lengthOfLastWord</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s == <span class=\"keyword\">null</span> || s.length() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> first = s.length() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">//the first not-' ' character --- start</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (first &gt;= <span class=\"number\">0</span> &amp;&amp; s.charAt(first) == <span class=\"string\">' '</span>)</span><br><span class=\"line\">            first--;</span><br><span class=\"line\">        <span class=\"comment\">//next ' ' position --- end</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (first &gt;= <span class=\"number\">0</span> &amp;&amp; s.charAt(first) != <span class=\"string\">' '</span>) &#123;</span><br><span class=\"line\">            first--;</span><br><span class=\"line\">            count++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"87-Scramble-String-Hard\"><a href=\"#87-Scramble-String-Hard\" class=\"headerlink\" title=\"87.  Scramble String (Hard) @\"></a>87.  Scramble String (Hard) <a href=\"https://leetcode.com/problems/scramble-string/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a string <em>s1</em>, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.</p>\n<p>Below is one possible representation of <em>s1</em> = <code>&quot;great&quot;</code>:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;  great</span><br><span class=\"line\">&gt; /    \\</span><br><span class=\"line\">&gt; gr    eat</span><br><span class=\"line\">&gt; / \\    /  \\</span><br><span class=\"line\">&gt; g   r  e   at</span><br><span class=\"line\">&gt;         / \\</span><br><span class=\"line\">&gt;        a   t</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p>To scramble the string, we may choose any non-leaf node and swap its two children.</p>\n<p>For example, if we choose the node <code>&quot;gr&quot;</code> and swap its two children, it produces a scrambled string <code>&quot;rgeat&quot;</code>.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;  rgeat</span><br><span class=\"line\">&gt; /    \\</span><br><span class=\"line\">&gt; rg    eat</span><br><span class=\"line\">&gt; / \\    /  \\</span><br><span class=\"line\">&gt; r   g  e   at</span><br><span class=\"line\">&gt;         / \\</span><br><span class=\"line\">&gt;        a   t</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p>We say that <code>&quot;rgeat&quot;</code> is a scrambled string of <code>&quot;great&quot;</code>.</p>\n<p>Similarly, if we continue to swap the children of nodes <code>&quot;eat&quot;</code> and <code>&quot;at&quot;</code>, it produces a scrambled string <code>&quot;rgtae&quot;</code>.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;  rgtae</span><br><span class=\"line\">&gt; /    \\</span><br><span class=\"line\">&gt; rg    tae</span><br><span class=\"line\">&gt; / \\    /  \\</span><br><span class=\"line\">&gt; r   g  ta  e</span><br><span class=\"line\">&gt;     / \\</span><br><span class=\"line\">&gt;    t   a</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p>We say that <code>&quot;rgtae&quot;</code> is a scrambled string of <code>&quot;great&quot;</code>.</p>\n<p>Given two strings <em>s1</em> and <em>s2</em> of the same length, determine if <em>s2</em> is a scrambled string of <em>s1</em>.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: s1 = &quot;great&quot;, s2 = &quot;rgeat&quot;</span><br><span class=\"line\">&gt; Output: true</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: s1 = &quot;abcde&quot;, s2 = &quot;caebd&quot;</span><br><span class=\"line\">&gt; Output: false</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution 1 Recursion</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isScramble</span><span class=\"params\">(String s1, String s2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//len of str</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s1.length() != s2.length()) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s1.equals(s2)) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//num of letters</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] letter = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class=\"line\">            letter[s1.charAt(i) - <span class=\"string\">'a'</span>]++;</span><br><span class=\"line\">            letter[s2.charAt(i) - <span class=\"string\">'a'</span>]--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//diff num of letters -&gt; false</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">26</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (letter[i] != <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//loop through all cut points</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; s1.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isScramble(s1.substring(<span class=\"number\">0</span>, i), s2.substring(<span class=\"number\">0</span>, i)) &amp;&amp; isScramble(s1.substring(i), s2.substring(i)))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"comment\">//switch</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isScramble(s1.substring(i), s2.substring(<span class=\"number\">0</span>, s2.length() - i)) &amp;&amp; isScramble(s1.substring(<span class=\"number\">0</span>, i), s2.substring(s2.length() - i)))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 2 Recursion + Memorization</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isScramble</span><span class=\"params\">(String s1, String s2)</span> </span>&#123;</span><br><span class=\"line\">        HashMap&lt;String, Integer&gt; memo = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> isSrambleHelper(s1, s2, memo);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isSrambleHelper</span><span class=\"params\">(String s1, String s2, HashMap&lt;String, Integer&gt; memo)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//previous res</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = memo.getOrDefault(s1 + <span class=\"string\">\"#\"</span> + s2, -<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (res == <span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (res == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//len of str</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s1.length() != s2.length()) &#123;</span><br><span class=\"line\">            memo.put(s1 + <span class=\"string\">\"#\"</span> + s2, <span class=\"number\">0</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s1.equals(s2)) &#123;</span><br><span class=\"line\">            memo.put(s1 + <span class=\"string\">\"#\"</span> + s2, <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//num of letters</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] letter = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class=\"line\">            letter[s1.charAt(i) - <span class=\"string\">'a'</span>]++;</span><br><span class=\"line\">            letter[s2.charAt(i) - <span class=\"string\">'a'</span>]--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//diff num of letters -&gt; false</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">26</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (letter[i] != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                memo.put(s1 + <span class=\"string\">\"#\"</span> + s2, <span class=\"number\">0</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//loop through all cut points</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; s1.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isScramble(s1.substring(<span class=\"number\">0</span>, i), s2.substring(<span class=\"number\">0</span>, i)) &amp;&amp; isScramble(s1.substring(i), s2.substring(i))) &#123;</span><br><span class=\"line\">                memo.put(s1 + <span class=\"string\">\"#\"</span> + s2, <span class=\"number\">1</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">            <span class=\"comment\">//switch</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isScramble(s1.substring(i), s2.substring(<span class=\"number\">0</span>, s2.length() - i)) &amp;&amp; isScramble(s1.substring(<span class=\"number\">0</span>, i), s2.substring(s2.length() - i))) &#123;</span><br><span class=\"line\">                memo.put(s1 + <span class=\"string\">\"#\"</span> + s2, <span class=\"number\">1</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        memo.put(s1 + <span class=\"string\">\"#\"</span> + s2, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 3 DP</p>\n<ul>\n<li><a href=\"https://leetcode-cn.com/problems/scramble-string/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-1-2/\" target=\"_blank\" rel=\"noopener\">solution detail</a></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isScramble</span><span class=\"params\">(String s1, String s2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//len of str</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s1.length() != s2.length()) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s1.equals(s2)) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//num of letters</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] letter = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class=\"line\">            letter[s1.charAt(i) - <span class=\"string\">'a'</span>]++;</span><br><span class=\"line\">            letter[s2.charAt(i) - <span class=\"string\">'a'</span>]--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//diff num of letters -&gt; false</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">26</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (letter[i] != <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> length = s1.length();</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span>[][][] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[length + <span class=\"number\">1</span>][length][length];</span><br><span class=\"line\">        <span class=\"comment\">//loop through all the len of str</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> len = <span class=\"number\">1</span>; len &lt; length + <span class=\"number\">1</span>; len++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//start of s1</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i + len &lt; length + <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//start of s2</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j + len &lt; length + <span class=\"number\">1</span>; j++) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (len == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                        dp[len][i][j] = s1.charAt(i) == s2.charAt(j);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">//loop through all the cut point</span></span><br><span class=\"line\">                        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> q = <span class=\"number\">1</span>; q &lt; len; q++) &#123;</span><br><span class=\"line\">                            dp[len][i][j] = (dp[q][i][j] &amp;&amp; dp[len-q][i+q][j+q]) || (dp[q][i][j+len-q] &amp;&amp; dp[len-q][i+q][j]);</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (dp[len][i][j])</span><br><span class=\"line\">                                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[length][<span class=\"number\">0</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"125-Valid-Palindrome-Easy\"><a href=\"#125-Valid-Palindrome-Easy\" class=\"headerlink\" title=\"125. Valid Palindrome (Easy) @\"></a>125. Valid Palindrome (Easy) <a href=\"https://leetcode.com/problems/valid-palindrome/submissions/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p>\n<p><strong>Note:</strong> For the purpose of this problem, we define empty string as valid palindrome.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class=\"line\">&gt; Output: true</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: &quot;race a car&quot;</span><br><span class=\"line\">&gt; Output: false</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.length() == <span class=\"number\">0</span> || s == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        s = s.toLowerCase();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>, right = s.length() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!Character.isLetterOrDigit(s.charAt(left))) &#123;</span><br><span class=\"line\">                left ++;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!Character.isLetterOrDigit(s.charAt(right))) &#123;</span><br><span class=\"line\">                right --;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s.charAt(left) == s.charAt(right)) &#123;</span><br><span class=\"line\">                left ++;</span><br><span class=\"line\">                right --;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"151-Reverse-Words-in-a-String-Medium\"><a href=\"#151-Reverse-Words-in-a-String-Medium\" class=\"headerlink\" title=\"151. Reverse Words in a String (Medium)  @\"></a>151. Reverse Words in a String (Medium)  <a href=\"https://leetcode.com/problems/reverse-words-in-a-string/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given an input string, reverse the string word by word.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: &quot;the sky is blue&quot;</span><br><span class=\"line\">&gt; Output: &quot;blue is sky the&quot;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: &quot;  hello world!  &quot;</span><br><span class=\"line\">&gt; Output: &quot;world! hello&quot;</span><br><span class=\"line\">&gt; Explanation: Your reversed string should not contain leading or trailing spaces.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: &quot;a good   example&quot;</span><br><span class=\"line\">&gt; Output: &quot;example good a&quot;</span><br><span class=\"line\">&gt; Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution 1 Library function</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">reverseWords</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        StringBuilder ans = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        <span class=\"comment\">//去掉s的首尾空格 然后将字符串拆分</span></span><br><span class=\"line\">        String[] str = s.trim().split(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = str.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//空格后面的空格会变成空字符串</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!str[i].equals(<span class=\"string\">\"\"</span>)) ans.append(str[i] + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//去掉最后添加上的空格</span></span><br><span class=\"line\">        ans = <span class=\"keyword\">new</span> StringBuilder(ans.toString().trim());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 2 从后向前</p>\n<ul>\n<li>将源字符串转换为数组，然后从后向前读取，遇到空格，判断是否单词结束</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">reverseWords</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s == <span class=\"keyword\">null</span> || s.length() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">char</span>[] chars = s.toCharArray();</span><br><span class=\"line\">        StringBuffer ans = <span class=\"keyword\">new</span> StringBuffer();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>, ptr = s.length()-<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">//从后向前扫描</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(ptr &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//空格两种情况：单词结束 和 未开始</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (chars[ptr] == <span class=\"string\">' '</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (count != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    ans.append(chars, ptr + <span class=\"number\">1</span>, count).append(<span class=\"string\">' '</span>);</span><br><span class=\"line\">                    count = <span class=\"number\">0</span>;<span class=\"comment\">//重置count</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            <span class=\"comment\">//遇到字母</span></span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                count++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ptr--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//处理最后一个单词</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (count != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            ans.append(chars, <span class=\"number\">0</span>, count).append(<span class=\"string\">' '</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//去除最后一个空格</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans.length() == <span class=\"number\">0</span> ? <span class=\"string\">\"\"</span> : ans.toString().substring(<span class=\"number\">0</span>, ans.length()-<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 3</p>\n<ul>\n<li>整句全部逆置，再逐个单词逆置</li>\n</ul>\n<h3 id=\"166-Fraction-to-Recurring-Decimal-Medium\"><a href=\"#166-Fraction-to-Recurring-Decimal-Medium\" class=\"headerlink\" title=\"166. Fraction to Recurring Decimal (Medium) @\"></a>166. Fraction to Recurring Decimal (Medium) <a href=\"https://leetcode.com/problems/fraction-to-recurring-decimal/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.</p>\n<p>If the fractional part is repeating, enclose the repeating part in parentheses.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: numerator = 1, denominator = 2</span><br><span class=\"line\">&gt; Output: &quot;0.5&quot;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: numerator = 2, denominator = 1</span><br><span class=\"line\">&gt; Output: &quot;2&quot;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: numerator = 2, denominator = 3</span><br><span class=\"line\">&gt; Output: &quot;0.(6)&quot;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution HashMap</p>\n<ul>\n<li>利用哈希表存储余数位置，以判断是否存在重复的对应小数位</li>\n<li>当出现重复则加入“（）”</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">fractionToDecimal</span><span class=\"params\">(<span class=\"keyword\">int</span> numerator, <span class=\"keyword\">int</span> denominator)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (numerator == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"string\">\"0\"</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        StringBuilder fraction = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        <span class=\"comment\">//positive or negative</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (numerator &lt; <span class=\"number\">0</span> ^ denominator &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            fraction.append(<span class=\"string\">\"-\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Long dividend = Math.abs(Long.valueOf(numerator));</span><br><span class=\"line\">        Long divisor = Math.abs(Long.valueOf(denominator));</span><br><span class=\"line\">        <span class=\"comment\">//Integer Part</span></span><br><span class=\"line\">        fraction.append(String.valueOf(dividend/divisor));</span><br><span class=\"line\">        Long remainder = dividend % divisor;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (remainder == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> fraction.toString();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//Decimal Part</span></span><br><span class=\"line\">        fraction.append(<span class=\"string\">\".\"</span>);</span><br><span class=\"line\">        Map&lt;Long, Integer&gt; pos = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (remainder != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//repeat</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pos.containsKey(remainder)) &#123;</span><br><span class=\"line\">                fraction.insert(pos.get(remainder), <span class=\"string\">\"(\"</span>);</span><br><span class=\"line\">                fraction.append(<span class=\"string\">\")\"</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//add new decimal num</span></span><br><span class=\"line\">            pos.put(remainder, fraction.length()); <span class=\"comment\">//add remainder's position</span></span><br><span class=\"line\">            remainder *= <span class=\"number\">10</span>;</span><br><span class=\"line\">            fraction.append(String.valueOf(remainder / divisor));<span class=\"comment\">//add corresponding decimal</span></span><br><span class=\"line\">            remainder %= divisor;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fraction.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"168-Excel-Sheet-Column-Title-Easy\"><a href=\"#168-Excel-Sheet-Column-Title-Easy\" class=\"headerlink\" title=\"168. Excel Sheet Column Title (Easy) @\"></a>168. Excel Sheet Column Title (Easy) <a href=\"https://leetcode.com/problems/excel-sheet-column-title/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a positive integer, return its corresponding column title as appear in an Excel sheet.</p>\n<p>For example:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;  1 -&gt; A</span><br><span class=\"line\">&gt;  2 -&gt; B</span><br><span class=\"line\">&gt;  3 -&gt; C</span><br><span class=\"line\">&gt;  ...</span><br><span class=\"line\">&gt;  26 -&gt; Z</span><br><span class=\"line\">&gt;  27 -&gt; AA</span><br><span class=\"line\">&gt;  28 -&gt; AB </span><br><span class=\"line\">&gt;  ...</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: 1</span><br><span class=\"line\">&gt; Output: &quot;A&quot;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: 28</span><br><span class=\"line\">&gt; Output: &quot;AB&quot;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: 701</span><br><span class=\"line\">&gt; Output: &quot;ZY&quot;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution 进制转换</p>\n<ul>\n<li>注意是1 - 26 所以使用 n-1</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">convertToTitle</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        StringBuilder str = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (n &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            str.insert(<span class=\"number\">0</span>, (<span class=\"keyword\">char</span>)((n-<span class=\"number\">1</span>)%<span class=\"number\">26</span> + <span class=\"string\">'A'</span>));</span><br><span class=\"line\">            n = (n-<span class=\"number\">1</span>)/<span class=\"number\">26</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> str.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"171-Excel-Sheet-Column-Number-Easy\"><a href=\"#171-Excel-Sheet-Column-Number-Easy\" class=\"headerlink\" title=\"171. Excel Sheet Column Number (Easy) @\"></a>171. Excel Sheet Column Number (Easy) <a href=\"https://leetcode.com/problems/excel-sheet-column-number/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a column title as appear in an Excel sheet, return its corresponding column number.</p>\n<p>For example:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;  A -&gt; 1</span><br><span class=\"line\">&gt;  B -&gt; 2</span><br><span class=\"line\">&gt;  C -&gt; 3</span><br><span class=\"line\">&gt;  ...</span><br><span class=\"line\">&gt;  Z -&gt; 26</span><br><span class=\"line\">&gt;  AA -&gt; 27</span><br><span class=\"line\">&gt;  AB -&gt; 28 </span><br><span class=\"line\">&gt;  ...</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: &quot;A&quot;</span><br><span class=\"line\">&gt; Output: 1</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: &quot;AB&quot;</span><br><span class=\"line\">&gt; Output: 28</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: &quot;ZY&quot;</span><br><span class=\"line\">&gt; Output: 701</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">titleToNumber</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> c : s.toCharArray()) &#123;</span><br><span class=\"line\">            ans = ans * <span class=\"number\">26</span> + (<span class=\"keyword\">int</span>)(c - <span class=\"string\">'A'</span> + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"179-Largest-Number-Medium\"><a href=\"#179-Largest-Number-Medium\" class=\"headerlink\" title=\"179. Largest Number (Medium) @\"></a>179. Largest Number (Medium) <a href=\"https://leetcode.com/problems/largest-number/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a list of non negative integers, arrange them such that they form the largest number.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [10,2]</span><br><span class=\"line\">&gt; Output: &quot;210&quot;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [3,30,34,5,9]</span><br><span class=\"line\">&gt; Output: &quot;9534330&quot;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Note:</strong> The result may be very large, so you need to return a string instead of an integer.</p>\n</blockquote>\n<p>Solution </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LargerNumberComparator</span> <span class=\"keyword\">implements</span> <span class=\"title\">Comparator</span>&lt;<span class=\"title\">String</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(String a, String b)</span> </span>&#123;</span><br><span class=\"line\">            String order1 = a + b;</span><br><span class=\"line\">            String order2 = b + a;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> order2.compareTo(order1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">largestNumber</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//convert to strings</span></span><br><span class=\"line\">        String[] asStrs = <span class=\"keyword\">new</span> String[nums.length];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            asStrs[i] = String.valueOf(nums[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Arrays.sort(asStrs, <span class=\"keyword\">new</span> LargerNumberComparator());</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (asStrs[<span class=\"number\">0</span>].equals(<span class=\"string\">\"0\"</span>)) <span class=\"keyword\">return</span> <span class=\"string\">\"0\"</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        StringBuilder ans = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String str : asStrs) &#123;</span><br><span class=\"line\">            ans.append(str);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"205-Isomorphic-Strings-Easy\"><a href=\"#205-Isomorphic-Strings-Easy\" class=\"headerlink\" title=\"205. Isomorphic Strings (Easy) @\"></a>205. Isomorphic Strings (Easy) <a href=\"https://leetcode.com/problems/isomorphic-strings/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given two strings <strong><em>s\\</em></strong> and <strong><em>t\\</em></strong>, determine if they are isomorphic.</p>\n<p>Two strings are isomorphic if the characters in <strong><em>s\\</em></strong> can be replaced to get <strong><em>t\\</em></strong>.</p>\n<p>All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: s = &quot;egg&quot;, t = &quot;add&quot;</span><br><span class=\"line\">&gt; Output: true</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: s = &quot;foo&quot;, t = &quot;bar&quot;</span><br><span class=\"line\">&gt; Output: false</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: s = &quot;paper&quot;, t = &quot;title&quot;</span><br><span class=\"line\">&gt; Output: true</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Note:</strong><br>You may assume both <strong><em>s\\</em></strong> and <strong><em>t\\</em></strong> have the same length.</p>\n</blockquote>\n<p>Solution 1 HashMap</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isIsomorphic</span><span class=\"params\">(String s, String t)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.length() != t.length()) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">//map -- match char in s and t</span></span><br><span class=\"line\">        HashMap&lt;Character, Character&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">//set -- judge char in t whether has mapped</span></span><br><span class=\"line\">        Set&lt;Character&gt; set = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">char</span> sChart, tChart;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">            sChart = s.charAt(i);</span><br><span class=\"line\">            tChart = t.charAt(i);</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!map.containsKey(sChart)) &#123;<span class=\"comment\">//no mapped</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (set.contains(tChart)) &#123;<span class=\"comment\">//t has been mapped</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    map.put(sChart, tChart);</span><br><span class=\"line\">                    set.add(tChart);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;<span class=\"comment\">//mapped</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (map.get(sChart) != tChart) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 2 Array</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isIsomorphic</span><span class=\"params\">(String s, String t)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span>[] sChars = s.toCharArray();</span><br><span class=\"line\">        <span class=\"keyword\">char</span>[] tChars = t.toCharArray();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> length = sChars.length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(length != tChars.length) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">char</span>[] sm = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"number\">256</span>];</span><br><span class=\"line\">        <span class=\"keyword\">char</span>[] tm = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"number\">256</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;length; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> sc = sChars[i];</span><br><span class=\"line\">            <span class=\"keyword\">char</span> tc = tChars[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(sm[sc] == <span class=\"number\">0</span> &amp;&amp; tm[tc] == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                sm[sc] = tc;</span><br><span class=\"line\">                tm[tc] = sc;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(sm[sc] != tc || tm[tc] != sc)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"242-Valid-Anagram-Easy\"><a href=\"#242-Valid-Anagram-Easy\" class=\"headerlink\" title=\"242. Valid Anagram (Easy) @\"></a>242. Valid Anagram (Easy) <a href=\"https://leetcode.com/problems/valid-anagram/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given two strings <em>s</em> and <em>t</em> , write a function to determine if <em>t</em> is an anagram of <em>s</em>.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: s = &quot;anagram&quot;, t = &quot;nagaram&quot;</span><br><span class=\"line\">&gt; Output: true</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: s = &quot;rat&quot;, t = &quot;car&quot;</span><br><span class=\"line\">&gt; Output: false</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Note:</strong><br>You may assume the string contains only lowercase alphabets.</p>\n<p><strong>Follow up:</strong><br>What if the inputs contain unicode characters? How would you adapt your solution to such case?</p>\n</blockquote>\n<p>Solution 1 Sort</p>\n<ul>\n<li>排序，比较</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isAnagram</span><span class=\"params\">(String s, String t)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span>[] sArr = s.toCharArray();</span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span>[] tArr = t.toCharArray();</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\tArrays.sort(sArr);</span><br><span class=\"line\">\t\tArrays.sort(tArr);</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> String.valueOf(sArr).equals(String.valueOf(tArr));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 2 Array</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isAnagram</span><span class=\"params\">(String s, String t)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.length() != t.length()) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] count = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> sChar = s.charAt(i);</span><br><span class=\"line\">            <span class=\"keyword\">char</span> tChar = t.charAt(i);</span><br><span class=\"line\">            </span><br><span class=\"line\">            count[sChar-<span class=\"string\">'a'</span>] ++;</span><br><span class=\"line\">            count[tChar-<span class=\"string\">'a'</span>] --;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">       \t<span class=\"comment\">//遍历整个count数组</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (count[i] != <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"290-Word-Pattern-Easy\"><a href=\"#290-Word-Pattern-Easy\" class=\"headerlink\" title=\"290. Word Pattern (Easy) @\"></a>290. Word Pattern (Easy) <a href=\"https://leetcode.com/problems/word-pattern/submissions/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a <code>pattern</code> and a string <code>str</code>, find if <code>str</code> follows the same pattern.</p>\n<p>Here <strong>follow</strong> means a full match, such that there is a bijection between a letter in <code>pattern</code> and a <strong>non-empty</strong> word in <code>str</code>.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: pattern = &quot;abba&quot;, str = &quot;dog cat cat dog&quot;</span><br><span class=\"line\">&gt; Output: true</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input:pattern = &quot;abba&quot;, str = &quot;dog cat cat fish&quot;</span><br><span class=\"line\">&gt; Output: false</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: pattern = &quot;aaaa&quot;, str = &quot;dog cat cat dog&quot;</span><br><span class=\"line\">&gt; Output: false</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 4:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: pattern = &quot;abba&quot;, str = &quot;dog dog dog dog&quot;</span><br><span class=\"line\">&gt; Output: false</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Notes:</strong><br>You may assume <code>pattern</code> contains only lowercase letters, and <code>str</code> contains lowercase letters that may be separated by a single space.</p>\n</blockquote>\n<p>Solution–Improvement of P205 Solution 1</p>\n<ul>\n<li>由于字符串比较需要转换，所以用字符串做键，模式字符作为值</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">wordPattern</span><span class=\"params\">(String pattern, String str)</span> </span>&#123;</span><br><span class=\"line\">        String[] Strs = str.split(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">char</span>[] p = pattern.toCharArray();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Strs.length != p.length) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        HashMap&lt;String, Character&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        Set&lt;Character&gt; set = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; p.length; i++) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!map.containsKey(Strs[i])) &#123;<span class=\"comment\">//no mapped</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (set.contains(p[i])) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    map.put(Strs[i], p[i]);</span><br><span class=\"line\">                    set.add(p[i]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;<span class=\"comment\">//mapped</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (map.get(Strs[i]) != p[i]) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"316-Remove-Duplicate-Letters-Hard\"><a href=\"#316-Remove-Duplicate-Letters-Hard\" class=\"headerlink\" title=\"316. Remove Duplicate Letters (Hard) @\"></a>316. Remove Duplicate Letters (Hard) <a href=\"https://leetcode.com/problems/remove-duplicate-letters/submissions/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a string which contains only lowercase letters, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: &quot;bcabc&quot;</span><br><span class=\"line\">&gt; Output: &quot;abc&quot;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: &quot;cbacdcbc&quot;</span><br><span class=\"line\">&gt; Output: &quot;acdb&quot;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution 1 Stack</p>\n<p>思路：每个字符必须出现一次，当这个字符只有一次机会的时候必须添加到字符串结尾，反之，如果后面还有则可以把优先级高的先放进来。<br>步骤：</p>\n<ol>\n<li><p>统计s中字符最后位置</p>\n</li>\n<li><p>如果当前字符已经出现在stack中则跳过</p>\n</li>\n<li><p>如果当前字符不在栈里：</p>\n<p>a. 若当前字符char小与栈顶元素，且栈顶元素有剩余 =》栈顶出栈 并 标记栈顶元素不在栈中（重复该操作直到不满足条件或栈为空）</p>\n<p>b. 当前字符char入栈，并标记char在栈中</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">removeDuplicateLetters</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = s.length();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (len &lt; <span class=\"number\">2</span>) <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">boolean</span>[] visited = <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] lastPos = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">26</span>]; <span class=\"comment\">// 1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">            lastPos[s.charAt(i) - <span class=\"string\">'a'</span>] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Stack&lt;Character&gt; stack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> cur = s.charAt(i);</span><br><span class=\"line\">            <span class=\"comment\">// 2</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (visited[cur - <span class=\"string\">'a'</span>]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 3.a</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() &gt; cur &amp;&amp; lastPos[stack.peek() - <span class=\"string\">'a'</span>] &gt; i) &#123;</span><br><span class=\"line\">                visited[stack.pop() - <span class=\"string\">'a'</span>] = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 3.b</span></span><br><span class=\"line\">            stack.add(cur);</span><br><span class=\"line\">            visited[cur - <span class=\"string\">'a'</span>] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        StringBuilder str = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!stack.isEmpty()) &#123;</span><br><span class=\"line\">            str.insert(<span class=\"number\">0</span>, stack.pop());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> str.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 2 Array</p>\n<ul>\n<li>思路和stack一样但是不需要用到stack</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">removeDuplicateLetters</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] count = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span>[] visited = <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">        <span class=\"keyword\">char</span>[] charArr = s.toCharArray();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">char</span> c : charArr) &#123;</span><br><span class=\"line\">            count[c - <span class=\"string\">'a'</span>]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> i =<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">char</span> c : charArr) &#123;</span><br><span class=\"line\">            count[c - <span class=\"string\">'a'</span>]--;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(visited[c- <span class=\"string\">'a'</span>]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(i &gt;<span class=\"number\">0</span> &amp;&amp; charArr[i-<span class=\"number\">1</span>] &gt;= c &amp;&amp; count[charArr[i-<span class=\"number\">1</span>]-<span class=\"string\">'a'</span>]&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                visited[charArr[i-<span class=\"number\">1</span>]-<span class=\"string\">'a'</span>] = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                i--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            charArr[i] = c;</span><br><span class=\"line\">            visited[c -<span class=\"string\">'a'</span>] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> String(charArr).substring(<span class=\"number\">0</span>,i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"344-Reverse-String-Easy\"><a href=\"#344-Reverse-String-Easy\" class=\"headerlink\" title=\"344. Reverse String (Easy) @\"></a>344. Reverse String (Easy) <a href=\"https://leetcode.com/problems/reverse-string/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Write a function that reverses a string. The input string is given as an array of characters <code>char[]</code>.</p>\n<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\" rel=\"noopener\">in-place</a></strong> with O(1) extra memory.</p>\n<p>You may assume all the characters consist of <a href=\"https://en.wikipedia.org/wiki/ASCII#Printable_characters\" target=\"_blank\" rel=\"noopener\">printable ascii characters</a>.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]</span><br><span class=\"line\">&gt; Output: [&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]</span><br><span class=\"line\">&gt; Output: [&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution Swap</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">reverseString</span><span class=\"params\">(<span class=\"keyword\">char</span>[] s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.length == <span class=\"number\">0</span> || s == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length/<span class=\"number\">2</span>; i++) &#123;</span><br><span class=\"line\">            swap(s, i, s.length-i-<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">char</span>[] s, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> temp = s[i];</span><br><span class=\"line\">        s[i] = s[j];</span><br><span class=\"line\">        s[j] = temp;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"345-Reverse-Vowels-of-a-String-Easy\"><a href=\"#345-Reverse-Vowels-of-a-String-Easy\" class=\"headerlink\" title=\"345. Reverse Vowels of a String (Easy) @\"></a>345. Reverse Vowels of a String (Easy) <a href=\"https://leetcode.com/problems/reverse-vowels-of-a-string/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Write a function that takes a string as input and reverse only the vowels of a string.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: &quot;hello&quot;</span><br><span class=\"line\">&gt; Output: &quot;holle&quot;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: &quot;leetcode&quot;</span><br><span class=\"line\">&gt; Output: &quot;leotcede&quot;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Note:</strong><br>The vowels does not include the letter “y”.</p>\n</blockquote>\n<p>Solution </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">reverseVowels</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span>[] arr = s.toCharArray();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left =<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> right =arr.length-<span class=\"number\">1</span>;</span><br><span class=\"line\">         </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(left&lt;right)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(!isVowel(s.charAt(left))&amp;&amp;left&lt;right)</span><br><span class=\"line\">                left++;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(!isVowel(s.charAt(right))&amp;&amp;left&lt;right)</span><br><span class=\"line\">                right--;</span><br><span class=\"line\">            swap(left,right,arr);</span><br><span class=\"line\">            left++;</span><br><span class=\"line\">            right--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> String(arr);</span><br><span class=\"line\">         </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isVowel</span><span class=\"params\">(<span class=\"keyword\">char</span> c)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(c==<span class=\"string\">'a'</span>||c==<span class=\"string\">'e'</span>||c==<span class=\"string\">'i'</span>||c==<span class=\"string\">'o'</span>||c==<span class=\"string\">'u'</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(c==<span class=\"string\">'A'</span>||c==<span class=\"string\">'E'</span>||c==<span class=\"string\">'I'</span>||c==<span class=\"string\">'O'</span>||c==<span class=\"string\">'U'</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span> i,<span class=\"keyword\">int</span> j,<span class=\"keyword\">char</span>[] arr)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> tmp = arr[i];</span><br><span class=\"line\">        arr[i] =arr[j];</span><br><span class=\"line\">        arr[j]=tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"383-Ransom-Note-Easy\"><a href=\"#383-Ransom-Note-Easy\" class=\"headerlink\" title=\"383. Ransom Note (Easy) @\"></a>383. Ransom Note (Easy) <a href=\"https://leetcode.com/problems/ransom-note/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false.</p>\n<p>Each letter in the magazine string can only be used once in your ransom note.</p>\n<p><strong>Note:</strong><br>You may assume that both strings contain only lowercase letters.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; canConstruct(&quot;a&quot;, &quot;b&quot;) -&gt; false</span><br><span class=\"line\">&gt; canConstruct(&quot;aa&quot;, &quot;ab&quot;) -&gt; false</span><br><span class=\"line\">&gt; canConstruct(&quot;aa&quot;, &quot;aab&quot;) -&gt; true</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution 1 Hash Map</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">canConstruct</span><span class=\"params\">(String ransomNote, String magazine)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//generate hash map of magazine</span></span><br><span class=\"line\">        HashMap&lt;Character, Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; magazine.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> c = magazine.charAt(i);</span><br><span class=\"line\">            map.put(c, map.getOrDefault(c, <span class=\"number\">0</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//update the num of characters in map</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; ransomNote.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> c = ransomNote.charAt(i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!map.containsKey(c))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            map.put(c, map.get(c)-<span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (map.get(c) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 2 String to Array</p>\n<ul>\n<li>字符转化为数字对应</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">canConstruct</span><span class=\"params\">(String ransomNote, String magazine)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count[] = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">char</span> ch: magazine.toCharArray()) &#123;</span><br><span class=\"line\">            count[ch - <span class=\"string\">'a'</span>]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">char</span> ch: ransomNote.toCharArray()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(count[ch - <span class=\"string\">'a'</span>] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            count[ch - <span class=\"string\">'a'</span>]--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 3</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">canConstruct</span><span class=\"params\">(String ransomNote, String magazine)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//若magazine比ransomNote短则一定不可能</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (magazine.length() &lt; ransomNote.length()) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">char</span>[] r = ransomNote.toCharArray();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] list = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> idx = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> c : r) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//判断mag中是否还有c</span></span><br><span class=\"line\">            <span class=\"comment\">//public int indexOf(int char, int fromIndex)</span></span><br><span class=\"line\">            idx = magazine.indexOf(c, list[c - <span class=\"string\">'a'</span>]);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (idx &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//使用过之后向后移动idx</span></span><br><span class=\"line\">            list[c - <span class=\"string\">'a'</span>] = idx + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"387-First-Unique-Character-in-a-String-Easy\"><a href=\"#387-First-Unique-Character-in-a-String-Easy\" class=\"headerlink\" title=\"387. First Unique Character in a String (Easy)  @\"></a>387. First Unique Character in a String (Easy)  <a href=\"https://leetcode.com/problems/first-unique-character-in-a-string/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a string, find the first non-repeating character in it and return it’s index. If it doesn’t exist, return -1.</p>\n<p><strong>Examples:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; s = &quot;leetcode&quot;</span><br><span class=\"line\">&gt; return 0.</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; s = &quot;loveleetcode&quot;,</span><br><span class=\"line\">&gt; return 2.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Note:</strong> You may assume the string contain only lowercase letters.</p>\n</blockquote>\n<p>Solution Hash Map</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">firstUniqChar</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        HashMap&lt;Character, Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">//generate and update hashmap</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> c = s.charAt(i);</span><br><span class=\"line\">            map.put(c, map.getOrDefault(c, <span class=\"number\">0</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//traverse the map</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (map.get(s.charAt(i)) == <span class=\"number\">1</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Array\"><a href=\"#Array\" class=\"headerlink\" title=\"Array\"></a>Array</h2><h3 id=\"54-Spiral-Matrix-Medium\"><a href=\"#54-Spiral-Matrix-Medium\" class=\"headerlink\" title=\"54. Spiral Matrix (Medium) @\"></a>54. Spiral Matrix (Medium) <a href=\"https://leetcode.com/problems/spiral-matrix/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a matrix of <em>m</em> x <em>n</em> elements (<em>m</em> rows, <em>n</em> columns), return all elements of the matrix in spiral order.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input:</span><br><span class=\"line\">&gt; [</span><br><span class=\"line\">&gt; [ 1, 2, 3 ],</span><br><span class=\"line\">&gt; [ 4, 5, 6 ],</span><br><span class=\"line\">&gt; [ 7, 8, 9 ]</span><br><span class=\"line\">&gt; ]</span><br><span class=\"line\">&gt; Output: [1,2,3,6,9,8,7,4,5]</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input:</span><br><span class=\"line\">&gt; [</span><br><span class=\"line\">&gt; [1, 2, 3, 4],</span><br><span class=\"line\">&gt; [5, 6, 7, 8],</span><br><span class=\"line\">&gt; [9,10,11,12]</span><br><span class=\"line\">&gt; ]</span><br><span class=\"line\">&gt; Output: [1,2,3,4,8,12,11,10,9,5,6,7]</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution 1 Simulation<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">spiralOrder</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] matrix)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; res = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (matrix == <span class=\"keyword\">null</span> || matrix.length == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> R = matrix.length, C = matrix[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span>[][] visited = <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[R][C];</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] dr = &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, -<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] dc = &#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>, -<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> r = <span class=\"number\">0</span>, c = <span class=\"number\">0</span>, di = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; R*C; i++) &#123;</span><br><span class=\"line\">            res.add(matrix[r][c]);</span><br><span class=\"line\">            visited[r][c] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> cur_c = c + dc[di];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> cur_r = r + dr[di];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cur_c &gt;= <span class=\"number\">0</span> &amp;&amp; cur_c &lt; C &amp;&amp; cur_r &gt;= <span class=\"number\">0</span> &amp;&amp; cur_r &lt; R &amp;&amp; !visited[cur_r][cur_c]) &#123;</span><br><span class=\"line\">                c = cur_c;</span><br><span class=\"line\">                r = cur_r;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                di = (di + <span class=\"number\">1</span>) % <span class=\"number\">4</span>;</span><br><span class=\"line\">                c += dc[di];</span><br><span class=\"line\">                r += dr[di];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Solution 2 Layer by Layer</p>\n<ul>\n<li>For each outer layer, we want to iterate through its elements in clockwise order starting from the top left corner. Suppose the current outer layer has top-left coordinates (r1, c1) and bottom-right coordinates (r2, c2).</li>\n<li>top : c from c1 …… c2</li>\n<li>right : r from r1+1 …… r2</li>\n<li>bottom : c from c2-1 …… c1+1</li>\n<li>left : r from r2 …… r1-1<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">spiralOrder</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] matrix)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; res = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (matrix == <span class=\"keyword\">null</span> || matrix.length == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> r1 = <span class=\"number\">0</span>, r2 = matrix.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c1 = <span class=\"number\">0</span>, c2 = matrix[<span class=\"number\">0</span>].length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (r1 &lt;= r2 &amp;&amp; c1 &lt;= c2) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> c = c1; c &lt;= c2; c++) res.add(matrix[r1][c]);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> r = r1+<span class=\"number\">1</span>; r &lt;= r2; r++) res.add(matrix[r][c2]);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r1 &lt; r2 &amp;&amp; c1 &lt; c2) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> c = c2 - <span class=\"number\">1</span>; c &gt; c1; c--) res.add(matrix[r2][c]);</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> r = r2; r &gt; r1; r--) res.add(matrix[r][c1]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//move top-left and bottom-right point</span></span><br><span class=\"line\">            r1++;</span><br><span class=\"line\">            c1++;</span><br><span class=\"line\">            r2--;</span><br><span class=\"line\">            c2--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"56-Merge-Intervals-Medium\"><a href=\"#56-Merge-Intervals-Medium\" class=\"headerlink\" title=\"56. Merge Intervals (Medium) @\"></a>56. Merge Intervals (Medium) <a href=\"https://leetcode.com/problems/merge-intervals/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a collection of intervals, merge all overlapping intervals.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [[1,3],[2,6],[8,10],[15,18]]</span><br><span class=\"line\">&gt; Output: [[1,6],[8,10],[15,18]]</span><br><span class=\"line\">&gt; Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [[1,4],[4,5]]</span><br><span class=\"line\">&gt; Output: [[1,5]]</span><br><span class=\"line\">&gt; Explanation: Intervals [1,4] and [4,5] are considered overlapping.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>NOTE:</strong> input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.</p>\n</blockquote>\n<p>Solution Sort + Compare</p>\n<ul>\n<li>按照start排序，然后相邻之间比较</li>\n<li><a href=\"https://blog.csdn.net/wqh8522/article/details/79745350\" target=\"_blank\" rel=\"noopener\">Lambda表达式</a><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[][] merge(<span class=\"keyword\">int</span>[][] intervals) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (intervals.length &lt;= <span class=\"number\">1</span>) <span class=\"keyword\">return</span> intervals;</span><br><span class=\"line\">        <span class=\"comment\">//sorted by start</span></span><br><span class=\"line\">        Arrays.sort(intervals,(i1, i2) -&gt; Integer.compare(i1[<span class=\"number\">0</span>], i2[<span class=\"number\">0</span>]));</span><br><span class=\"line\">        </span><br><span class=\"line\">        List&lt;<span class=\"keyword\">int</span>[]&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] newInterval = intervals[<span class=\"number\">0</span>];</span><br><span class=\"line\">        res.add(newInterval);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span>[] interval : intervals) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//前一个右界大于等于后一个左界</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (newInterval[<span class=\"number\">1</span>] &gt;= interval[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">                newInterval[<span class=\"number\">1</span>] = Math.max(newInterval[<span class=\"number\">1</span>], interval[<span class=\"number\">1</span>]);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                newInterval = interval;</span><br><span class=\"line\">                res.add(newInterval);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res.toArray(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[res.size()][]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"66-Plus-One-Easy\"><a href=\"#66-Plus-One-Easy\" class=\"headerlink\" title=\"66. Plus One (Easy) @\"></a>66. Plus One (Easy) <a href=\"https://leetcode.com/problems/plus-one/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a <strong>non-empty</strong> array of digits representing a non-negative integer, plus one to the integer.</p>\n<p>The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.</p>\n<p>You may assume the integer does not contain any leading zero, except the number 0 itself.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [1,2,3]</span><br><span class=\"line\">&gt; Output: [1,2,4]</span><br><span class=\"line\">&gt; Explanation: The array represents the integer 123.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [4,3,2,1]</span><br><span class=\"line\">&gt; Output: [4,3,2,2]</span><br><span class=\"line\">&gt; Explanation: The array represents the integer 4321.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] plusOne(<span class=\"keyword\">int</span>[] digits) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = digits.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            digits[i]++;</span><br><span class=\"line\">            digits[i] %= <span class=\"number\">10</span>;</span><br><span class=\"line\">            <span class=\"comment\">//若进位则继续遍历，若不进位则直接返回</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (digits[i] != <span class=\"number\">0</span>) <span class=\"keyword\">return</span> digits;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//only 99,999...need one more digit</span></span><br><span class=\"line\">        digits = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[digits.length+<span class=\"number\">1</span>];</span><br><span class=\"line\">        digits[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> digits;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"73-Set-Matrix-Zeros-Medium\"><a href=\"#73-Set-Matrix-Zeros-Medium\" class=\"headerlink\" title=\"73. Set Matrix Zeros (Medium) @\"></a>73. Set Matrix Zeros (Medium) <a href=\"https://leetcode.com/problems/set-matrix-zeroes/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a <em>m</em> x <em>n</em> matrix, if an element is 0, set its entire row and column to 0. Do it <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\" rel=\"noopener\"><strong>in-place</strong></a>.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: </span><br><span class=\"line\">&gt; [</span><br><span class=\"line\">&gt; [1,1,1],</span><br><span class=\"line\">&gt; [1,0,1],</span><br><span class=\"line\">&gt; [1,1,1]</span><br><span class=\"line\">&gt; ]</span><br><span class=\"line\">&gt; Output: </span><br><span class=\"line\">&gt; [</span><br><span class=\"line\">&gt; [1,0,1],</span><br><span class=\"line\">&gt; [0,0,0],</span><br><span class=\"line\">&gt; [1,0,1]</span><br><span class=\"line\">&gt; ]</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: </span><br><span class=\"line\">&gt; [</span><br><span class=\"line\">&gt; [0,1,2,0],</span><br><span class=\"line\">&gt; [3,4,5,2],</span><br><span class=\"line\">&gt; [1,3,1,5]</span><br><span class=\"line\">&gt; ]</span><br><span class=\"line\">&gt; Output: </span><br><span class=\"line\">&gt; [</span><br><span class=\"line\">&gt; [0,0,0,0],</span><br><span class=\"line\">&gt; [0,4,5,0],</span><br><span class=\"line\">&gt; [0,3,1,0]</span><br><span class=\"line\">&gt; ]</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Follow up:</strong></p>\n<ul>\n<li>A straight forward solution using O(<em>m**n</em>) space is probably a bad idea.</li>\n<li>A simple improvement uses O(<em>m</em> + <em>n</em>) space, but still not the best solution.</li>\n<li>Could you devise a constant space solution?</li>\n</ul>\n</blockquote>\n<p>Solution </p>\n<ul>\n<li>Use first row and first column to mark if the row/col needs to be set to 0. (Postpone the change)<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setZeroes</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] matrix)</span> </span>&#123;</span><br><span class=\"line\">    Boolean isCol = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> R = matrix.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> C = matrix[<span class=\"number\">0</span>].length;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; R; i++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// Since first cell for both first row and first column is the same i.e. matrix[0][0]</span></span><br><span class=\"line\">      <span class=\"comment\">// We can use an additional variable for either the first row/column.</span></span><br><span class=\"line\">      <span class=\"comment\">// For this solution we are using an additional variable for the first column</span></span><br><span class=\"line\">      <span class=\"comment\">// and using matrix[0][0] for the first row.</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (matrix[i][<span class=\"number\">0</span>] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        isCol = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; C; j++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// If an element is zero, we set the first element of the corresponding row and column to 0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (matrix[i][j] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          matrix[<span class=\"number\">0</span>][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">          matrix[i][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Iterate over the array once again and using the first row and first column, update the elements.</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; R; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; C; j++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (matrix[i][<span class=\"number\">0</span>] == <span class=\"number\">0</span> || matrix[<span class=\"number\">0</span>][j] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          matrix[i][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// See if the first row needs to be set to zero as well</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (matrix[<span class=\"number\">0</span>][<span class=\"number\">0</span>] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; C; j++) &#123;</span><br><span class=\"line\">        matrix[<span class=\"number\">0</span>][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// See if the first column needs to be set to zero as well</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isCol) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; R; i++) &#123;</span><br><span class=\"line\">        matrix[i][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"75-Sort-Colors-Medium\"><a href=\"#75-Sort-Colors-Medium\" class=\"headerlink\" title=\"75. Sort Colors (Medium) @\"></a>75. Sort Colors (Medium) <a href=\"https://leetcode.com/problems/sort-colors/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given an array with <em>n</em> objects colored red, white or blue, sort them <strong><a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\" rel=\"noopener\">in-place</a></strong> so that objects of the same color are adjacent, with the colors in the order red, white and blue.</p>\n<p>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p>\n<p><strong>Note:</strong> You are not suppose to use the library’s sort function for this problem.</p>\n<p><strong>Example:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [2,0,2,1,1,0]</span><br><span class=\"line\">&gt; Output: [0,0,1,1,2,2]</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Follow up:</strong></p>\n<ul>\n<li>A rather straight forward solution is a two-pass algorithm using counting sort.<br>First, iterate the array counting number of 0’s, 1’s, and 2’s, then overwrite array with total number of 0’s, then 1’s and followed by 2’s.</li>\n<li>Could you come up with a one-pass algorithm using only constant space?</li>\n</ul>\n</blockquote>\n<p>Solution</p>\n<ul>\n<li>red replace forward, blue replace backward <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sortColors</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> red = <span class=\"number\">0</span>, blue = nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (red &lt;= blue &amp;&amp; i &lt;= blue) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[i] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                swap(nums, red, i);</span><br><span class=\"line\">                red++;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[i] == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">                swap(nums, i, blue);</span><br><span class=\"line\">                blue--;</span><br><span class=\"line\">                i--; <span class=\"comment\">//re-evaluate current element</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp = nums[i];</span><br><span class=\"line\">        nums[i] = nums[j];</span><br><span class=\"line\">        nums[j] = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"88-Merge-Sorted-Array-Easy\"><a href=\"#88-Merge-Sorted-Array-Easy\" class=\"headerlink\" title=\"88. Merge Sorted Array (Easy) @\"></a>88. Merge Sorted Array (Easy) <a href=\"https://leetcode.com/problems/merge-sorted-array/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given two sorted integer arrays <em>nums1</em> and <em>nums2</em>, merge <em>nums2</em> into <em>nums1</em> as one sorted array.</p>\n<p><strong>Note:</strong></p>\n<ul>\n<li>The number of elements initialized in <em>nums1</em> and <em>nums2</em> are <em>m</em> and <em>n</em> respectively.</li>\n<li>You may assume that <em>nums1</em> has enough space (size that is greater or equal to <em>m</em> + <em>n</em>) to hold additional elements from <em>nums2</em>.</li>\n</ul>\n<p><strong>Example:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input:</span><br><span class=\"line\">&gt; nums1 = [1,2,3,0,0,0], m = 3</span><br><span class=\"line\">&gt; nums2 = [2,5,6],       n = 3</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; Output: [1,2,2,3,5,6]</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution</p>\n<ul>\n<li>从后向前扫描，添加大的元素<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums1, <span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span>[] nums2, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//two pointer for nums1 and nums2</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> ptr1 = m - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ptr2 = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">//pointer for insert position</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> p = m + n - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">//compare back forward</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (ptr1 &gt;= <span class=\"number\">0</span> &amp;&amp; ptr2 &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums1[ptr1] &gt; nums2[ptr2]) &#123;</span><br><span class=\"line\">                nums1[p--] = nums1[ptr1--];</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                nums1[p--] = nums2[ptr2--];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//add remaining nums in nums2</span></span><br><span class=\"line\">        <span class=\"comment\">//public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</span></span><br><span class=\"line\">        System.arraycopy(nums2, <span class=\"number\">0</span>, nums1, <span class=\"number\">0</span>, ptr2 + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"118-Pascal‘s-Triangle-Easy\"><a href=\"#118-Pascal‘s-Triangle-Easy\" class=\"headerlink\" title=\"118. Pascal‘s Triangle (Easy) @\"></a>118. Pascal‘s Triangle (Easy) <a href=\"https://leetcode.com/problems/pascals-triangle/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a non-negative integer <em>numRows</em>, generate the first <em>numRows</em> of Pascal’s triangle.</p>\n<p>In Pascal’s triangle, each number is the sum of the two numbers directly above it.</p>\n<p><strong>Example:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: 5</span><br><span class=\"line\">&gt; Output:</span><br><span class=\"line\">&gt; [</span><br><span class=\"line\">&gt;   [1],</span><br><span class=\"line\">&gt;  [1,1],</span><br><span class=\"line\">&gt; [1,2,1],</span><br><span class=\"line\">&gt; [1,3,3,1],</span><br><span class=\"line\">&gt; [1,4,6,4,1]</span><br><span class=\"line\">&gt; ]</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution DP</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; generate(<span class=\"keyword\">int</span> numRows) &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; triangle = <span class=\"keyword\">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// First base case; if user requests zero rows, they get zero rows.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (numRows == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> triangle;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Second base case; first row is always [1].</span></span><br><span class=\"line\">        triangle.add(<span class=\"keyword\">new</span> ArrayList&lt;&gt;());</span><br><span class=\"line\">        triangle.get(<span class=\"number\">0</span>).add(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> rowNum = <span class=\"number\">1</span>; rowNum &lt; numRows; rowNum++) &#123;</span><br><span class=\"line\">            List&lt;Integer&gt; row = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(Integer);</span><br><span class=\"line\">            List&lt;Integer&gt; prevRow = triangle.get(rowNum-<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// The first row element is always 1.</span></span><br><span class=\"line\">            row.add(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Each triangle element (other than the first and last of each row)</span></span><br><span class=\"line\">            <span class=\"comment\">// is equal to the sum of the elements above-and-to-the-left and</span></span><br><span class=\"line\">            <span class=\"comment\">// above-and-to-the-right.</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; rowNum; j++) &#123;</span><br><span class=\"line\">                row.add(prevRow.get(j-<span class=\"number\">1</span>) + prevRow.get(j));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// The last row element is always 1.</span></span><br><span class=\"line\">            row.add(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            triangle.add(row);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> triangle;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"136-Single-Number-Easy\"><a href=\"#136-Single-Number-Easy\" class=\"headerlink\" title=\"136. Single Number (Easy) @\"></a>136. Single Number (Easy) <a href=\"https://leetcode.com/problems/single-number/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a <strong>non-empty</strong> array of integers, every element appears <em>twice</em> except for one. Find that single one.</p>\n<p><strong>Note:</strong></p>\n<p>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [2,2,1]</span><br><span class=\"line\">&gt; Output: 1</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [4,1,2,1,2]</span><br><span class=\"line\">&gt; Output: 4</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution 1 Hash Map</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">singleNumber</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        HashMap&lt;Integer, Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> num : nums) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (map.containsKey(num)) &#123;</span><br><span class=\"line\">                map.remove(num);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                map.put(num, <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> map.entrySet().iterator().next().getKey();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 2 Math</p>\n<ul>\n<li>所有不重复数字的两倍乘总和 - 原数组总和 = 出现一次的数字<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">singleNumber</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        Set&lt;Integer&gt; set = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> arrSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> num : nums) &#123;</span><br><span class=\"line\">            set.add(num);</span><br><span class=\"line\">            arrSum += num;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> doubleSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> num : set) &#123;</span><br><span class=\"line\">            doubleSum += <span class=\"number\">2</span>*num;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> doubleSum - arrSum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>Solution 3 Bit Manipulation</p>\n<ul>\n<li>异或XOR</li>\n<li>对所有数字进行异或，最后得出单个的数</li>\n<li>异或性质<ul>\n<li>交换律: A XOR B = B XOR A</li>\n<li>结合律: A XOR B XOR C = A XOR (B XOR C) = (A XOR B) XOR C</li>\n<li>自反性: A XOR B XOR B = A XOR 0 = A<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">singleNumber</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> num : nums) &#123;</span><br><span class=\"line\">            res ^= num;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"169-Majority-Element-Easy\"><a href=\"#169-Majority-Element-Easy\" class=\"headerlink\" title=\"169. Majority Element (Easy) @\"></a>169. Majority Element (Easy) <a href=\"https://leetcode.com/problems/majority-element/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given an array of size <em>n</em>, find the majority element. The majority element is the element that appears <strong>more than</strong> <code>⌊ n/2 ⌋</code> times.</p>\n<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [3,2,3]</span><br><span class=\"line\">&gt; Output: 3</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [2,2,1,1,1,2,2]</span><br><span class=\"line\">&gt; Output: 2</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution 1 HashMap</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">majorityElement</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        HashMap&lt;Integer, Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> N = nums.length;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; N; i++) &#123;</span><br><span class=\"line\">            map.put(nums[i], map.getOrDefault(nums[i], <span class=\"number\">0</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Map.Entry&lt;Integer,Integer&gt; s : map.entrySet()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s.getValue() &gt; N/<span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">                res = s.getKey();</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 2 Sort</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">majorityElement</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        Arrays.sort(nums);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums[nums.length/<span class=\"number\">2</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 3 摩尔投票法</p>\n<ul>\n<li>首先假定数组头元素即为众数，设定计数器为1，从第二个数开始遍历，如果和头元素相同则计数器加1，如果不相同则减1，之后判断计数器是否为0，如果不为0则继续下一步循环，如果为0则将众数指针指向当前元素，以此类推，最后众数指针指向的元素即为众数，时间复杂度～O(n)，空间复杂度～O(1)</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">majorityElement</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[i] == res) count++;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                count--;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (count == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    res = nums[i];</span><br><span class=\"line\">                    count = <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"189-Rotate-Array-Easy\"><a href=\"#189-Rotate-Array-Easy\" class=\"headerlink\" title=\"189. Rotate Array (Easy) @\"></a>189. Rotate Array (Easy) <a href=\"https://leetcode.com/problems/rotate-array/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given an array, rotate the array to the right by <em>k</em> steps, where <em>k</em> is non-negative.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [1,2,3,4,5,6,7] and k = 3</span><br><span class=\"line\">&gt; Output: [5,6,7,1,2,3,4]</span><br><span class=\"line\">&gt; Explanation:</span><br><span class=\"line\">&gt; rotate 1 steps to the right: [7,1,2,3,4,5,6]</span><br><span class=\"line\">&gt; rotate 2 steps to the right: [6,7,1,2,3,4,5]</span><br><span class=\"line\">&gt; rotate 3 steps to the right: [5,6,7,1,2,3,4]</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [-1,-100,3,99] and k = 2</span><br><span class=\"line\">&gt; Output: [3,99,-1,-100]</span><br><span class=\"line\">&gt; Explanation: </span><br><span class=\"line\">&gt; rotate 1 steps to the right: [99,-1,-100,3]</span><br><span class=\"line\">&gt; rotate 2 steps to the right: [3,99,-1,-100]</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Note:</strong></p>\n<ul>\n<li>Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.</li>\n<li>Could you do it in-place with O(1) extra space?</li>\n</ul>\n</blockquote>\n<p>Solution 1 Extra Array</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rotate</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> N = nums.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] temp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[N];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; N; i++) &#123;</span><br><span class=\"line\">            temp[(i+k) % N] = nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; N; i++) &#123;</span><br><span class=\"line\">            nums[i] = temp[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 2 Cyclic Replacements</p>\n<ul>\n<li><a href=\"https://leetcode-cn.com/problems/rotate-array/solution/xuan-zhuan-shu-zu-by-leetcode/\" target=\"_blank\" rel=\"noopener\">Leetcode CN</a></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rotate</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> start = <span class=\"number\">0</span>; count &lt; nums.length; start++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> cur = start;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> prev = nums[cur];</span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> next = (cur + k) % nums.length;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> temp = nums[next];</span><br><span class=\"line\">                nums[next] = prev;</span><br><span class=\"line\">                prev = temp;</span><br><span class=\"line\">                cur = next;</span><br><span class=\"line\">                count++;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">while</span> (start != cur);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 3 Reverse</p>\n<ul>\n<li>先反转所有，再分别反转前k个位置和后面所有<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rotate</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        k %= nums.length;</span><br><span class=\"line\">        reverse(nums, <span class=\"number\">0</span>, nums.length - <span class=\"number\">1</span>);</span><br><span class=\"line\">        reverse(nums, <span class=\"number\">0</span>, k - <span class=\"number\">1</span>);</span><br><span class=\"line\">        reverse(nums, k, nums.length - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">reverse</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> end)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (start &lt; end) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> temp = nums[start];</span><br><span class=\"line\">            nums[start] = nums[end];</span><br><span class=\"line\">            nums[end] = temp;</span><br><span class=\"line\">            start++;</span><br><span class=\"line\">            end--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"Linked-List\"><a href=\"#Linked-List\" class=\"headerlink\" title=\"Linked List\"></a>Linked List</h2><h3 id=\"138-Copy-List-with-Random-Pointer-Medium\"><a href=\"#138-Copy-List-with-Random-Pointer-Medium\" class=\"headerlink\" title=\"138. Copy List with Random Pointer (Medium) @\"></a>138. Copy List with Random Pointer (Medium) <a href=\"https://leetcode.com/problems/copy-list-with-random-pointer/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p>\n<p>Return a <a href=\"https://en.wikipedia.org/wiki/Object_copying#Deep_copy\" target=\"_blank\" rel=\"noopener\"><strong>deep copy</strong></a> of the list.</p>\n<p>The Linked List is represented in the input/output as a list of <code>n</code> nodes. Each node is represented as a pair of <code>[val, random_index]</code> where:</p>\n<ul>\n<li><code>val</code>: an integer representing <code>Node.val</code></li>\n<li><code>random_index</code>: the index of the node (range from <code>0</code> to <code>n-1</code>) where random pointer points to, or <code>null</code> if it does not point to any node.</li>\n</ul>\n<p><strong>Example 1:</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2019/12/18/e1.png\" alt=\"img\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class=\"line\">&gt; Output: [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2019/12/18/e2.png\" alt=\"img\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: head = [[1,1],[2,1]]</span><br><span class=\"line\">&gt; Output: [[1,1],[2,1]]</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 3:</strong></p>\n<p><strong><img src=\"https://assets.leetcode.com/uploads/2019/12/18/e3.png\" alt=\"img\"></strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: head = [[3,null],[3,0],[3,null]]</span><br><span class=\"line\">&gt; Output: [[3,null],[3,0],[3,null]]</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 4:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: head = []</span><br><span class=\"line\">&gt; Output: []</span><br><span class=\"line\">&gt; Explanation: Given linked list is empty (null pointer), so return null.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution 1 HashMap + 2 iterations </p>\n<p>第一种方法，就是使用HashMap来坐，HashMap的key存原始pointer，value存新的pointer。</p>\n<ul>\n<li>第一遍，先不copy random的值，只copy数值建立好新的链表。并把新旧pointer存在HashMap中。</li>\n<li>第二遍，遍历旧表，复制random的值，因为第一遍已经把链表复制好了并且也存在HashMap里了，所以只需从HashMap中，把当前旧的node.random作为key值，得到新的value的值，并把其赋给新node.random就好。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">// Definition for a Node.</span></span><br><span class=\"line\"><span class=\"comment\">class Node &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    int val;</span></span><br><span class=\"line\"><span class=\"comment\">    Node next;</span></span><br><span class=\"line\"><span class=\"comment\">    Node random;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    public Node(int val) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        this.val = val;</span></span><br><span class=\"line\"><span class=\"comment\">        this.next = null;</span></span><br><span class=\"line\"><span class=\"comment\">        this.random = null;</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Node <span class=\"title\">copyRandomList</span><span class=\"params\">(Node head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        HashMap&lt;Node, Node&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        Node newHead = <span class=\"keyword\">new</span> Node(head.val);</span><br><span class=\"line\">        map.put(head, newHead);</span><br><span class=\"line\">        Node oldPtr = head.next;</span><br><span class=\"line\">        Node newPtr = newHead;</span><br><span class=\"line\">        <span class=\"comment\">//first iterate the linked list</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (oldPtr != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//link next node</span></span><br><span class=\"line\">            Node newNode = <span class=\"keyword\">new</span> Node(oldPtr.val);</span><br><span class=\"line\">            newPtr.next = newNode;</span><br><span class=\"line\">            <span class=\"comment\">//update hashmap</span></span><br><span class=\"line\">            map.put(oldPtr, newNode);</span><br><span class=\"line\">            </span><br><span class=\"line\">            oldPtr = oldPtr.next;</span><br><span class=\"line\">            newPtr = newPtr.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        oldPtr = head;</span><br><span class=\"line\">        newPtr = newHead;</span><br><span class=\"line\">        <span class=\"comment\">//second iterate the linked list -&gt; update random ptr</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(oldPtr != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//update random ptr of new list</span></span><br><span class=\"line\">            newPtr.random = map.get(oldPtr.random);</span><br><span class=\"line\">            </span><br><span class=\"line\">            oldPtr = oldPtr.next;</span><br><span class=\"line\">            newPtr = newPtr.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> newHead;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 2 3-iteration</p>\n<p>第二种方法不使用HashMap来做，使空间复杂度降为O(1)，不过需要3次遍历list，时间复杂度为O(3n)=O(n)。</p>\n<ul>\n<li>第一遍，对每个node进行复制，并插入其原始node的后面，新旧交替，变成重复链表。如：原始：1-&gt;2-&gt;3-&gt;null，复制后：1-&gt;1-&gt;2-&gt;2-&gt;3-&gt;3-&gt;null</li>\n<li>第二遍，遍历每个旧node，把旧node的random的复制给新node的random，因为链表已经是新旧交替的。所以复制方法为：<strong>node.next.random = node.random.next</strong> 前面是说旧node的next的random，就是新node的random，后面是旧node的random的next，正好是新node，是从旧random复制来的。</li>\n<li>第三遍，则是把新旧两个表拆开，返回新的表即可。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">// Definition for a Node.</span></span><br><span class=\"line\"><span class=\"comment\">class Node &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    int val;</span></span><br><span class=\"line\"><span class=\"comment\">    Node next;</span></span><br><span class=\"line\"><span class=\"comment\">    Node random;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    public Node(int val) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        this.val = val;</span></span><br><span class=\"line\"><span class=\"comment\">        this.next = null;</span></span><br><span class=\"line\"><span class=\"comment\">        this.random = null;</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Node <span class=\"title\">copyRandomList</span><span class=\"params\">(Node head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        Node cur = head;</span><br><span class=\"line\">        <span class=\"comment\">//1st iteration: copy current node and link it to next</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            Node newNode = <span class=\"keyword\">new</span> Node(cur.val);</span><br><span class=\"line\">            newNode.next = cur.next;</span><br><span class=\"line\">            cur.next = newNode;</span><br><span class=\"line\">            </span><br><span class=\"line\">            cur = newNode.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//2ed iteration: update random node</span></span><br><span class=\"line\">        cur = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cur.random != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                cur.next.random = cur.random.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cur = cur.next.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//3rd iteration: </span></span><br><span class=\"line\">        cur = head; <span class=\"comment\">//point to old node</span></span><br><span class=\"line\">        Node newHead = head.next;<span class=\"comment\">//initialize new head</span></span><br><span class=\"line\">        Node copy = newHead;<span class=\"comment\">//point to new node</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// method 1</span></span><br><span class=\"line\"><span class=\"comment\">//         while (copy.next != null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//             //old</span></span><br><span class=\"line\"><span class=\"comment\">//             cur.next = cur.next.next;</span></span><br><span class=\"line\"><span class=\"comment\">//             cur = cur.next;</span></span><br><span class=\"line\">            </span><br><span class=\"line\"><span class=\"comment\">//             //new</span></span><br><span class=\"line\"><span class=\"comment\">//             copy.next = copy.next.next;</span></span><br><span class=\"line\"><span class=\"comment\">//             copy = copy.next;</span></span><br><span class=\"line\"><span class=\"comment\">//         &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//         cur.next = cur.next.next;</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//method 2</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            copy = cur.next;</span><br><span class=\"line\">            cur.next = copy.next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (copy.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                copy.next = copy.next.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cur = cur.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> newHead;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"141-Linked-List-Cycle-Easy\"><a href=\"#141-Linked-List-Cycle-Easy\" class=\"headerlink\" title=\"141. Linked List Cycle (Easy) @\"></a>141. Linked List Cycle (Easy) <a href=\"https://leetcode.com/problems/linked-list-cycle/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given a linked list, determine if it has a cycle in it.</p>\n<p>To represent a cycle in the given linked list, we use an integer <code>pos</code> which represents the position (0-indexed) in the linked list where tail connects to. If <code>pos</code> is <code>-1</code>, then there is no cycle in the linked list.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: head = [3,2,0,-4], pos = 1</span><br><span class=\"line\">&gt; Output: true</span><br><span class=\"line\">&gt; Explanation: There is a cycle in the linked list, where tail connects to the second node.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><img src=\"https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png\" alt=\"img\"></p>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: head = [1,2], pos = 0</span><br><span class=\"line\">&gt; Output: true</span><br><span class=\"line\">&gt; Explanation: There is a cycle in the linked list, where tail connects to the first node.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><img src=\"https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png\" alt=\"img\"></p>\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: head = [1], pos = -1</span><br><span class=\"line\">&gt; Output: false</span><br><span class=\"line\">&gt; Explanation: There is no cycle in the linked list.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><img src=\"https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png\" alt=\"img\"></p>\n<p><strong>Follow up:</strong></p>\n<p>Can you solve it using <em>O(1)</em> (i.e. constant) memory?</p>\n</blockquote>\n<p>Solution 1 HashSet</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasCycle</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">    Set&lt;ListNode&gt; nodesSeen = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (head != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nodesSeen.contains(head)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            nodesSeen.add(head);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        head = head.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 2 Two ptrs</p>\n<ul>\n<li>if slow and fast ptr meet then it much contains a cycle.<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         val = x;</span></span><br><span class=\"line\"><span class=\"comment\"> *         next = null;</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasCycle</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span> || head.next == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        ListNode slow = head;</span><br><span class=\"line\">        ListNode fast = head.next;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (slow != fast) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (fast == <span class=\"keyword\">null</span> || fast.next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            fast = fast.next.next;</span><br><span class=\"line\">            slow = slow.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"146-LRU-Cache-Medium\"><a href=\"#146-LRU-Cache-Medium\" class=\"headerlink\" title=\"146. LRU Cache (Medium) @\"></a>146. LRU Cache (Medium) <a href=\"https://leetcode.com/problems/lru-cache/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Design and implement a data structure for <a href=\"https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU\" target=\"_blank\" rel=\"noopener\">Least Recently Used (LRU) cache</a>. It should support the following operations: <code>get</code> and <code>put</code>.</p>\n<p><code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br><code>put(key, value)</code> - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</p>\n<p>The cache is initialized with a <strong>positive</strong> capacity.</p>\n<p><strong>Follow up:</strong><br>Could you do both operations in <strong>O(1)</strong> time complexity?</p>\n<p><strong>Example:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; LRUCache cache = new LRUCache( 2 /* capacity */ );</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; cache.put(1, 1);</span><br><span class=\"line\">&gt; cache.put(2, 2);</span><br><span class=\"line\">&gt; cache.get(1);       // returns 1</span><br><span class=\"line\">&gt; cache.put(3, 3);    // evicts key 2</span><br><span class=\"line\">&gt; cache.get(2);       // returns -1 (not found)</span><br><span class=\"line\">&gt; cache.put(4, 4);    // evicts key 1</span><br><span class=\"line\">&gt; cache.get(1);       // returns -1 (not found)</span><br><span class=\"line\">&gt; cache.get(3);       // returns 3</span><br><span class=\"line\">&gt; cache.get(4);       // returns 4</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution 1 LinkedHashMap</p>\n<ul>\n<li><a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html\" target=\"_blank\" rel=\"noopener\">LinkedHashMap</a></li>\n<li>LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder)</li>\n<li>作为一般规则，默认负载因子（0.75）在时间和空间成本上提供了很好的折衷。较高的值会降低空间开销，但提高查找成本（体现在大多数的HashMap类的操作，包括get和put）。设置初始大小时，应该考虑预计的entry数在map及其负载系数，并且尽量减少rehash操作的次数。如果初始容量大于最大条目数除以负载因子，rehash操作将不会发生。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LRUCache</span> <span class=\"keyword\">extends</span> <span class=\"title\">LinkedHashMap</span>&lt;<span class=\"title\">Integer</span>, <span class=\"title\">Integer</span>&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> capacity;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LRUCache</span><span class=\"params\">(<span class=\"keyword\">int</span> capacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(capacity, <span class=\"number\">0.75F</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.capacity = capacity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.getOrDefault(key, -<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(<span class=\"keyword\">int</span> key, <span class=\"keyword\">int</span> value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.put(key, value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">removeEldestEntry</span><span class=\"params\">(Map.Entry&lt;Integer, Integer&gt; eldest)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> size() &gt; capacity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * LRUCache obj = new LRUCache(capacity);</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_1 = obj.get(key);</span></span><br><span class=\"line\"><span class=\"comment\"> * obj.put(key,value);</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n<p>Solution 2 Linked List + HashMap (implementation of sol 1)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LRUCache</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DLinkedNode</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> key;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> val;</span><br><span class=\"line\">        DLinkedNode prev;</span><br><span class=\"line\">        DLinkedNode next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">addNode</span><span class=\"params\">(DLinkedNode node)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//always add node right after head</span></span><br><span class=\"line\">        node.next = head.next;</span><br><span class=\"line\">        node.prev = head;</span><br><span class=\"line\">        </span><br><span class=\"line\">        head.next.prev = node;</span><br><span class=\"line\">        head.next = node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">removeNode</span><span class=\"params\">(DLinkedNode node)</span> </span>&#123;</span><br><span class=\"line\">        node.prev.next = node.next;</span><br><span class=\"line\">        node.next.prev = node.prev;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">moveToHead</span><span class=\"params\">(DLinkedNode node)</span> </span>&#123;</span><br><span class=\"line\">        removeNode(node);</span><br><span class=\"line\">        addNode(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> DLinkedNode <span class=\"title\">popTail</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        DLinkedNode res = tail.prev;</span><br><span class=\"line\">        removeNode(res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> HashMap&lt;Integer, DLinkedNode&gt; cache = <span class=\"keyword\">new</span> HashMap&lt;Integer, DLinkedNode&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> capacity;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> DLinkedNode head, tail;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LRUCache</span><span class=\"params\">(<span class=\"keyword\">int</span> capacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.size = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.capacity = capacity;</span><br><span class=\"line\">        </span><br><span class=\"line\">        head = <span class=\"keyword\">new</span> DLinkedNode();</span><br><span class=\"line\">        tail = <span class=\"keyword\">new</span> DLinkedNode();</span><br><span class=\"line\">        </span><br><span class=\"line\">        head.next = tail;</span><br><span class=\"line\">        tail.prev = head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> key)</span> </span>&#123;</span><br><span class=\"line\">        DLinkedNode node = cache.get(key);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node == <span class=\"keyword\">null</span>) </span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//used =&gt; move to head</span></span><br><span class=\"line\">            moveToHead(node);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> node.val;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(<span class=\"keyword\">int</span> key, <span class=\"keyword\">int</span> value)</span> </span>&#123;</span><br><span class=\"line\">        DLinkedNode node = cache.get(key);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            DLinkedNode newNode = <span class=\"keyword\">new</span> DLinkedNode();</span><br><span class=\"line\">            newNode.key = key;</span><br><span class=\"line\">            newNode.val = value;</span><br><span class=\"line\">            </span><br><span class=\"line\">            cache.put(key, newNode);<span class=\"comment\">//update cache(HashMap)</span></span><br><span class=\"line\">            addNode(newNode); <span class=\"comment\">//update Linked List</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            size++;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (size &gt; capacity) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//pop tail</span></span><br><span class=\"line\">                DLinkedNode tail = popTail();</span><br><span class=\"line\">                cache.remove(tail.key);</span><br><span class=\"line\">                size--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//update val</span></span><br><span class=\"line\">            node.val = value;</span><br><span class=\"line\">            moveToHead(node);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * LRUCache obj = new LRUCache(capacity);</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_1 = obj.get(key);</span></span><br><span class=\"line\"><span class=\"comment\"> * obj.put(key,value);</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"148-Sort-List-Medium\"><a href=\"#148-Sort-List-Medium\" class=\"headerlink\" title=\"148. Sort List (Medium) @\"></a>148. Sort List (Medium) <a href=\"https://leetcode.com/problems/sort-list/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Sort a linked list in <em>O</em>(<em>n</em> log <em>n</em>) time using constant space complexity.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: 4-&gt;2-&gt;1-&gt;3</span><br><span class=\"line\">&gt; Output: 1-&gt;2-&gt;3-&gt;4</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: -1-&gt;5-&gt;3-&gt;4-&gt;0</span><br><span class=\"line\">&gt; Output: -1-&gt;0-&gt;3-&gt;4-&gt;5</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution 1 Merge sort</p>\n<ul>\n<li>空间复杂度O(logn)， 不符合要求<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">sortList</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span> || head.next == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//find the mid point</span></span><br><span class=\"line\">        ListNode slow = head, fast = head.next;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (fast != <span class=\"keyword\">null</span> &amp;&amp; fast.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            slow = slow.next;</span><br><span class=\"line\">            fast = fast.next.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//mid = slow</span></span><br><span class=\"line\">        ListNode tmp = slow.next;</span><br><span class=\"line\">        slow.next = <span class=\"keyword\">null</span>; <span class=\"comment\">//cut</span></span><br><span class=\"line\">        <span class=\"comment\">//divide</span></span><br><span class=\"line\">        ListNode left = sortList(head);</span><br><span class=\"line\">        ListNode right = sortList(tmp);</span><br><span class=\"line\">        <span class=\"comment\">//merge</span></span><br><span class=\"line\">        ListNode cur = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">        ListNode res = cur;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left != <span class=\"keyword\">null</span> &amp;&amp; right != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (left.val &lt; right.val) &#123;</span><br><span class=\"line\">                cur.next = left;</span><br><span class=\"line\">                left = left.next;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                cur.next = right;</span><br><span class=\"line\">                right = right.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cur = cur.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//add the rest of left or right part</span></span><br><span class=\"line\">        cur.next = left != <span class=\"keyword\">null</span> ? left : right;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>Solution 2 Iteration<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">sortList</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span> || head.next == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        </span><br><span class=\"line\">        ListNode dummy = <span class=\"keyword\">new</span> ListNode(-<span class=\"number\">1</span>);</span><br><span class=\"line\">        dummy.next = head;</span><br><span class=\"line\">        <span class=\"comment\">//len of list</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> length = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (head != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            length++;</span><br><span class=\"line\">            head = head.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        head = dummy.next;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//loop logn times</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; length; i+= i) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//list was divided into 4 parts:</span></span><br><span class=\"line\">            <span class=\"comment\">//1. already sorted; 2. left part of list to be sorted;</span></span><br><span class=\"line\">            <span class=\"comment\">//3. right part of list to be sorted; 4. unsorted part of list</span></span><br><span class=\"line\">            ListNode success = dummy;</span><br><span class=\"line\">            ListNode left = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            ListNode right = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (head != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                left = head;</span><br><span class=\"line\">                head = cutFromHead(head, i);</span><br><span class=\"line\">                right = head;</span><br><span class=\"line\">                head = cutFromHead(head, i);</span><br><span class=\"line\">                <span class=\"comment\">//merge sort left and right, put them after success, and update success</span></span><br><span class=\"line\">                success.next = mergeLists(left, right);</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (success.next != <span class=\"keyword\">null</span>) success = success.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            head = dummy.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dummy.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//cut the list from head with n-len and return (n+1)th node</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> ListNode <span class=\"title\">cutFromHead</span><span class=\"params\">(ListNode head, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (head != <span class=\"keyword\">null</span> &amp;&amp; --n &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            head = head.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        ListNode next = head.next;</span><br><span class=\"line\">        head.next = <span class=\"keyword\">null</span>; <span class=\"comment\">//cut</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//merge sort 2 lists</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> ListNode <span class=\"title\">mergeLists</span><span class=\"params\">(ListNode left, ListNode right)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> right;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (right == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">        </span><br><span class=\"line\">        ListNode dummy = <span class=\"keyword\">new</span> ListNode(-<span class=\"number\">1</span>);</span><br><span class=\"line\">        ListNode cur = dummy;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left != <span class=\"keyword\">null</span> &amp;&amp; right != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (left.val &lt; right.val) &#123;</span><br><span class=\"line\">                cur.next = left;</span><br><span class=\"line\">                left = left.next;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                cur.next = right;</span><br><span class=\"line\">                right = right.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cur = cur.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cur.next = left != <span class=\"keyword\">null</span> ? left : right;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dummy.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"160-Intersection-of-Two-Linked-Lists-Easy\"><a href=\"#160-Intersection-of-Two-Linked-Lists-Easy\" class=\"headerlink\" title=\"160. Intersection of Two Linked Lists (Easy) @\"></a>160. Intersection of Two Linked Lists (Easy) <a href=\"https://leetcode.com/problems/intersection-of-two-linked-lists/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Write a program to find the node at which the intersection of two singly linked lists begins.</p>\n<p>For example, the following two linked lists:</p>\n<p><a href=\"https://assets.leetcode.com/uploads/2018/12/13/160_statement.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://assets.leetcode.com/uploads/2018/12/13/160_statement.png\" alt=\"img\"></a></p>\n<p>begin to intersect at node c1.</p>\n<p><strong>Example 1:</strong></p>\n<p><a href=\"https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png\" alt=\"img\"></a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3</span><br><span class=\"line\">&gt; Output: Reference of the node with value = 8</span><br><span class=\"line\">&gt; Input Explanation: The intersected node&apos;s value is 8 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,0,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<p><a href=\"https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png\" alt=\"img\"></a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</span><br><span class=\"line\">&gt; Output: Reference of the node with value = 2</span><br><span class=\"line\">&gt; Input Explanation: The intersected node&apos;s value is 2 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [0,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 3:</strong></p>\n<p><a href=\"https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png\" alt=\"img\"></a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2</span><br><span class=\"line\">&gt; Output: null</span><br><span class=\"line\">&gt; Input Explanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.</span><br><span class=\"line\">&gt; Explanation: The two lists do not intersect, so return null.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Notes:</strong></p>\n<ul>\n<li>If the two linked lists have no intersection at all, return <code>null</code>.</li>\n<li>The linked lists must retain their original structure after the function returns.</li>\n<li>You may assume there are no cycles anywhere in the entire linked structure.</li>\n<li>Your code should preferably run in O(n) time and use only O(1) memory.</li>\n</ul>\n</blockquote>\n<p>Solution 1 Two round iteration</p>\n<ul>\n<li>尾部对齐，找出长度差，长的先走<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         val = x;</span></span><br><span class=\"line\"><span class=\"comment\"> *         next = null;</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">getIntersectionNode</span><span class=\"params\">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> lenA=<span class=\"number\">0</span>, lenB=<span class=\"number\">0</span>;</span><br><span class=\"line\">        ListNode A=headA, B=headB;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(A != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            lenA ++;</span><br><span class=\"line\">            A = A.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(B != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            lenB++;</span><br><span class=\"line\">            B = B.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        A = headA;</span><br><span class=\"line\">        B = headB;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(lenA &gt; lenB)&#123;</span><br><span class=\"line\">            A = A.next;</span><br><span class=\"line\">            lenA --;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(lenA &lt; lenB)&#123;</span><br><span class=\"line\">            B = B.next;</span><br><span class=\"line\">            lenB --;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(A != B)&#123;</span><br><span class=\"line\">            A = A.next;</span><br><span class=\"line\">            B = B.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> A;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>Solution 2 Two pointer + 环</p>\n<ul>\n<li>转化成判断环的问题<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         val = x;</span></span><br><span class=\"line\"><span class=\"comment\"> *         next = null;</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">getIntersectionNode</span><span class=\"params\">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (headA == <span class=\"keyword\">null</span> || headB == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        ListNode curA = headA;</span><br><span class=\"line\">        ListNode curB = headB;</span><br><span class=\"line\">        <span class=\"comment\">//将自身最后连接到另一个链表头，若存在intersection则形成环</span></span><br><span class=\"line\">        <span class=\"comment\">//如果形成环，则curA和curB一定在环的入口相交</span></span><br><span class=\"line\">        <span class=\"comment\">//若没有形成环，则都到达null</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (curA != curB) &#123;</span><br><span class=\"line\">            curA = curA == <span class=\"keyword\">null</span> ? headB : curA.next;</span><br><span class=\"line\">            curB = curB == <span class=\"keyword\">null</span> ? headA : curB.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> curA;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"Stack\"><a href=\"#Stack\" class=\"headerlink\" title=\"Stack\"></a>Stack</h2><h3 id=\"150-Evaluate-Reverse-Polish-Notation-Medium\"><a href=\"#150-Evaluate-Reverse-Polish-Notation-Medium\" class=\"headerlink\" title=\"150. Evaluate Reverse Polish Notation (Medium) @\"></a>150. Evaluate Reverse Polish Notation (Medium) <a href=\"https://leetcode.com/problems/evaluate-reverse-polish-notation/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Evaluate the value of an arithmetic expression in <a href=\"http://en.wikipedia.org/wiki/Reverse_Polish_notation\" target=\"_blank\" rel=\"noopener\">Reverse Polish Notation</a>.</p>\n<p>Valid operators are <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>. Each operand may be an integer or another expression.</p>\n<p><strong>Note:</strong></p>\n<ul>\n<li>Division between two integers should truncate toward zero.</li>\n<li>The given RPN expression is always valid. That means the expression would always evaluate to a result and there won’t be any divide by zero operation.</li>\n</ul>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]</span><br><span class=\"line\">&gt; Output: 9</span><br><span class=\"line\">&gt; Explanation: ((2 + 1) * 3) = 9</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]</span><br><span class=\"line\">&gt; Output: 6</span><br><span class=\"line\">&gt; Explanation: (4 + (13 / 5)) = 6</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]</span><br><span class=\"line\">&gt; Output: 22</span><br><span class=\"line\">&gt; Explanation: </span><br><span class=\"line\">&gt;   ((10 * (6 / ((9 + 3) * -11))) + 17) + 5</span><br><span class=\"line\">&gt; = ((10 * (6 / (12 * -11))) + 17) + 5</span><br><span class=\"line\">&gt; = ((10 * (6 / -132)) + 17) + 5</span><br><span class=\"line\">&gt; = ((10 * 0) + 17) + 5</span><br><span class=\"line\">&gt; = (0 + 17) + 5</span><br><span class=\"line\">&gt; = 17 + 5</span><br><span class=\"line\">&gt; = 22</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution 1 Stack<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">evalRPN</span><span class=\"params\">(String[] tokens)</span> </span>&#123;</span><br><span class=\"line\">        Stack&lt;Integer&gt; stack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String s : tokens) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s.equals(<span class=\"string\">\"+\"</span>)) &#123;</span><br><span class=\"line\">                stack.push(stack.pop() + stack.pop());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s.equals(<span class=\"string\">\"-\"</span>)) &#123;</span><br><span class=\"line\">                stack.push(- stack.pop() + stack.pop());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s.equals(<span class=\"string\">\"*\"</span>)) &#123;</span><br><span class=\"line\">                stack.push(stack.pop() * stack.pop());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s.equals(<span class=\"string\">\"/\"</span>)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> dividend = stack.pop();</span><br><span class=\"line\">                stack.push(stack.pop() / dividend);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">//normal numbers</span></span><br><span class=\"line\">                stack.push(Integer.parseInt(s));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> stack.pop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"155-Min-Stack-Medium\"><a href=\"#155-Min-Stack-Medium\" class=\"headerlink\" title=\"155. Min Stack (Medium) @\"></a>155. Min Stack (Medium) <a href=\"https://leetcode.com/problems/min-stack/submissions/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p>\n<ul>\n<li>push(x) – Push element x onto stack.</li>\n<li>pop() – Removes the element on top of the stack.</li>\n<li>top() – Get the top element.</li>\n<li>getMin() – Retrieve the minimum element in the stack.</li>\n</ul>\n<p><strong>Example:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; MinStack minStack = new MinStack();</span><br><span class=\"line\">&gt; minStack.push(-2);</span><br><span class=\"line\">&gt; minStack.push(0);</span><br><span class=\"line\">&gt; minStack.push(-3);</span><br><span class=\"line\">&gt; minStack.getMin();   --&gt; Returns -3.</span><br><span class=\"line\">&gt; minStack.pop();</span><br><span class=\"line\">&gt; minStack.top();      --&gt; Returns 0.</span><br><span class=\"line\">&gt; minStack.getMin();   --&gt; Returns -2.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Solution 1 synchronous data stack and helper stack<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MinStack</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> Stack&lt;Integer&gt; data;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Stack&lt;Integer&gt; minElement;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** initialize your data structure here. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MinStack</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        data = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">        minElement = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        data.add(x);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (minElement.isEmpty() || minElement.peek() &gt;= x) &#123;</span><br><span class=\"line\">            minElement.add(x);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            minElement.add(minElement.peek());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!data.isEmpty()) &#123;</span><br><span class=\"line\">            data.pop();</span><br><span class=\"line\">            minElement.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">top</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!data.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> data.peek();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"stack is empty\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getMin</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!minElement.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> minElement.peek();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"stack is empty\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * MinStack obj = new MinStack();</span></span><br><span class=\"line\"><span class=\"comment\"> * obj.push(x);</span></span><br><span class=\"line\"><span class=\"comment\"> * obj.pop();</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_3 = obj.top();</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_4 = obj.getMin();</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure></p>\n<p>Solution 2 asynchronous </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MinStack</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> Stack&lt;Integer&gt; data;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Stack&lt;Integer&gt; minElement;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** initialize your data structure here. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MinStack</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        data = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">        minElement = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 思路 2：辅助栈和数据栈不同步</span></span><br><span class=\"line\">    <span class=\"comment\">// 关键 1：辅助栈的元素空的时候，必须放入新进来的数</span></span><br><span class=\"line\">    <span class=\"comment\">// 关键 2：新来的数小于或者等于辅助栈栈顶元素的时候，才放入（特别注意这里等于要考虑进去）</span></span><br><span class=\"line\">    <span class=\"comment\">// 关键 3：出栈的时候，辅助栈的栈顶元素等于数据栈的栈顶元素，才出栈，即\"出栈保持同步\"就可以了</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        data.add(x);</span><br><span class=\"line\">        <span class=\"comment\">// 辅助栈在必要的时候才增加</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (minElement.isEmpty() || minElement.peek() &gt;= x) &#123;</span><br><span class=\"line\">            minElement.add(x);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//关键3: 数据栈一定pop</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!data.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 注意：声明成 int 类型，这里完成了自动拆箱，从 Integer 转成了 int，因此下面的比较可以使用 \"==\" 运算符</span></span><br><span class=\"line\">            <span class=\"comment\">// 参考资料：https://www.cnblogs.com/GuoYaxiang/p/6931264.html</span></span><br><span class=\"line\">            <span class=\"comment\">// 如果把 top 变量声明成 Integer 类型，下面的比较就得使用 equals 方法</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> top = data.pop();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (top == minElement.peek()) &#123;</span><br><span class=\"line\">                minElement.pop();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">top</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!data.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> data.peek();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"stack is empty\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getMin</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!minElement.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> minElement.peek();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"stack is empty\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * MinStack obj = new MinStack();</span></span><br><span class=\"line\"><span class=\"comment\"> * obj.push(x);</span></span><br><span class=\"line\"><span class=\"comment\"> * obj.pop();</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_3 = obj.top();</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_4 = obj.getMin();</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n<p>Solution 3 Linked List</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MinStack</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> Node head;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> val;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> min;</span><br><span class=\"line\">        Node next;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Node(<span class=\"keyword\">int</span> val, <span class=\"keyword\">int</span> min, Node next) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.val = val;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.min = min;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.next = next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            head = <span class=\"keyword\">new</span> Node(x, x, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            head = <span class=\"keyword\">new</span> Node(x, Math.min(head.min, x), head);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        head = head.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">top</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head.val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getMin</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head.min;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * MinStack obj = new MinStack();</span></span><br><span class=\"line\"><span class=\"comment\"> * obj.push(x);</span></span><br><span class=\"line\"><span class=\"comment\"> * obj.pop();</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_3 = obj.top();</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_4 = obj.getMin();</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Math\"><a href=\"#Math\" class=\"headerlink\" title=\"Math\"></a>Math</h2><h3 id=\"172-Factorial-Trailing-Zeroes-Easy\"><a href=\"#172-Factorial-Trailing-Zeroes-Easy\" class=\"headerlink\" title=\"172. Factorial Trailing Zeroes (Easy) @\"></a>172. Factorial Trailing Zeroes (Easy) <a href=\"https://leetcode.com/problems/factorial-trailing-zeroes/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Given an integer <em>n</em>, return the number of trailing zeroes in <em>n</em>!.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: 3</span><br><span class=\"line\">&gt; Output: 0</span><br><span class=\"line\">&gt; Explanation: 3! = 6, no trailing zero.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: 5</span><br><span class=\"line\">&gt; Output: 1</span><br><span class=\"line\">&gt; Explanation: 5! = 120, one trailing zero.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Note:</strong> Your solution should be in logarithmic time complexity.</p>\n</blockquote>\n<p>Solution </p>\n<ul>\n<li>判断n!中有多少个5</li>\n<li><a href=\"https://leetcode-cn.com/problems/factorial-trailing-zeroes/solution/xiang-xi-tong-su-de-si-lu-fen-xi-by-windliang-3/\" target=\"_blank\" rel=\"noopener\">Detail</a></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">trailingZeroes</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (n &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        count += n / <span class=\"number\">5</span>;</span><br><span class=\"line\">        n = n / <span class=\"number\">5</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"190-Reverse-Bits-Easy\"><a href=\"#190-Reverse-Bits-Easy\" class=\"headerlink\" title=\"190. Reverse Bits (Easy) @\"></a>190. Reverse Bits (Easy) <a href=\"https://leetcode.com/problems/reverse-bits/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Reverse bits of a given 32 bits unsigned integer.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: 00000010100101000001111010011100</span><br><span class=\"line\">&gt; Output: 00111001011110000010100101000000</span><br><span class=\"line\">&gt; Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: 11111111111111111111111111111101</span><br><span class=\"line\">&gt; Output: 10111111111111111111111111111111</span><br><span class=\"line\">&gt; Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Note:</strong></p>\n<ul>\n<li>Note that in some languages such as Java, there is no unsigned integer type. In this case, both input and output will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned.</li>\n<li>In Java, the compiler represents the signed integers using <a href=\"https://en.wikipedia.org/wiki/Two&#39;s_complement\" target=\"_blank\" rel=\"noopener\">2’s complement notation</a>. Therefore, in <strong>Example 2</strong> above the input represents the signed integer <code>-3</code> and the output represents the signed integer <code>-1073741825</code>.</li>\n</ul>\n<p><strong>Follow up</strong>:</p>\n<p>If this function is called many times, how would you optimize it?</p>\n</blockquote>\n<p>Solution 1 shift</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// you need treat n as an unsigned value</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">reverseBits</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (count &lt; <span class=\"number\">32</span>) &#123;</span><br><span class=\"line\">            res &lt;&lt;= <span class=\"number\">1</span>; <span class=\"comment\">//res is shifted by 1 position to left</span></span><br><span class=\"line\">            res |= (n &amp; <span class=\"number\">1</span>); <span class=\"comment\">//just pick the last pos of n to OR res</span></span><br><span class=\"line\">            n &gt;&gt;= <span class=\"number\">1</span>; <span class=\"comment\">//n is shifted by 1 pos to right =&gt; get rid of the last pos</span></span><br><span class=\"line\">            count++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"191-Number-of-1-Bits-Easy\"><a href=\"#191-Number-of-1-Bits-Easy\" class=\"headerlink\" title=\"191. Number of 1 Bits (Easy) @\"></a>191. Number of 1 Bits (Easy) <a href=\"https://leetcode.com/problems/number-of-1-bits/\" target=\"_blank\" rel=\"noopener\">@</a></h3><blockquote>\n<p>Write a function that takes an unsigned integer and return the number of ‘1’ bits it has (also known as the <a href=\"http://en.wikipedia.org/wiki/Hamming_weight\" target=\"_blank\" rel=\"noopener\">Hamming weight</a>).</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: 00000000000000000000000000001011</span><br><span class=\"line\">&gt; Output: 3</span><br><span class=\"line\">&gt; Explanation: The input binary string 00000000000000000000000000001011 has a total of three &apos;1&apos; bits.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: 00000000000000000000000010000000</span><br><span class=\"line\">&gt; Output: 1</span><br><span class=\"line\">&gt; Explanation: The input binary string 00000000000000000000000010000000 has a total of one &apos;1&apos; bit.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Input: 11111111111111111111111111111101</span><br><span class=\"line\">&gt; Output: 31</span><br><span class=\"line\">&gt; Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one &apos;1&apos; bits.</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p><strong>Note:</strong></p>\n<ul>\n<li>Note that in some languages such as Java, there is no unsigned integer type. In this case, the input will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned.</li>\n<li>In Java, the compiler represents the signed integers using <a href=\"https://en.wikipedia.org/wiki/Two&#39;s_complement\" target=\"_blank\" rel=\"noopener\">2’s complement notation</a>. Therefore, in <strong>Example 3</strong> above the input represents the signed integer <code>-3</code>.</li>\n</ul>\n<p><strong>Follow up</strong>:</p>\n<p>If this function is called many times, how would you optimize it?</p>\n</blockquote>\n<p>Solution 1</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// you need to treat n as an unsigned value</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hammingWeight</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">32</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((n &amp; <span class=\"number\">1</span>) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                res++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            n &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Solution 2 Flip<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// you need to treat n as an unsigned value</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hammingWeight</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (n != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            res++;</span><br><span class=\"line\">            <span class=\"comment\">//always flip the least-significant 1-bit to 0</span></span><br><span class=\"line\">            n &amp;= (n - <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Graph\"><a href=\"#Graph\" class=\"headerlink\" title=\"Graph\"></a>Graph</h2><h2 id=\"Sliding-Window\"><a href=\"#Sliding-Window\" class=\"headerlink\" title=\"Sliding Window\"></a>Sliding Window</h2><h2 id=\"Partition\"><a href=\"#Partition\" class=\"headerlink\" title=\"Partition\"></a>Partition</h2>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ckcqk30wy0005pu9kdim89e9o","tag_id":"ckcqk30wv0003pu9kb98jgdp0","_id":"ckcqk30x00007pu9kv25uwhiu"},{"post_id":"ckcqk30wp0000pu9kpt0o537m","tag_id":"ckcqk30wv0003pu9kb98jgdp0","_id":"ckcqk30x10008pu9kdalr1iut"},{"post_id":"ckcqk30wt0002pu9kvp0fv8ke","tag_id":"ckcqk30x00006pu9kqutqc2hi","_id":"ckcqk30x1000apu9k4hk89uuu"},{"post_id":"ckcqk30wx0004pu9k2jaew5pa","tag_id":"ckcqk30x10009pu9koegc2yj2","_id":"ckcqk30x1000bpu9k6l4kwyxb"},{"post_id":"ckcqk30xf000cpu9kamvp0t7r","tag_id":"ckcqk30xg000dpu9kzccul2h0","_id":"ckcqk30xh000epu9klmhlw0f1"}],"Tag":[{"name":"Softwares","_id":"ckcqk30wv0003pu9kb98jgdp0"},{"name":"JEE","_id":"ckcqk30x00006pu9kqutqc2hi"},{"name":"Reading","_id":"ckcqk30x10009pu9koegc2yj2"},{"name":"Programming","_id":"ckcqk30xg000dpu9kzccul2h0"}]}}